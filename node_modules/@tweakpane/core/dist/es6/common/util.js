import { forceCast, isEmpty } from '../misc/type-util';
import { findConstraint } from './constraint/composite';
import { ListConstraint } from './constraint/list';
import { StepConstraint } from './constraint/step';
import { getDecimalDigits } from './number-util';
import { ParamsParsers } from './params-parsers';
export function parseListOptions(value) {
    const p = ParamsParsers;
    if (Array.isArray(value)) {
        return p.required.array(p.required.object({
            text: p.required.string,
            value: p.required.raw,
        }))(value).value;
    }
    if (typeof value === 'object') {
        return p.required.raw(value)
            .value;
    }
    return undefined;
}
export function parsePickerLayout(value) {
    if (value === 'inline' || value === 'popup') {
        return value;
    }
    return undefined;
}
export function parsePointDimensionParams(value) {
    const p = ParamsParsers;
    return p.required.object({
        max: p.optional.number,
        min: p.optional.number,
        step: p.optional.number,
    })(value).value;
}
export function normalizeListOptions(options) {
    if (Array.isArray(options)) {
        return options;
    }
    const items = [];
    Object.keys(options).forEach((text) => {
        items.push({ text: text, value: options[text] });
    });
    return items;
}
/**
 * Tries to create a list constraint.
 * @template T The type of the raw value.
 * @param options The list options.
 * @return A constraint or null if not found.
 */
export function createListConstraint(options) {
    return !isEmpty(options)
        ? new ListConstraint(normalizeListOptions(forceCast(options)))
        : null;
}
function findStep(constraint) {
    const c = constraint ? findConstraint(constraint, StepConstraint) : null;
    if (!c) {
        return null;
    }
    return c.step;
}
/**
 * @hidden
 */
export function getSuitableDecimalDigits(constraint, rawValue) {
    const sc = constraint && findConstraint(constraint, StepConstraint);
    if (sc) {
        return getDecimalDigits(sc.step);
    }
    return Math.max(getDecimalDigits(rawValue), 2);
}
/**
 * @hidden
 */
export function getBaseStep(constraint) {
    const step = findStep(constraint);
    return step !== null && step !== void 0 ? step : 1;
}
/**
 * @hidden
 */
export function getSuitableDraggingScale(constraint, rawValue) {
    var _a;
    const sc = constraint && findConstraint(constraint, StepConstraint);
    const base = Math.abs((_a = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a !== void 0 ? _a : rawValue);
    return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
}
