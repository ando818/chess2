import { InputBindingApi } from '../blade/input-binding/api/input-binding';
import { InputBindingController } from '../blade/input-binding/controller/input-binding';
import { MonitorBindingApi } from '../blade/monitor-binding/api/monitor-binding';
import { MonitorBindingController } from '../blade/monitor-binding/controller/monitor-binding';
import { createBladeController } from '../blade/plugin';
import { RackApi } from '../blade/rack/api/rack';
import { RackController } from '../blade/rack/controller/rack';
import { TpError } from '../common/tp-error';
import { createInputBindingController, } from '../input-binding/plugin';
import { isEmpty } from '../misc/type-util';
import { createMonitorBindingController, } from '../monitor-binding/plugin';
/**
 * @hidden
 */
export class PluginPool {
    constructor() {
        this.pluginsMap_ = {
            blades: [],
            inputs: [],
            monitors: [],
        };
    }
    getAll() {
        return [
            ...this.pluginsMap_.blades,
            ...this.pluginsMap_.inputs,
            ...this.pluginsMap_.monitors,
        ];
    }
    register(r) {
        if (r.type === 'blade') {
            this.pluginsMap_.blades.unshift(r);
        }
        else if (r.type === 'input') {
            this.pluginsMap_.inputs.unshift(r);
        }
        else if (r.type === 'monitor') {
            this.pluginsMap_.monitors.unshift(r);
        }
    }
    createInput(document, target, params) {
        const initialValue = target.read();
        if (isEmpty(initialValue)) {
            throw new TpError({
                context: {
                    key: target.key,
                },
                type: 'nomatchingcontroller',
            });
        }
        const bc = this.pluginsMap_.inputs.reduce((result, plugin) => result !== null && result !== void 0 ? result : createInputBindingController(plugin, {
            document: document,
            target: target,
            params: params,
        }), null);
        if (bc) {
            return bc;
        }
        throw new TpError({
            context: {
                key: target.key,
            },
            type: 'nomatchingcontroller',
        });
    }
    createMonitor(document, target, params) {
        const bc = this.pluginsMap_.monitors.reduce((result, plugin) => result !== null && result !== void 0 ? result : createMonitorBindingController(plugin, {
            document: document,
            params: params,
            target: target,
        }), null);
        if (bc) {
            return bc;
        }
        throw new TpError({
            context: {
                key: target.key,
            },
            type: 'nomatchingcontroller',
        });
    }
    createBlade(document, params) {
        const bc = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : createBladeController(plugin, {
            document: document,
            params: params,
        }), null);
        if (!bc) {
            throw new TpError({
                type: 'nomatchingview',
                context: {
                    params: params,
                },
            });
        }
        return bc;
    }
    createBladeApi(bc) {
        if (bc instanceof InputBindingController) {
            return new InputBindingApi(bc);
        }
        if (bc instanceof MonitorBindingController) {
            return new MonitorBindingApi(bc);
        }
        if (bc instanceof RackController) {
            return new RackApi(bc, this);
        }
        const api = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : plugin.api({
            controller: bc,
            pool: this,
        }), null);
        if (!api) {
            throw TpError.shouldNeverHappen();
        }
        return api;
    }
}
