import { BindingTarget } from '../../../common/binding/target';
import { Emitter } from '../../../common/model/emitter';
import { TpError } from '../../../common/tp-error';
import { forceCast } from '../../../misc/type-util';
import { BladeApi } from '../../common/api/blade';
import { addButtonAsBlade, addFolderAsBlade, addSeparatorAsBlade, addTabAsBlade, } from '../../common/api/blade-rack';
import { RackLikeApi } from '../../common/api/rack-like-api';
import { TpChangeEvent, TpUpdateEvent } from '../../common/api/tp-event';
import { ValueBladeController } from '../../common/controller/value-blade';
import { NestedOrderedSet } from '../../common/model/nested-ordered-set';
import { InputBindingApi } from '../../input-binding/api/input-binding';
import { InputBindingController } from '../../input-binding/controller/input-binding';
import { MonitorBindingApi } from '../../monitor-binding/api/monitor-binding';
import { MonitorBindingController } from '../../monitor-binding/controller/monitor-binding';
export function findSubBladeApiSet(api) {
    if (api instanceof RackApi) {
        return api['apiSet_'];
    }
    if (api instanceof RackLikeApi) {
        return api['rackApi_']['apiSet_'];
    }
    return null;
}
function getApiByController(apiSet, controller) {
    const api = apiSet.find((api) => api.controller_ === controller);
    /* istanbul ignore next */
    if (!api) {
        throw TpError.shouldNeverHappen();
    }
    return api;
}
function createBindingTarget(obj, key, opt_id) {
    if (!BindingTarget.isBindable(obj)) {
        throw TpError.notBindable();
    }
    return new BindingTarget(obj, key, opt_id);
}
export class RackApi extends BladeApi {
    /**
     * @hidden
     */
    constructor(controller, pool) {
        super(controller);
        this.onRackAdd_ = this.onRackAdd_.bind(this);
        this.onRackRemove_ = this.onRackRemove_.bind(this);
        this.onRackInputChange_ = this.onRackInputChange_.bind(this);
        this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this);
        this.emitter_ = new Emitter();
        this.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
        this.pool_ = pool;
        const rack = this.controller_.rack;
        rack.emitter.on('add', this.onRackAdd_);
        rack.emitter.on('remove', this.onRackRemove_);
        rack.emitter.on('inputchange', this.onRackInputChange_);
        rack.emitter.on('monitorupdate', this.onRackMonitorUpdate_);
        rack.children.forEach((bc) => {
            this.setUpApi_(bc);
        });
    }
    get children() {
        return this.controller_.rack.children.map((bc) => getApiByController(this.apiSet_, bc));
    }
    addInput(object, key, opt_params) {
        const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        const doc = this.controller_.view.element.ownerDocument;
        const bc = this.pool_.createInput(doc, createBindingTarget(object, key, params.presetKey), params);
        const api = new InputBindingApi(bc);
        return this.add(api, params.index);
    }
    addMonitor(object, key, opt_params) {
        const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        const doc = this.controller_.view.element.ownerDocument;
        const bc = this.pool_.createMonitor(doc, createBindingTarget(object, key), params);
        const api = new MonitorBindingApi(bc);
        return forceCast(this.add(api, params.index));
    }
    addFolder(params) {
        return addFolderAsBlade(this, params);
    }
    addButton(params) {
        return addButtonAsBlade(this, params);
    }
    addSeparator(opt_params) {
        return addSeparatorAsBlade(this, opt_params);
    }
    addTab(params) {
        return addTabAsBlade(this, params);
    }
    add(api, opt_index) {
        this.controller_.rack.add(api.controller_, opt_index);
        // Replace generated API with specified one
        const gapi = this.apiSet_.find((a) => a.controller_ === api.controller_);
        if (gapi) {
            this.apiSet_.remove(gapi);
        }
        this.apiSet_.add(api);
        return api;
    }
    remove(api) {
        this.controller_.rack.remove(api.controller_);
    }
    addBlade(params) {
        const doc = this.controller_.view.element.ownerDocument;
        const bc = this.pool_.createBlade(doc, params);
        const api = this.pool_.createBladeApi(bc);
        return this.add(api, params.index);
    }
    on(eventName, handler) {
        const bh = handler.bind(this);
        this.emitter_.on(eventName, (ev) => {
            bh(ev.event);
        });
        return this;
    }
    setUpApi_(bc) {
        const api = this.apiSet_.find((api) => api.controller_ === bc);
        if (!api) {
            // Auto-fill missing API
            this.apiSet_.add(this.pool_.createBladeApi(bc));
        }
    }
    onRackAdd_(ev) {
        this.setUpApi_(ev.bladeController);
    }
    onRackRemove_(ev) {
        if (ev.isRoot) {
            const api = getApiByController(this.apiSet_, ev.bladeController);
            this.apiSet_.remove(api);
        }
    }
    onRackInputChange_(ev) {
        const bc = ev.bladeController;
        if (bc instanceof InputBindingController) {
            const api = getApiByController(this.apiSet_, bc);
            const binding = bc.binding;
            this.emitter_.emit('change', {
                event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last),
            });
        }
        else if (bc instanceof ValueBladeController) {
            const api = getApiByController(this.apiSet_, bc);
            this.emitter_.emit('change', {
                event: new TpChangeEvent(api, bc.value.rawValue, undefined, ev.options.last),
            });
        }
    }
    onRackMonitorUpdate_(ev) {
        /* istanbul ignore next */
        if (!(ev.bladeController instanceof MonitorBindingController)) {
            throw TpError.shouldNeverHappen();
        }
        const api = getApiByController(this.apiSet_, ev.bladeController);
        const binding = ev.bladeController.binding;
        this.emitter_.emit('update', {
            event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey),
        });
    }
}
