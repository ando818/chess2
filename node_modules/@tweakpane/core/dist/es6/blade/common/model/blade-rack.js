import { warnMissing } from '../../../common/compat';
import { Emitter } from '../../../common/model/emitter';
import { TpError } from '../../../common/tp-error';
import { forceCast, isPropertyWritable } from '../../../misc/type-util';
import { InputBindingController } from '../../input-binding/controller/input-binding';
import { MonitorBindingController } from '../../monitor-binding/controller/monitor-binding';
import { RackController } from '../../rack/controller/rack';
import { RackLikeController } from '../controller/rack-like';
import { ValueBladeController } from '../controller/value-blade';
import { NestedOrderedSet } from './nested-ordered-set';
function findInputBindingController(bcs, b) {
    for (let i = 0; i < bcs.length; i++) {
        const bc = bcs[i];
        if (bc instanceof InputBindingController && bc.binding === b) {
            return bc;
        }
    }
    return null;
}
function findMonitorBindingController(bcs, b) {
    for (let i = 0; i < bcs.length; i++) {
        const bc = bcs[i];
        if (bc instanceof MonitorBindingController && bc.binding === b) {
            return bc;
        }
    }
    return null;
}
function findValueBladeController(bcs, v) {
    for (let i = 0; i < bcs.length; i++) {
        const bc = bcs[i];
        if (bc instanceof ValueBladeController && bc.value === v) {
            return bc;
        }
    }
    return null;
}
function findSubRack(bc) {
    if (bc instanceof RackController) {
        return bc.rack;
    }
    if (bc instanceof RackLikeController) {
        return bc.rackController.rack;
    }
    return null;
}
function findSubBladeControllerSet(bc) {
    const rack = findSubRack(bc);
    return rack ? rack['bcSet_'] : null;
}
/**
 * A collection of blade controllers that manages positions and event propagation.
 */
export class BladeRack {
    constructor(config) {
        var _a, _b;
        this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
        this.onSetAdd_ = this.onSetAdd_.bind(this);
        this.onSetRemove_ = this.onSetRemove_.bind(this);
        this.onChildDispose_ = this.onChildDispose_.bind(this);
        this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
        this.onChildInputChange_ = this.onChildInputChange_.bind(this);
        this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
        this.onChildValueChange_ = this.onChildValueChange_.bind(this);
        this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
        this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
        this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
        this.onDescendantMonitorUpdate_ =
            this.onDescendantMonitorUpdate_.bind(this);
        this.emitter = new Emitter();
        this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
        (_b = this.blade_) === null || _b === void 0 ? void 0 : _b.value('positions').emitter.on('change', this.onBladePositionsChange_);
        this.viewProps = config.viewProps;
        this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
        this.bcSet_.emitter.on('add', this.onSetAdd_);
        this.bcSet_.emitter.on('remove', this.onSetRemove_);
    }
    get children() {
        return this.bcSet_.items;
    }
    add(bc, opt_index) {
        var _a;
        (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
        if (isPropertyWritable(bc, 'parent')) {
            bc.parent = this;
        }
        else {
            // TODO: Remove it in the next major version
            bc['parent_'] = this;
            warnMissing({
                key: 'parent',
                target: 'BladeController',
                place: 'BladeRack.add',
            });
        }
        this.bcSet_.add(bc, opt_index);
    }
    remove(bc) {
        if (isPropertyWritable(bc, 'parent')) {
            bc.parent = null;
        }
        else {
            // TODO: Remove it in the next major version
            bc['parent_'] = null;
            warnMissing({
                key: 'parent',
                target: 'BladeController',
                place: 'BladeRack.remove',
            });
        }
        this.bcSet_.remove(bc);
    }
    find(controllerClass) {
        return forceCast(this.bcSet_.allItems().filter((bc) => {
            return bc instanceof controllerClass;
        }));
    }
    onSetAdd_(ev) {
        this.updatePositions_();
        const isRoot = ev.target === ev.root;
        this.emitter.emit('add', {
            bladeController: ev.item,
            index: ev.index,
            isRoot: isRoot,
            sender: this,
        });
        if (!isRoot) {
            return;
        }
        const bc = ev.item;
        bc.viewProps.emitter.on('change', this.onChildViewPropsChange_);
        bc.blade
            .value('positions')
            .emitter.on('change', this.onChildPositionsChange_);
        bc.viewProps.handleDispose(this.onChildDispose_);
        if (bc instanceof InputBindingController) {
            bc.binding.emitter.on('change', this.onChildInputChange_);
        }
        else if (bc instanceof MonitorBindingController) {
            bc.binding.emitter.on('update', this.onChildMonitorUpdate_);
        }
        else if (bc instanceof ValueBladeController) {
            bc.value.emitter.on('change', this.onChildValueChange_);
        }
        else {
            const rack = findSubRack(bc);
            if (rack) {
                const emitter = rack.emitter;
                emitter.on('layout', this.onDescendantLayout_);
                emitter.on('inputchange', this.onDescendantInputChange_);
                emitter.on('monitorupdate', this.onDescendantMonitorUpdate_);
            }
        }
    }
    onSetRemove_(ev) {
        this.updatePositions_();
        const isRoot = ev.target === ev.root;
        this.emitter.emit('remove', {
            bladeController: ev.item,
            isRoot: isRoot,
            sender: this,
        });
        if (!isRoot) {
            return;
        }
        const bc = ev.item;
        if (bc instanceof InputBindingController) {
            bc.binding.emitter.off('change', this.onChildInputChange_);
        }
        else if (bc instanceof MonitorBindingController) {
            bc.binding.emitter.off('update', this.onChildMonitorUpdate_);
        }
        else if (bc instanceof ValueBladeController) {
            bc.value.emitter.off('change', this.onChildValueChange_);
        }
        else {
            const rack = findSubRack(bc);
            if (rack) {
                const emitter = rack.emitter;
                emitter.off('layout', this.onDescendantLayout_);
                emitter.off('inputchange', this.onDescendantInputChange_);
                emitter.off('monitorupdate', this.onDescendantMonitorUpdate_);
            }
        }
    }
    updatePositions_() {
        const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get('hidden'));
        const firstVisibleItem = visibleItems[0];
        const lastVisibleItem = visibleItems[visibleItems.length - 1];
        this.bcSet_.items.forEach((bc) => {
            const ps = [];
            if (bc === firstVisibleItem) {
                ps.push('first');
                if (!this.blade_ ||
                    this.blade_.get('positions').includes('veryfirst')) {
                    ps.push('veryfirst');
                }
            }
            if (bc === lastVisibleItem) {
                ps.push('last');
                if (!this.blade_ || this.blade_.get('positions').includes('verylast')) {
                    ps.push('verylast');
                }
            }
            bc.blade.set('positions', ps);
        });
    }
    onChildPositionsChange_() {
        this.updatePositions_();
        this.emitter.emit('layout', {
            sender: this,
        });
    }
    onChildViewPropsChange_(_ev) {
        this.updatePositions_();
        this.emitter.emit('layout', {
            sender: this,
        });
    }
    onChildDispose_() {
        const disposedUcs = this.bcSet_.items.filter((bc) => {
            return bc.viewProps.get('disposed');
        });
        disposedUcs.forEach((bc) => {
            this.bcSet_.remove(bc);
        });
    }
    onChildInputChange_(ev) {
        const bc = findInputBindingController(this.find(InputBindingController), ev.sender);
        if (!bc) {
            throw TpError.alreadyDisposed();
        }
        this.emitter.emit('inputchange', {
            bladeController: bc,
            options: ev.options,
            sender: this,
        });
    }
    onChildMonitorUpdate_(ev) {
        const bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);
        if (!bc) {
            throw TpError.alreadyDisposed();
        }
        this.emitter.emit('monitorupdate', {
            bladeController: bc,
            sender: this,
        });
    }
    onChildValueChange_(ev) {
        const bc = findValueBladeController(this.find(ValueBladeController), ev.sender);
        if (!bc) {
            throw TpError.alreadyDisposed();
        }
        this.emitter.emit('inputchange', {
            bladeController: bc,
            options: ev.options,
            sender: this,
        });
    }
    onDescendantLayout_(_) {
        this.updatePositions_();
        this.emitter.emit('layout', {
            sender: this,
        });
    }
    onDescendantInputChange_(ev) {
        this.emitter.emit('inputchange', {
            bladeController: ev.bladeController,
            options: ev.options,
            sender: this,
        });
    }
    onDescendantMonitorUpdate_(ev) {
        this.emitter.emit('monitorupdate', {
            bladeController: ev.bladeController,
            sender: this,
        });
    }
    onBladePositionsChange_() {
        this.updatePositions_();
    }
}
