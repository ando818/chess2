import { CompositeConstraint, findConstraint, } from '../../common/constraint/composite';
import { DefiniteRangeConstraint } from '../../common/constraint/definite-range';
import { ListConstraint } from '../../common/constraint/list';
import { RangeConstraint } from '../../common/constraint/range';
import { StepConstraint } from '../../common/constraint/step';
import { ListController } from '../../common/controller/list';
import { createNumberFormatter, numberFromUnknown, parseNumber, } from '../../common/converter/number';
import { ValueMap } from '../../common/model/value-map';
import { NumberTextController } from '../../common/number/controller/number-text';
import { SliderTextController } from '../../common/number/controller/slider-text';
import { ParamsParsers, parseParams, } from '../../common/params-parsers';
import { writePrimitive } from '../../common/primitive';
import { createListConstraint, getBaseStep, getSuitableDecimalDigits, getSuitableDraggingScale, parseListOptions, } from '../../common/util';
import { isEmpty } from '../../misc/type-util';
/**
 * Tries to create a step constraint.
 * @param params The input parameters object.
 * @return A constraint or null if not found.
 */
export function createStepConstraint(params, initialValue) {
    if ('step' in params && !isEmpty(params.step)) {
        return new StepConstraint(params.step, initialValue);
    }
    return null;
}
/**
 * Tries to create a range constraint.
 * @param params The input parameters object.
 * @return A constraint or null if not found.
 */
export function createRangeConstraint(params) {
    if (!isEmpty(params.max) && !isEmpty(params.min)) {
        return new DefiniteRangeConstraint({
            max: params.max,
            min: params.min,
        });
    }
    if (!isEmpty(params.max) || !isEmpty(params.min)) {
        return new RangeConstraint({
            max: params.max,
            min: params.min,
        });
    }
    return null;
}
/**
 * Finds a range from number constraint.
 * @param c The number constraint.
 * @return A list that contains a minimum value and a max value.
 */
export function findNumberRange(c) {
    const drc = findConstraint(c, DefiniteRangeConstraint);
    if (drc) {
        return [drc.values.get('min'), drc.values.get('max')];
    }
    const rc = findConstraint(c, RangeConstraint);
    if (rc) {
        return [rc.minValue, rc.maxValue];
    }
    return [undefined, undefined];
}
function createConstraint(params, 
// TODO: Make it required in the next version
initialValue) {
    const constraints = [];
    const sc = createStepConstraint(params, initialValue);
    if (sc) {
        constraints.push(sc);
    }
    const rc = createRangeConstraint(params);
    if (rc) {
        constraints.push(rc);
    }
    const lc = createListConstraint(params.options);
    if (lc) {
        constraints.push(lc);
    }
    return new CompositeConstraint(constraints);
}
/**
 * @hidden
 */
export const NumberInputPlugin = {
    id: 'input-number',
    type: 'input',
    accept: (value, params) => {
        if (typeof value !== 'number') {
            return null;
        }
        const p = ParamsParsers;
        const result = parseParams(params, {
            format: p.optional.function,
            max: p.optional.number,
            min: p.optional.number,
            options: p.optional.custom(parseListOptions),
            step: p.optional.number,
        });
        return result
            ? {
                initialValue: value,
                params: result,
            }
            : null;
    },
    binding: {
        reader: (_args) => numberFromUnknown,
        constraint: (args) => createConstraint(args.params, args.initialValue),
        writer: (_args) => writePrimitive,
    },
    controller: (args) => {
        var _a;
        const value = args.value;
        const c = args.constraint;
        const lc = c && findConstraint(c, ListConstraint);
        if (lc) {
            return new ListController(args.document, {
                props: new ValueMap({
                    options: lc.values.value('options'),
                }),
                value: value,
                viewProps: args.viewProps,
            });
        }
        const formatter = (_a = ('format' in args.params ? args.params.format : undefined)) !== null && _a !== void 0 ? _a : createNumberFormatter(getSuitableDecimalDigits(c, value.rawValue));
        const drc = c && findConstraint(c, DefiniteRangeConstraint);
        if (drc) {
            return new SliderTextController(args.document, {
                baseStep: getBaseStep(c),
                parser: parseNumber,
                sliderProps: new ValueMap({
                    maxValue: drc.values.value('max'),
                    minValue: drc.values.value('min'),
                }),
                textProps: ValueMap.fromObject({
                    draggingScale: getSuitableDraggingScale(c, value.rawValue),
                    formatter: formatter,
                }),
                value: value,
                viewProps: args.viewProps,
            });
        }
        return new NumberTextController(args.document, {
            baseStep: getBaseStep(c),
            parser: parseNumber,
            props: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(c, value.rawValue),
                formatter: formatter,
            }),
            value: value,
            viewProps: args.viewProps,
        });
    },
};
