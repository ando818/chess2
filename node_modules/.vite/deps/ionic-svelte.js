import "./chunk-A5ZVI5HM.js";
import "./chunk-DI2GE425.js";
import {
  __awaiter,
  __generator,
  componentOnReady,
  createAnimation,
  getMode
} from "./chunk-2SDKNJ2L.js";
import {
  mdTransitionAnimation
} from "./chunk-2BQJ2HY4.js";
import {
  iosTransitionAnimation
} from "./chunk-GTFATV5P.js";
import {
  Icon,
  IonAccordion,
  IonAccordionGroup,
  IonActionSheet,
  IonAlert,
  IonApp,
  IonAvatar,
  IonBackButton,
  IonBackdrop,
  IonBadge,
  IonBreadcrumb,
  IonBreadcrumbs,
  IonButton,
  IonButtons,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardSubtitle,
  IonCardTitle,
  IonCheckbox,
  IonChip,
  IonCol,
  IonContent,
  IonDatetime,
  IonFab,
  IonFabButton,
  IonFabList,
  IonFooter,
  IonGrid,
  IonHeader,
  IonImg,
  IonInfiniteScroll,
  IonInfiniteScrollContent,
  IonInput,
  IonItem,
  IonItemDivider,
  IonItemGroup,
  IonItemOption,
  IonItemOptions,
  IonItemSliding,
  IonLabel,
  IonList,
  IonListHeader,
  IonLoading,
  IonMenu,
  IonMenuButton,
  IonMenuToggle,
  IonModal,
  IonNav,
  IonNavLink,
  IonNote,
  IonPicker,
  IonPopover,
  IonProgressBar,
  IonRadio,
  IonRadioGroup,
  IonRange,
  IonRefresher,
  IonRefresherContent,
  IonReorder,
  IonReorderGroup,
  IonRippleEffect,
  IonRow,
  IonSearchbar,
  IonSegment,
  IonSegmentButton,
  IonSelect,
  IonSelectOption,
  IonSkeletonText,
  IonSlide,
  IonSlides,
  IonSpinner,
  IonSplitPane,
  IonTab,
  IonTabBar,
  IonTabButton,
  IonTabs,
  IonText,
  IonTextarea,
  IonThumbnail,
  IonTitle,
  IonToast,
  IonToggle,
  IonToolbar,
  IonVirtualScroll,
  PickerColumnCmp,
  PickerColumnInternal,
  PickerInternal,
  SelectPopover,
  getTimeGivenProgression,
  initialize
} from "./chunk-UFSINPFG.js";
import "./chunk-FD34S6MG.js";
import "./chunk-M4X77M43.js";
import "./chunk-CY4DBI7G.js";
import "./chunk-L5P4WHJX.js";
import {
  createAnimation as createAnimation2
} from "./chunk-PDZOBIMS.js";
import "./chunk-JJR2QCDA.js";
import {
  createGesture
} from "./chunk-7VWVTKIQ.js";
import "./chunk-Z43FUGMJ.js";
import {
  addEventListener,
  raf,
  removeEventListener
} from "./chunk-TX7TBNQQ.js";
import {
  readable,
  writable
} from "./chunk-ADM3CLVU.js";
import {
  fly
} from "./chunk-O642WJ7Z.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  attr_dev,
  binding_callbacks,
  bubble,
  children,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  set_custom_element_data,
  set_data_dev,
  space,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots,
  validate_store
} from "./chunk-3PEI35UK.js";
import "./chunk-RSJERJUL.js";

// node_modules/ionic-svelte/index.ts
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/core.css";
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/normalize.css";
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/structure.css";
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/typography.css";
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/padding.css";
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/float-elements.css";
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/text-alignment.css";
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/text-transformation.css";
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/flex-utils.css";
import "/Users/andreismailyan/andre/chess/node_modules/@ionic/core/css/display.css";

// node_modules/@ionic/core/dist/esm-es5/gesture-controller-17060b7c.js
var GestureController = function() {
  function t() {
    this.gestureId = 0;
    this.requestedStart = /* @__PURE__ */ new Map();
    this.disabledGestures = /* @__PURE__ */ new Map();
    this.disabledScroll = /* @__PURE__ */ new Set();
  }
  t.prototype.createGesture = function(t2) {
    var e;
    return new GestureDelegate(this, this.newID(), t2.name, (e = t2.priority) !== null && e !== void 0 ? e : 0, !!t2.disableScroll);
  };
  t.prototype.createBlocker = function(t2) {
    if (t2 === void 0) {
      t2 = {};
    }
    return new BlockerDelegate(this, this.newID(), t2.disable, !!t2.disableScroll);
  };
  t.prototype.start = function(t2, e, r) {
    if (!this.canStart(t2)) {
      this.requestedStart.delete(e);
      return false;
    }
    this.requestedStart.set(e, r);
    return true;
  };
  t.prototype.capture = function(t2, e, r) {
    if (!this.start(t2, e, r)) {
      return false;
    }
    var i = this.requestedStart;
    var s = -1e4;
    i.forEach(function(t3) {
      s = Math.max(s, t3);
    });
    if (s === r) {
      this.capturedId = e;
      i.clear();
      var l = new CustomEvent("ionGestureCaptured", { detail: { gestureName: t2 } });
      document.dispatchEvent(l);
      return true;
    }
    i.delete(e);
    return false;
  };
  t.prototype.release = function(t2) {
    this.requestedStart.delete(t2);
    if (this.capturedId === t2) {
      this.capturedId = void 0;
    }
  };
  t.prototype.disableGesture = function(t2, e) {
    var r = this.disabledGestures.get(t2);
    if (r === void 0) {
      r = /* @__PURE__ */ new Set();
      this.disabledGestures.set(t2, r);
    }
    r.add(e);
  };
  t.prototype.enableGesture = function(t2, e) {
    var r = this.disabledGestures.get(t2);
    if (r !== void 0) {
      r.delete(e);
    }
  };
  t.prototype.disableScroll = function(t2) {
    this.disabledScroll.add(t2);
    if (this.disabledScroll.size === 1) {
      document.body.classList.add(BACKDROP_NO_SCROLL);
    }
  };
  t.prototype.enableScroll = function(t2) {
    this.disabledScroll.delete(t2);
    if (this.disabledScroll.size === 0) {
      document.body.classList.remove(BACKDROP_NO_SCROLL);
    }
  };
  t.prototype.canStart = function(t2) {
    if (this.capturedId !== void 0) {
      return false;
    }
    if (this.isDisabled(t2)) {
      return false;
    }
    return true;
  };
  t.prototype.isCaptured = function() {
    return this.capturedId !== void 0;
  };
  t.prototype.isScrollDisabled = function() {
    return this.disabledScroll.size > 0;
  };
  t.prototype.isDisabled = function(t2) {
    var e = this.disabledGestures.get(t2);
    if (e && e.size > 0) {
      return true;
    }
    return false;
  };
  t.prototype.newID = function() {
    this.gestureId++;
    return this.gestureId;
  };
  return t;
}();
var GestureDelegate = function() {
  function t(t2, e, r, i, s) {
    this.id = e;
    this.name = r;
    this.disableScroll = s;
    this.priority = i * 1e6 + e;
    this.ctrl = t2;
  }
  t.prototype.canStart = function() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.canStart(this.name);
  };
  t.prototype.start = function() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.start(this.name, this.id, this.priority);
  };
  t.prototype.capture = function() {
    if (!this.ctrl) {
      return false;
    }
    var t2 = this.ctrl.capture(this.name, this.id, this.priority);
    if (t2 && this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
    return t2;
  };
  t.prototype.release = function() {
    if (this.ctrl) {
      this.ctrl.release(this.id);
      if (this.disableScroll) {
        this.ctrl.enableScroll(this.id);
      }
    }
  };
  t.prototype.destroy = function() {
    this.release();
    this.ctrl = void 0;
  };
  return t;
}();
var BlockerDelegate = function() {
  function t(t2, e, r, i) {
    this.id = e;
    this.disable = r;
    this.disableScroll = i;
    this.ctrl = t2;
  }
  t.prototype.block = function() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (var t2 = 0, e = this.disable; t2 < e.length; t2++) {
        var r = e[t2];
        this.ctrl.disableGesture(r, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
  };
  t.prototype.unblock = function() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (var t2 = 0, e = this.disable; t2 < e.length; t2++) {
        var r = e[t2];
        this.ctrl.enableGesture(r, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.enableScroll(this.id);
    }
  };
  t.prototype.destroy = function() {
    this.unblock();
    this.ctrl = void 0;
  };
  return t;
}();
var BACKDROP_NO_SCROLL = "backdrop-no-scroll";
var GESTURE_CONTROLLER = new GestureController();

// node_modules/@ionic/core/dist/esm-es5/ionic-global-c74e4951.js
var Config = function() {
  function t() {
    this.m = /* @__PURE__ */ new Map();
  }
  t.prototype.reset = function(t2) {
    this.m = new Map(Object.entries(t2));
  };
  t.prototype.get = function(t2, e) {
    var n = this.m.get(t2);
    return n !== void 0 ? n : e;
  };
  t.prototype.getBoolean = function(t2, e) {
    if (e === void 0) {
      e = false;
    }
    var n = this.m.get(t2);
    if (n === void 0) {
      return e;
    }
    if (typeof n === "string") {
      return n === "true";
    }
    return !!n;
  };
  t.prototype.getNumber = function(t2, e) {
    var n = parseFloat(this.m.get(t2));
    return isNaN(n) ? e !== void 0 ? e : NaN : n;
  };
  t.prototype.set = function(t2, e) {
    this.m.set(t2, e);
  };
  return t;
}();
var config = new Config();
var defaultMode;
var getIonMode = function(t) {
  return t && getMode(t) || defaultMode;
};

// node_modules/@ionic/core/dist/esm-es5/index-6661fe90.js
var IonicSafeString = function() {
  function e(e2) {
    this.value = e2;
  }
  return e;
}();

// node_modules/@ionic/core/dist/esm-es5/hardware-back-button-490df115.js
var MENU_BACK_BUTTON_PRIORITY = 99;

// node_modules/@ionic/core/dist/esm-es5/index-2b839939.js
var baseAnimation = function(n) {
  return createAnimation().duration(n ? 400 : 300);
};
var menuOverlayAnimation = function(n) {
  var e;
  var r;
  var t = n.width + 8;
  var i = createAnimation();
  var a = createAnimation();
  if (n.isEndSide) {
    e = t + "px";
    r = "0px";
  } else {
    e = -t + "px";
    r = "0px";
  }
  i.addElement(n.menuInnerEl).fromTo("transform", "translateX(".concat(e, ")"), "translateX(".concat(r, ")"));
  var o = getIonMode(n);
  var u = o === "ios";
  var s = u ? 0.2 : 0.25;
  a.addElement(n.backdropEl).fromTo("opacity", 0.01, s);
  return baseAnimation(u).addAnimation([i, a]);
};
var menuPushAnimation = function(n) {
  var e;
  var r;
  var t = getIonMode(n);
  var i = n.width;
  if (n.isEndSide) {
    e = -i + "px";
    r = i + "px";
  } else {
    e = i + "px";
    r = -i + "px";
  }
  var a = createAnimation().addElement(n.menuInnerEl).fromTo("transform", "translateX(".concat(r, ")"), "translateX(0px)");
  var o = createAnimation().addElement(n.contentEl).fromTo("transform", "translateX(0px)", "translateX(".concat(e, ")"));
  var u = createAnimation().addElement(n.backdropEl).fromTo("opacity", 0.01, 0.32);
  return baseAnimation(t === "ios").addAnimation([a, o, u]);
};
var menuRevealAnimation = function(n) {
  var e = getIonMode(n);
  var r = n.width * (n.isEndSide ? -1 : 1) + "px";
  var t = createAnimation().addElement(n.contentEl).fromTo("transform", "translateX(0px)", "translateX(".concat(r, ")"));
  return baseAnimation(e === "ios").addAnimation(t);
};
var createMenuController = function() {
  var n = /* @__PURE__ */ new Map();
  var e = [];
  var r = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, c(n2)];
          case 1:
            e2 = r2.sent();
            if (e2) {
              return [2, e2.open()];
            }
            return [2, false];
        }
      });
    });
  };
  var t = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, n2 !== void 0 ? c(n2) : f()];
          case 1:
            e2 = r2.sent();
            if (e2 !== void 0) {
              return [2, e2.close()];
            }
            return [2, false];
        }
      });
    });
  };
  var i = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, c(n2)];
          case 1:
            e2 = r2.sent();
            if (e2) {
              return [2, e2.toggle()];
            }
            return [2, false];
        }
      });
    });
  };
  var a = function(n2, e2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var r2;
      return __generator(this, function(t2) {
        switch (t2.label) {
          case 0:
            return [4, c(e2)];
          case 1:
            r2 = t2.sent();
            if (r2) {
              r2.disabled = !n2;
            }
            return [2, r2];
        }
      });
    });
  };
  var o = function(n2, e2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var r2;
      return __generator(this, function(t2) {
        switch (t2.label) {
          case 0:
            return [4, c(e2)];
          case 1:
            r2 = t2.sent();
            if (r2) {
              r2.swipeGesture = n2;
            }
            return [2, r2];
        }
      });
    });
  };
  var u = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2, e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!(n2 != null))
              return [3, 2];
            return [4, c(n2)];
          case 1:
            e2 = r2.sent();
            return [2, e2 !== void 0 && e2.isOpen()];
          case 2:
            return [4, f()];
          case 3:
            e2 = r2.sent();
            return [2, e2 !== void 0];
        }
      });
    });
  };
  var s = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, c(n2)];
          case 1:
            e2 = r2.sent();
            if (e2) {
              return [2, !e2.disabled];
            }
            return [2, false];
        }
      });
    });
  };
  var c = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var r2, t2;
      return __generator(this, function(i2) {
        switch (i2.label) {
          case 0:
            return [4, O()];
          case 1:
            i2.sent();
            if (n2 === "start" || n2 === "end") {
              r2 = E(function(e2) {
                return e2.side === n2 && !e2.disabled;
              });
              if (r2) {
                return [2, r2];
              }
              return [2, E(function(e2) {
                return e2.side === n2;
              })];
            } else if (n2 != null) {
              return [2, E(function(e2) {
                return e2.menuId === n2;
              })];
            }
            t2 = E(function(n3) {
              return !n3.disabled;
            });
            if (t2) {
              return [2, t2];
            }
            return [2, e.length > 0 ? e[0].el : void 0];
        }
      });
    });
  };
  var f = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, O()];
          case 1:
            n2.sent();
            return [2, w()];
        }
      });
    });
  };
  var d = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, O()];
          case 1:
            n2.sent();
            return [2, b()];
        }
      });
    });
  };
  var v = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, O()];
          case 1:
            n2.sent();
            return [2, A()];
        }
      });
    });
  };
  var l = function(e2, r2) {
    n.set(e2, r2);
  };
  var m = function(n2) {
    if (e.indexOf(n2) < 0) {
      if (!n2.disabled) {
        p(n2);
      }
      e.push(n2);
    }
  };
  var _ = function(n2) {
    var r2 = e.indexOf(n2);
    if (r2 > -1) {
      e.splice(r2, 1);
    }
  };
  var p = function(n2) {
    var r2 = n2.side;
    e.filter(function(e2) {
      return e2.side === r2 && e2 !== n2;
    }).forEach(function(n3) {
      return n3.disabled = true;
    });
  };
  var h = function(n2, e2, r2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var t2;
      return __generator(this, function(i2) {
        switch (i2.label) {
          case 0:
            if (A()) {
              return [2, false];
            }
            if (!e2)
              return [3, 3];
            return [4, f()];
          case 1:
            t2 = i2.sent();
            if (!(t2 && n2.el !== t2))
              return [3, 3];
            return [4, t2.setOpen(false, false)];
          case 2:
            i2.sent();
            i2.label = 3;
          case 3:
            return [2, n2._setOpen(e2, r2)];
        }
      });
    });
  };
  var g = function(e2, r2) {
    var t2 = n.get(e2);
    if (!t2) {
      throw new Error("animation not registered");
    }
    var i2 = t2(r2);
    return i2;
  };
  var w = function() {
    return E(function(n2) {
      return n2._isOpen;
    });
  };
  var b = function() {
    return e.map(function(n2) {
      return n2.el;
    });
  };
  var A = function() {
    return e.some(function(n2) {
      return n2.isAnimating;
    });
  };
  var E = function(n2) {
    var r2 = e.find(n2);
    if (r2 !== void 0) {
      return r2.el;
    }
    return void 0;
  };
  var O = function() {
    return Promise.all(Array.from(document.querySelectorAll("ion-menu")).map(function(n2) {
      return new Promise(function(e2) {
        return componentOnReady(n2, e2);
      });
    }));
  };
  l("reveal", menuRevealAnimation);
  l("push", menuPushAnimation);
  l("overlay", menuOverlayAnimation);
  if (typeof document !== "undefined") {
    document.addEventListener("ionBackButton", function(n2) {
      var e2 = w();
      if (e2) {
        n2.detail.register(MENU_BACK_BUTTON_PRIORITY, function() {
          return e2.close();
        });
      }
    });
  }
  return { registerAnimation: l, get: c, getMenus: d, getOpen: f, isEnabled: s, swipeGesture: o, isAnimating: v, isOpen: u, enable: a, toggle: i, close: t, open: r, _getOpenSync: w, _createAnimation: g, _register: m, _unregister: _, _setOpen: h, _setActiveMenu: p };
};
var menuController = createMenuController();

// node_modules/@ionic/core/dist/esm-es5/overlays-58fa8e4d.js
var createController = function(e) {
  return { create: function(t) {
    return createOverlay(e, t);
  }, dismiss: function(t, n, r) {
    return dismissOverlay(document, t, n, e, r);
  }, getTop: function() {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(t) {
        return [2, getOverlay(document, e)];
      });
    });
  } };
};
var alertController = createController("ion-alert");
var actionSheetController = createController("ion-action-sheet");
var loadingController = createController("ion-loading");
var modalController = createController("ion-modal");
var pickerController = createController("ion-picker");
var popoverController = createController("ion-popover");
var toastController = createController("ion-toast");
var createOverlay = function(e, t) {
  if (typeof window !== "undefined" && typeof window.customElements !== "undefined") {
    return window.customElements.whenDefined(e).then(function() {
      var n = document.createElement(e);
      n.classList.add("overlay-hidden");
      Object.assign(n, Object.assign(Object.assign({}, t), { hasController: true }));
      getAppRoot(document).appendChild(n);
      return new Promise(function(e2) {
        return componentOnReady(n, e2);
      });
    });
  }
  return Promise.resolve();
};
var isOverlayHidden = function(e) {
  return e.classList.contains("overlay-hidden");
};
var dismissOverlay = function(e, t, n, r, o) {
  var i = getOverlay(e, r, o);
  if (!i) {
    return Promise.reject("overlay does not exist");
  }
  return i.dismiss(t, n);
};
var getOverlays = function(e, t) {
  if (t === void 0) {
    t = "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast";
  }
  return Array.from(e.querySelectorAll(t)).filter(function(e2) {
    return e2.overlayIndex > 0;
  });
};
var getOverlay = function(e, t, n) {
  var r = getOverlays(e, t).filter(function(e2) {
    return !isOverlayHidden(e2);
  });
  return n === void 0 ? r[r.length - 1] : r.find(function(e2) {
    return e2.id === n;
  });
};
var getAppRoot = function(e) {
  return e.querySelector("ion-app") || e.body;
};

// node_modules/@ionic/core/components/ion-icon.js
var IonIcon = Icon;

// node_modules/@ionic/core/components/ion-picker-column.js
var IonPickerColumn = PickerColumnCmp;

// node_modules/@ionic/core/components/ion-picker-column-internal.js
var IonPickerColumnInternal = PickerColumnInternal;

// node_modules/@ionic/core/components/ion-picker-internal.js
var IonPickerInternal = PickerInternal;

// node_modules/@ionic/core/components/ion-select-popover.js
var IonSelectPopover = SelectPopover;

// node_modules/@ionic/core/components/index.js
var setupSwiperInIonic = (swiper, watchForIonPageChanges = true) => {
  if (typeof window === "undefined") {
    return;
  }
  const swiperEl = swiper.el;
  const ionPage = swiperEl.closest(".ion-page");
  if (!ionPage) {
    if (watchForIonPageChanges) {
      const rootNode = swiperEl.getRootNode();
      if (rootNode.tagName === "DIV") {
        const mo = new MutationObserver((m) => {
          const mutation = m[0];
          const wasEmpty = mutation.oldValue === null;
          const hasIonPage = rootNode.classList.contains("ion-page");
          if (wasEmpty && hasIonPage) {
            mo.disconnect();
            setupSwiperInIonic(swiper, false);
          }
        });
        mo.observe(rootNode, {
          attributeFilter: ["class"],
          attributeOldValue: true
        });
      }
    }
    return;
  }
  const modalOrPopover = swiperEl.closest("ion-modal, ion-popover");
  if (modalOrPopover) {
    const eventName = modalOrPopover.tagName === "ION-MODAL" ? "ionModalWillPresent" : "ionPopoverWillPresent";
    const overlayCallback = () => {
      raf(() => {
        swiperEl.swiper.update();
        removeEventListener(modalOrPopover, eventName, overlayCallback);
      });
    };
    addEventListener(modalOrPopover, eventName, overlayCallback);
  } else {
    const mo = new MutationObserver((m) => {
      var _a;
      const mutation = m[0];
      const wasPageHidden = (_a = mutation.oldValue) === null || _a === void 0 ? void 0 : _a.includes("ion-page-invisible");
      const isPageHidden = ionPage.classList.contains("ion-page-invisible");
      if (!isPageHidden && isPageHidden !== wasPageHidden) {
        swiperEl.swiper.update();
      }
    });
    mo.observe(ionPage, {
      attributeFilter: ["class"],
      attributeOldValue: true
    });
  }
  const onAppLoad = () => {
    swiperEl.swiper.update();
    removeEventListener(window, "appload", onAppLoad);
  };
  addEventListener(window, "appload", onAppLoad);
};
var IonicSwiper = {
  name: "ionic",
  on: {
    afterInit(swiper) {
      console.warn("[Deprecation Warning]: The IonicSwiper module has been deprecated in favor of the IonSlides module. This change was made to better support the Swiper 7 release. The IonicSwiper module will be removed in Ionic 7.0. See https://ionicframework.com/docs/api/slides#migration for revised migration steps.");
      setupSwiperInIonic(swiper);
    }
  }
};
var IonicSlides = (opts) => {
  const { swiper, extendParams } = opts;
  const slidesParams = {
    effect: void 0,
    direction: "horizontal",
    initialSlide: 0,
    loop: false,
    parallax: false,
    slidesPerView: 1,
    spaceBetween: 0,
    speed: 300,
    slidesPerColumn: 1,
    slidesPerColumnFill: "column",
    slidesPerGroup: 1,
    centeredSlides: false,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    touchEventsTarget: "container",
    autoplay: false,
    freeMode: false,
    freeModeMomentum: true,
    freeModeMomentumRatio: 1,
    freeModeMomentumBounce: true,
    freeModeMomentumBounceRatio: 1,
    freeModeMomentumVelocityRatio: 1,
    freeModeSticky: false,
    freeModeMinimumVelocity: 0.02,
    autoHeight: false,
    setWrapperSize: false,
    zoom: {
      maxRatio: 3,
      minRatio: 1,
      toggle: false
    },
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    touchStartPreventDefault: false,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    threshold: 0,
    touchMoveStopPropagation: true,
    touchReleaseOnEdges: false,
    iOSEdgeSwipeDetection: false,
    iOSEdgeSwipeThreshold: 20,
    resistance: true,
    resistanceRatio: 0.85,
    watchSlidesProgress: false,
    watchSlidesVisibility: false,
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    loopAdditionalSlides: 0,
    noSwiping: true,
    runCallbacksOnInit: true,
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      modifier: 1,
      slideShadows: true
    },
    flipEffect: {
      slideShadows: true,
      limitRotation: true
    },
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    },
    fadeEffect: {
      crossFade: false
    },
    a11y: {
      prevSlideMessage: "Previous slide",
      nextSlideMessage: "Next slide",
      firstSlideMessage: "This is the first slide",
      lastSlideMessage: "This is the last slide"
    }
  };
  if (swiper.pagination) {
    slidesParams.pagination = {
      type: "bullets",
      clickable: false,
      hideOnClick: false
    };
  }
  if (swiper.scrollbar) {
    slidesParams.scrollbar = {
      hide: true
    };
  }
  extendParams(slidesParams);
};

// node_modules/ionic-svelte/components/defineComponents.ts
var defineComponent = (tagName, customElement) => {
  if (typeof customElements === "undefined")
    return;
  if (!customElements.get(tagName)) {
    customElements.define(tagName, customElement);
  }
};
var defineIonComponents = () => {
  defineComponent("ion-accordion", IonAccordion);
  defineComponent("ion-accordion-group", IonAccordionGroup);
  defineComponent("ion-app", IonApp);
  defineComponent("ion-avatar", IonAvatar);
  defineComponent("ion-backdrop", IonBackdrop);
  defineComponent("ion-back-button", IonBackButton);
  defineComponent("ion-badge", IonBadge);
  defineComponent("ion-breadcrumb", IonBreadcrumb);
  defineComponent("ion-breadcrumbs", IonBreadcrumbs);
  defineComponent("ion-button", IonButton);
  defineComponent("ion-buttons", IonButtons);
  defineComponent("ion-card", IonCard);
  defineComponent("ion-card-content", IonCardContent);
  defineComponent("ion-card-header", IonCardHeader);
  defineComponent("ion-card-subtitle", IonCardSubtitle);
  defineComponent("ion-card-title", IonCardTitle);
  defineComponent("ion-checkbox", IonCheckbox);
  defineComponent("ion-chip", IonChip);
  defineComponent("ion-col", IonCol);
  defineComponent("ion-content", IonContent);
  defineComponent("ion-datetime", IonDatetime);
  defineComponent("ion-fab", IonFab);
  defineComponent("ion-fab-button", IonFabButton);
  defineComponent("ion-fab-list", IonFabList);
  defineComponent("ion-footer", IonFooter);
  defineComponent("ion-grid", IonGrid);
  defineComponent("ion-header", IonHeader);
  defineComponent("ion-icon", IonIcon);
  defineComponent("ion-img", IonImg);
  defineComponent("ion-infinite-scroll", IonInfiniteScroll);
  defineComponent("ion-infinite-scroll-content", IonInfiniteScrollContent);
  defineComponent("ion-input", IonInput);
  defineComponent("ion-item", IonItem);
  defineComponent("ion-item-divider", IonItemDivider);
  defineComponent("ion-item-group", IonItemGroup);
  defineComponent("ion-item-option", IonItemOption);
  defineComponent("ion-item-options", IonItemOptions);
  defineComponent("ion-item-sliding", IonItemSliding);
  defineComponent("ion-label", IonLabel);
  defineComponent("ion-list", IonList);
  defineComponent("ion-list-header", IonListHeader);
  defineComponent("ion-menu", IonMenu);
  defineComponent("ion-menu-button", IonMenuButton);
  defineComponent("ion-menu-toggle", IonMenuToggle);
  defineComponent("ion-nav", IonNav);
  defineComponent("ion-nav-link", IonNavLink);
  defineComponent("ion-note", IonNote);
  defineComponent("ion-progress-bar", IonProgressBar);
  defineComponent("ion-popover", IonPopover);
  defineComponent("ion-radio", IonRadio);
  defineComponent("ion-radio-group", IonRadioGroup);
  defineComponent("ion-range", IonRange);
  defineComponent("ion-refresher", IonRefresher);
  defineComponent("ion-refresher-content", IonRefresherContent);
  defineComponent("ion-reorder", IonReorder);
  defineComponent("ion-reorder-group", IonReorderGroup);
  defineComponent("ion-ripple-effect", IonRippleEffect);
  defineComponent("ion-row", IonRow);
  defineComponent("ion-searchbar", IonSearchbar);
  defineComponent("ion-segment", IonSegment);
  defineComponent("ion-segment-button", IonSegmentButton);
  defineComponent("ion-select", IonSelect);
  defineComponent("ion-select-option", IonSelectOption);
  defineComponent("ion-select-popover", IonSelectPopover);
  defineComponent("ion-skeleton-text", IonSkeletonText);
  defineComponent("ion-slide", IonSlide);
  defineComponent("ion-slides", IonSlides);
  defineComponent("ion-spinner", IonSpinner);
  defineComponent("ion-split-pane", IonSplitPane);
  defineComponent("ion-tab", IonTab);
  defineComponent("ion-tabs", IonTabs);
  defineComponent("ion-tab-bar", IonTabBar);
  defineComponent("ion-tab-button", IonTabButton);
  defineComponent("ion-text", IonText);
  defineComponent("ion-textarea", IonTextarea);
  defineComponent("ion-thumbnail", IonThumbnail);
  defineComponent("ion-title", IonTitle);
  defineComponent("ion-toggle", IonToggle);
  defineComponent("ion-toolbar", IonToolbar);
  defineComponent("ion-virtual-scroll", IonVirtualScroll);
  defineComponent("ion-action-sheet", IonActionSheet);
  defineComponent("ion-alert", IonAlert);
  defineComponent("ion-loading", IonLoading);
  defineComponent("ion-modal", IonModal);
  defineComponent("ion-picker", IonPicker);
  defineComponent("ion-picker-column", IonPickerColumn);
  defineComponent("ion-picker-column-internal", IonPickerColumnInternal);
  defineComponent("ion-picker-internal", IonPickerInternal);
  defineComponent("ion-toast", IonToast);
};

// node_modules/ionic-svelte/utils/controllers.ts
var modalController3 = {
  create: (modalOptions) => {
    return Promise.resolve(
      modalController3.__create(modalOptions.component, modalOptions)
    );
  },
  __create: (component, modalOptions) => {
    const divWrapper = document.createElement("div");
    const contentID = "id" + Date.now();
    divWrapper.id = contentID;
    const modalWrapper = document.createElement(
      "ion-modal"
    );
    if (modalOptions.cssClass) {
      if (Array.isArray(modalOptions.cssClass)) {
        modalOptions.cssClass.forEach((cssClass) => {
          modalWrapper.classList.add(cssClass);
        });
      } else
        modalWrapper.classList.add(modalOptions.cssClass);
    }
    let modalContent = document.createElement("div");
    Object.keys(modalOptions).filter((key) => !["component", "componentProps"].includes(key)).forEach((key) => {
      modalWrapper[key] = modalOptions[key];
    });
    divWrapper.appendChild(modalWrapper);
    modalWrapper.appendChild(modalContent);
    document.body.appendChild(divWrapper);
    const svelteComponent = new component({
      target: modalContent,
      props: modalOptions.componentProps
    });
    modalWrapper.onDidDismiss().then(() => {
      svelteComponent.$destroy();
      divWrapper.remove();
    });
    return modalWrapper;
  },
  dismiss: (data, role, id) => {
    return modalController.dismiss(data, role);
  },
  getTop: () => {
    return modalController.getTop();
  }
};
var popoverController3 = {
  create: (popoverOptions) => {
    return Promise.resolve(
      popoverController3.__create(popoverOptions.component, popoverOptions)
    );
  },
  __create: (component, popoverOptions) => {
    const divWrapper = document.createElement("div");
    const contentID = "id" + Date.now();
    divWrapper.id = contentID;
    const popoverWrapper = document.createElement(
      "ion-popover"
    );
    if (popoverOptions.cssClass) {
      if (Array.isArray(popoverOptions.cssClass)) {
        popoverOptions.cssClass.forEach((cssClass) => {
          popoverWrapper.classList.add(cssClass);
        });
      } else
        popoverWrapper.classList.add(popoverOptions.cssClass);
    }
    let popoverContent = document.createElement("div");
    Object.keys(popoverOptions).filter((key) => !["component", "componentProps"].includes(key)).forEach((key) => {
      popoverWrapper[key] = popoverOptions[key];
    });
    divWrapper.appendChild(popoverWrapper);
    popoverWrapper.appendChild(popoverContent);
    document.body.appendChild(divWrapper);
    const svelteComponent = new component({
      target: popoverContent,
      props: popoverOptions.componentProps
    });
    popoverWrapper.onDidDismiss().then(() => {
      svelteComponent.$destroy();
      divWrapper.remove();
    });
    return popoverWrapper;
  },
  dismiss: (data, role, id) => {
    return popoverController.dismiss(data, role);
  },
  getTop: () => {
    return popoverController.getTop();
  }
};

// node_modules/ionic-svelte/utils/navcontroller.ts
var createHTMLCompFromSvelte = (component, componentProps = {}) => {
  const divWrapper = document.createElement("div");
  const contentID = "id" + Date.now();
  divWrapper.id = contentID;
  const navContent = document.createElement("div");
  divWrapper.appendChild(navContent);
  document.body.appendChild(divWrapper);
  const props = {
    ...componentProps
    // ionNav
  };
  const svelteComponent = new component({
    target: navContent,
    props
  });
  return divWrapper;
};
var navController = {
  canGoBack: function(view) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.canGoBack(view) : void 0;
  },
  getActive: function() {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.getActive() : void 0;
  },
  getByIndex: function(index) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.getByIndex(index) : void 0;
  },
  getPrevious: function(view) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.getPrevious(view) : void 0;
  },
  insert: function(insertIndex, component, componentProps, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponent = createHTMLCompFromSvelte(component, componentProps);
    return _nav !== void 0 ? _nav.insert(insertIndex, htmlcomponent, componentProps, opts, done) : void 0;
  },
  insertPages: function(insertIndex, insertComponents, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponents = insertComponents.map((component) => {
      return typeof component["component"] === "undefined" ? component : {
        //@ts-ignore
        component: createHTMLCompFromSvelte(component["component"], component["componentProps"]),
        //@ts-ignore
        componentProps: component["componentProps"]
      };
    });
    return _nav !== void 0 ? _nav.insertPages(insertIndex, htmlcomponents, opts, done) : void 0;
  },
  pop: function(opts, done) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.pop(opts, done) : void 0;
  },
  popTo: function(indexOrViewCtrl, opts, done) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.popTo(indexOrViewCtrl, opts, done) : void 0;
  },
  popToRoot: function(opts, done) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.popToRoot(opts, done) : void 0;
  },
  push: function(component, componentProps, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponent = createHTMLCompFromSvelte(component, componentProps);
    return _nav !== void 0 ? _nav.push(htmlcomponent, componentProps, opts, done) : void 0;
  },
  removeIndex: function(startIndex, removeCount, opts, done) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.removeIndex(startIndex, removeCount, opts, done) : void 0;
  },
  setPages: function(views, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponents = views.map((component) => {
      return typeof component["component"] === "undefined" ? component : {
        //@ts-ignore
        component: createHTMLCompFromSvelte(component["component"], component["componentProps"]),
        //@ts-ignore
        componentProps: component["componentProps"]
      };
    });
    return _nav !== void 0 ? _nav.setPages(htmlcomponents, opts, done) : void 0;
  },
  setRoot: function(component, componentProps, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponent = createHTMLCompFromSvelte(component, componentProps);
    return _nav !== void 0 ? _nav.setRoot(htmlcomponent, componentProps, opts, done) : void 0;
  }
};

// node_modules/@ionic/core/dist/collection/global/config.js
var Config2 = class {
  constructor() {
    this.m = /* @__PURE__ */ new Map();
  }
  reset(configObj) {
    this.m = new Map(Object.entries(configObj));
  }
  get(key, fallback) {
    const value = this.m.get(key);
    return value !== void 0 ? value : fallback;
  }
  getBoolean(key, fallback = false) {
    const val = this.m.get(key);
    if (val === void 0) {
      return fallback;
    }
    if (typeof val === "string") {
      return val === "true";
    }
    return !!val;
  }
  getNumber(key, fallback) {
    const val = parseFloat(this.m.get(key));
    return isNaN(val) ? fallback !== void 0 ? fallback : NaN : val;
  }
  set(key, value) {
    this.m.set(key, value);
  }
};
var config2 = new Config2();

// node_modules/ionic-svelte/utils/platform.ts
var _win;
var _doc;
var getPlatforms3 = (win) => setupPlatforms(win);
var isPlatform3 = (winOrPlatform, platform) => {
  if (typeof winOrPlatform === "string") {
    platform = winOrPlatform;
    winOrPlatform = void 0;
  }
  return getPlatforms3(winOrPlatform).includes(platform);
};
var setupPlatforms = (win) => {
  if (typeof window !== "undefined") {
    win = window;
    _win = window;
  }
  if (typeof document !== "undefined") {
    _doc = document;
  }
  if (typeof win === "undefined") {
    return [];
  }
  win.Ionic = win.Ionic || {};
  let platforms = win.Ionic.platforms;
  if (platforms == null) {
    platforms = win.Ionic.platforms = detectPlatforms(win);
    platforms.forEach(
      (p) => win.document.documentElement.classList.add(`plt-${p}`)
    );
  }
  return platforms;
};
var detectPlatforms = (win) => {
  const customPlatformMethods = config2.get("platform");
  return Object.keys(PLATFORMS_MAP).filter((p) => {
    const customMethod = customPlatformMethods == null ? void 0 : customPlatformMethods[p];
    return typeof customMethod === "function" ? customMethod(win) : PLATFORMS_MAP[p](win);
  });
};
var isMobileWeb = (win) => isMobile(win) && !isHybrid(win);
var isIpad = (win) => {
  if (testUserAgent(win, /iPad/i)) {
    return true;
  }
  if (testUserAgent(win, /Macintosh/i) && isMobile(win)) {
    return true;
  }
  return false;
};
var isIphone = (win) => testUserAgent(win, /iPhone/i);
var isIOS = (win) => testUserAgent(win, /iPhone|iPod/i) || isIpad(win);
var isAndroid = (win) => testUserAgent(win, /android|sink/i);
var isAndroidTablet = (win) => {
  return isAndroid(win) && !testUserAgent(win, /mobile/i);
};
var isPhablet = (win) => {
  const width2 = win.innerWidth;
  const height2 = win.innerHeight;
  const smallest = Math.min(width2, height2);
  const largest = Math.max(width2, height2);
  return smallest > 390 && smallest < 520 && largest > 620 && largest < 800;
};
var isTablet = (win) => {
  const width2 = win.innerWidth;
  const height2 = win.innerHeight;
  const smallest = Math.min(width2, height2);
  const largest = Math.max(width2, height2);
  return isIpad(win) || isAndroidTablet(win) || smallest > 460 && smallest < 820 && largest > 780 && largest < 1400;
};
var isMobile = (win) => matchMedia(win, "(any-pointer:coarse)");
var isDesktop = (win) => !isMobile(win);
var isHybrid = (win) => isCordova(win) || isCapacitorNative(win);
var isCordova = (win) => !!(win["cordova"] || win["phonegap"] || win["PhoneGap"]);
var isCapacitorNative = (win) => {
  const capacitor = win["Capacitor"];
  return !!(capacitor == null ? void 0 : capacitor.isNative);
};
var isElectron = (win) => testUserAgent(win, /electron/i);
var isPWA = (win) => {
  var _a;
  return !!(((_a = win.matchMedia) == null ? void 0 : _a.call(win, "(display-mode: standalone)").matches) || win.navigator.standalone);
};
var testUserAgent = (win, expr) => expr.test(win.navigator.userAgent);
var matchMedia = (win, query) => {
  var _a;
  return (_a = win.matchMedia) == null ? void 0 : _a.call(win, query).matches;
};
var PLATFORMS_MAP = {
  ipad: isIpad,
  iphone: isIphone,
  ios: isIOS,
  android: isAndroid,
  phablet: isPhablet,
  tablet: isTablet,
  cordova: isCordova,
  capacitor: isCapacitorNative,
  electron: isElectron,
  pwa: isPWA,
  mobile: isMobile,
  mobileweb: isMobileWeb,
  desktop: isDesktop,
  hybrid: isHybrid
};
var networkStatus = readable(
  typeof window !== "undefined" ? (window.navigator.onLine ? "on" : "off") + "line" : "",
  (set) => {
    const eventFunction = () => {
      if (typeof window !== "undefined")
        set((window.navigator.onLine ? "on" : "off") + "line");
    };
    if (typeof window !== "undefined") {
      window.addEventListener("offline", eventFunction);
      window.addEventListener("online", eventFunction);
    }
    return () => {
      if (typeof window !== "undefined") {
        window.removeEventListener("offline", eventFunction);
        window.removeEventListener("online", eventFunction);
      }
    };
  }
);
var readableEventFactory = (args) => {
  const { defaultvalue, event, eventAttr, listenerComponent } = args;
  return readable(defaultvalue, (set) => {
    const eventFunction = (event2) => {
      if (eventAttr)
        set(event2[eventAttr]);
      else
        set(event2);
    };
    listenerComponent.addEventListener(event, eventFunction);
    return () => {
      listenerComponent.removeEventListener(event, eventFunction);
    };
  });
};
var resize = readable("", (set) => {
  return () => {
  };
});
var keyboardDidShow = readable("", (set) => {
  return () => {
  };
});
var keyboardDidHide = readable("", (set) => {
  return () => {
  };
});
if (typeof window !== "undefined") {
  resize = readableEventFactory({
    defaultvalue: "",
    event: "resize",
    eventAttr: "timeStamp",
    listenerComponent: window
  });
  keyboardDidShow = readableEventFactory({
    defaultvalue: "",
    event: "ionKeyboardDidShow",
    eventAttr: void 0,
    listenerComponent: window
  });
  keyboardDidHide = readableEventFactory({
    defaultvalue: "",
    event: "ionKeyboardDidHide",
    eventAttr: void 0,
    listenerComponent: window
  });
}
var resume = readable("", (set) => {
  return () => {
  };
});
var pause = readable("", (set) => {
  return () => {
  };
});
var backButton = readable("", (set) => {
  return () => {
  };
});
var keydown = readable("", (set) => {
  return () => {
  };
});
if (typeof document !== "undefined") {
  resume = readableEventFactory({
    defaultvalue: "",
    event: "resume",
    eventAttr: void 0,
    listenerComponent: document
  });
  pause = readableEventFactory({
    defaultvalue: "",
    event: "pause",
    eventAttr: void 0,
    listenerComponent: document
  });
  backButton = readableEventFactory({
    defaultvalue: "",
    event: "ionBackButton",
    eventAttr: void 0,
    listenerComponent: document
  });
  keydown = readableEventFactory({
    defaultvalue: "",
    event: "keydown",
    eventAttr: "key",
    listenerComponent: document
  });
}
var backButtonSubscribeWithPriority = (handler, priority = 10) => {
  if (typeof document !== "undefined")
    document.addEventListener("ionBackButton", (ev) => {
      ev.detail.register(priority, () => {
        handler();
        console.log("Handler was called!");
      });
    });
};
var height = () => {
  if (_win)
    return _win.innerHeight;
  return 0;
};
var width = () => {
  if (_win)
    return _win.innerWidth;
  return 0;
};
var url = () => {
  if (_win)
    return _win.location.href;
  return "";
};
var isPortrait = () => {
  var _a;
  if (_win)
    return (_a = _win.matchMedia) == null ? void 0 : _a.call(_win, "(orientation: portrait)").matches;
  return false;
};
var isLandscape = () => {
  return !isPortrait();
};
var getQueryParam = (key) => {
  if (_win)
    return readQueryParam(_win.location.href, key);
  return null;
};
var isRTL = () => {
  if (_doc)
    return _doc.dir === "rtl";
};
var is = (platformName) => {
  if (_win)
    return isPlatform3(_win, platformName);
  return false;
};
var readQueryParam = (url2, key) => {
  key = key.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
  const regex = new RegExp("[\\?&]" + key + "=([^&#]*)");
  const results = regex.exec(url2);
  return results ? decodeURIComponent(results[1].replace(/\+/g, " ")) : null;
};
var prefersDark = writable(
  typeof window !== "undefined" ? window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches : ""
);
if (typeof window !== "undefined")
  window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (e) => {
    prefersDark.set(e.matches ? true : false);
  });
var toggleDarkTheme = (shouldAdd) => {
  if (_doc)
    document.body.classList.toggle("dark", shouldAdd);
};

// node_modules/ionic-svelte/components/IonTabs.svelte
import { page } from "$app/stores";
import { goto } from "$app/navigation";
var file = "node_modules/ionic-svelte/components/IonTabs.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function create_if_block_1(ctx) {
  let ion_tab_bar;
  let each_value_1 = (
    /*tabs*/
    ctx[3]
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      ion_tab_bar = element("ion-tab-bar");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ion_tab_bar = claim_element(nodes, "ION-TAB-BAR", { slot: true });
      var ion_tab_bar_nodes = children(ion_tab_bar);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ion_tab_bar_nodes);
      }
      ion_tab_bar_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_custom_element_data(ion_tab_bar, "slot", "bottom");
      add_location(ion_tab_bar, file, 41, 4, 1170);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ion_tab_bar, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ion_tab_bar, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tabs, tabBarClick*/
      40) {
        each_value_1 = /*tabs*/
        ctx2[3];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ion_tab_bar, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ion_tab_bar);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: '(41:2) {#if slot === \\"bottom\\" || slot === \\"\\"}',
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let ion_tab_button;
  let ion_label;
  let t0_value = (
    /*tab*/
    ctx[18].label + ""
  );
  let t0;
  let t1;
  let ion_icon;
  let ion_icon_icon_value;
  let t2;
  let ion_tab_button_tab_value;
  let mounted;
  let dispose;
  function keydown_handler() {
    return (
      /*keydown_handler*/
      ctx[8](
        /*tab*/
        ctx[18]
      )
    );
  }
  function click_handler() {
    return (
      /*click_handler*/
      ctx[9](
        /*tab*/
        ctx[18]
      )
    );
  }
  const block = {
    c: function create() {
      ion_tab_button = element("ion-tab-button");
      ion_label = element("ion-label");
      t0 = text(t0_value);
      t1 = space();
      ion_icon = element("ion-icon");
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      ion_tab_button = claim_element(nodes, "ION-TAB-BUTTON", { tab: true });
      var ion_tab_button_nodes = children(ion_tab_button);
      ion_label = claim_element(ion_tab_button_nodes, "ION-LABEL", {});
      var ion_label_nodes = children(ion_label);
      t0 = claim_text(ion_label_nodes, t0_value);
      ion_label_nodes.forEach(detach_dev);
      t1 = claim_space(ion_tab_button_nodes);
      ion_icon = claim_element(ion_tab_button_nodes, "ION-ICON", { icon: true });
      children(ion_icon).forEach(detach_dev);
      t2 = claim_space(ion_tab_button_nodes);
      ion_tab_button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ion_label, file, 52, 10, 1455);
      set_custom_element_data(ion_icon, "icon", ion_icon_icon_value = /*tab*/
      ctx[18].icon);
      add_location(ion_icon, file, 53, 10, 1501);
      set_custom_element_data(ion_tab_button, "tab", ion_tab_button_tab_value = /*tab*/
      ctx[18].tab);
      add_location(ion_tab_button, file, 43, 8, 1234);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ion_tab_button, anchor);
      append_hydration_dev(ion_tab_button, ion_label);
      append_hydration_dev(ion_label, t0);
      append_hydration_dev(ion_tab_button, t1);
      append_hydration_dev(ion_tab_button, ion_icon);
      append_hydration_dev(ion_tab_button, t2);
      if (!mounted) {
        dispose = [
          listen_dev(ion_tab_button, "keydown", keydown_handler, false, false, false, false),
          listen_dev(ion_tab_button, "click", click_handler, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tabs*/
      8 && t0_value !== (t0_value = /*tab*/
      ctx[18].label + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*tabs*/
      8 && ion_icon_icon_value !== (ion_icon_icon_value = /*tab*/
      ctx[18].icon)) {
        set_custom_element_data(ion_icon, "icon", ion_icon_icon_value);
      }
      if (dirty & /*tabs*/
      8 && ion_tab_button_tab_value !== (ion_tab_button_tab_value = /*tab*/
      ctx[18].tab)) {
        set_custom_element_data(ion_tab_button, "tab", ion_tab_button_tab_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ion_tab_button);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(43:6) {#each tabs as tab}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let ion_tab_bar;
  let each_value = (
    /*tabs*/
    ctx[3]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      ion_tab_bar = element("ion-tab-bar");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ion_tab_bar = claim_element(nodes, "ION-TAB-BAR", { slot: true });
      var ion_tab_bar_nodes = children(ion_tab_bar);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ion_tab_bar_nodes);
      }
      ion_tab_bar_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_custom_element_data(ion_tab_bar, "slot", "top");
      add_location(ion_tab_bar, file, 60, 4, 1632);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ion_tab_bar, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ion_tab_bar, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tabs, tabBarClick*/
      40) {
        each_value = /*tabs*/
        ctx2[3];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ion_tab_bar, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ion_tab_bar);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: '(60:2) {#if slot === \\"top\\"}',
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let ion_tab_button;
  let ion_label;
  let t0_value = (
    /*tab*/
    ctx[18].label + ""
  );
  let t0;
  let t1;
  let ion_icon;
  let ion_icon_icon_value;
  let t2;
  let ion_tab_button_tab_value;
  let mounted;
  let dispose;
  function keydown_handler_1() {
    return (
      /*keydown_handler_1*/
      ctx[10](
        /*tab*/
        ctx[18]
      )
    );
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[11](
        /*tab*/
        ctx[18]
      )
    );
  }
  const block = {
    c: function create() {
      ion_tab_button = element("ion-tab-button");
      ion_label = element("ion-label");
      t0 = text(t0_value);
      t1 = space();
      ion_icon = element("ion-icon");
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      ion_tab_button = claim_element(nodes, "ION-TAB-BUTTON", { tab: true });
      var ion_tab_button_nodes = children(ion_tab_button);
      ion_label = claim_element(ion_tab_button_nodes, "ION-LABEL", {});
      var ion_label_nodes = children(ion_label);
      t0 = claim_text(ion_label_nodes, t0_value);
      ion_label_nodes.forEach(detach_dev);
      t1 = claim_space(ion_tab_button_nodes);
      ion_icon = claim_element(ion_tab_button_nodes, "ION-ICON", { icon: true });
      children(ion_icon).forEach(detach_dev);
      t2 = claim_space(ion_tab_button_nodes);
      ion_tab_button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ion_label, file, 71, 10, 1914);
      set_custom_element_data(ion_icon, "icon", ion_icon_icon_value = /*tab*/
      ctx[18].icon);
      add_location(ion_icon, file, 72, 10, 1960);
      set_custom_element_data(ion_tab_button, "tab", ion_tab_button_tab_value = /*tab*/
      ctx[18].tab);
      add_location(ion_tab_button, file, 62, 8, 1693);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ion_tab_button, anchor);
      append_hydration_dev(ion_tab_button, ion_label);
      append_hydration_dev(ion_label, t0);
      append_hydration_dev(ion_tab_button, t1);
      append_hydration_dev(ion_tab_button, ion_icon);
      append_hydration_dev(ion_tab_button, t2);
      if (!mounted) {
        dispose = [
          listen_dev(ion_tab_button, "keydown", keydown_handler_1, false, false, false, false),
          listen_dev(ion_tab_button, "click", click_handler_1, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tabs*/
      8 && t0_value !== (t0_value = /*tab*/
      ctx[18].label + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*tabs*/
      8 && ion_icon_icon_value !== (ion_icon_icon_value = /*tab*/
      ctx[18].icon)) {
        set_custom_element_data(ion_icon, "icon", ion_icon_icon_value);
      }
      if (dirty & /*tabs*/
      8 && ion_tab_button_tab_value !== (ion_tab_button_tab_value = /*tab*/
      ctx[18].tab)) {
        set_custom_element_data(ion_tab_button, "tab", ion_tab_button_tab_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ion_tab_button);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(62:6) {#each tabs as tab}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let ion_tabs;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let if_block0 = (
    /*slot*/
    (ctx[2] === "bottom" || /*slot*/
    ctx[2] === "") && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*slot*/
    ctx[2] === "top" && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      ion_tabs = element("ion-tabs");
      if (default_slot)
        default_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      ion_tabs = claim_element(nodes, "ION-TABS", {});
      var ion_tabs_nodes = children(ion_tabs);
      if (default_slot)
        default_slot.l(ion_tabs_nodes);
      t0 = claim_space(ion_tabs_nodes);
      if (if_block0)
        if_block0.l(ion_tabs_nodes);
      t1 = claim_space(ion_tabs_nodes);
      if (if_block1)
        if_block1.l(ion_tabs_nodes);
      ion_tabs_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ion_tabs, file, 33, 0, 978);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ion_tabs, anchor);
      if (default_slot) {
        default_slot.m(ion_tabs, null);
      }
      append_hydration_dev(ion_tabs, t0);
      if (if_block0)
        if_block0.m(ion_tabs, null);
      append_hydration_dev(ion_tabs, t1);
      if (if_block1)
        if_block1.m(ion_tabs, null);
      ctx[12](ion_tabs);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            ion_tabs,
            "ionTabsDidChange",
            function() {
              if (is_function(
                /*ionTabsDidChange*/
                ctx[0]
              ))
                ctx[0].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ion_tabs,
            "ionTabsWillChange",
            function() {
              if (is_function(
                /*ionTabsWillChange*/
                ctx[1]
              ))
                ctx[1].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*slot*/
        ctx[2] === "bottom" || /*slot*/
        ctx[2] === ""
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_1(ctx);
          if_block0.c();
          if_block0.m(ion_tabs, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*slot*/
        ctx[2] === "top"
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block(ctx);
          if_block1.c();
          if_block1.m(ion_tabs, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ion_tabs);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $page;
  validate_store(page, "page");
  component_subscribe($$self, page, ($$value) => $$invalidate(15, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("IonTabs", slots, ["default"]);
  let { ionTabsDidChange = () => {
  } } = $$props;
  let { ionTabsWillChange = () => {
  } } = $$props;
  let { slot = "bottom" } = $$props;
  let { tabs = [] } = $$props;
  let ionTabBarElement;
  let controller;
  const { pathname } = $page.url;
  let currentTabName = pathname.split("/").at(-1);
  const relativePath = pathname.replace(currentTabName, "");
  onMount(async () => {
    controller = ionTabBarElement;
    controller.select(currentTabName);
  });
  const tabBarClick = async (selectedTab) => {
    currentTabName = selectedTab;
    await goto(relativePath + selectedTab);
    controller.select(selectedTab);
  };
  const writable_props = ["ionTabsDidChange", "ionTabsWillChange", "slot", "tabs"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<IonTabs> was created with unknown prop '${key}'`);
  });
  const keydown_handler = (tab) => {
    tabBarClick(tab.tab);
  };
  const click_handler = (tab) => {
    tabBarClick(tab.tab);
  };
  const keydown_handler_1 = (tab) => {
    tabBarClick(tab.tab);
  };
  const click_handler_1 = (tab) => {
    tabBarClick(tab.tab);
  };
  function ion_tabs_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ionTabBarElement = $$value;
      $$invalidate(4, ionTabBarElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("ionTabsDidChange" in $$props2)
      $$invalidate(0, ionTabsDidChange = $$props2.ionTabsDidChange);
    if ("ionTabsWillChange" in $$props2)
      $$invalidate(1, ionTabsWillChange = $$props2.ionTabsWillChange);
    if ("slot" in $$props2)
      $$invalidate(2, slot = $$props2.slot);
    if ("tabs" in $$props2)
      $$invalidate(3, tabs = $$props2.tabs);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    page,
    goto,
    ionTabsDidChange,
    ionTabsWillChange,
    slot,
    tabs,
    ionTabBarElement,
    controller,
    pathname,
    currentTabName,
    relativePath,
    tabBarClick,
    $page
  });
  $$self.$inject_state = ($$props2) => {
    if ("ionTabsDidChange" in $$props2)
      $$invalidate(0, ionTabsDidChange = $$props2.ionTabsDidChange);
    if ("ionTabsWillChange" in $$props2)
      $$invalidate(1, ionTabsWillChange = $$props2.ionTabsWillChange);
    if ("slot" in $$props2)
      $$invalidate(2, slot = $$props2.slot);
    if ("tabs" in $$props2)
      $$invalidate(3, tabs = $$props2.tabs);
    if ("ionTabBarElement" in $$props2)
      $$invalidate(4, ionTabBarElement = $$props2.ionTabBarElement);
    if ("controller" in $$props2)
      controller = $$props2.controller;
    if ("currentTabName" in $$props2)
      currentTabName = $$props2.currentTabName;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ionTabsDidChange,
    ionTabsWillChange,
    slot,
    tabs,
    ionTabBarElement,
    tabBarClick,
    $$scope,
    slots,
    keydown_handler,
    click_handler,
    keydown_handler_1,
    click_handler_1,
    ion_tabs_binding
  ];
}
var IonTabs2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      ionTabsDidChange: 0,
      ionTabsWillChange: 1,
      slot: 2,
      tabs: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "IonTabs",
      options,
      id: create_fragment.name
    });
  }
  get ionTabsDidChange() {
    throw new Error("<IonTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ionTabsDidChange(value) {
    throw new Error("<IonTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ionTabsWillChange() {
    throw new Error("<IonTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ionTabsWillChange(value) {
    throw new Error("<IonTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slot() {
    throw new Error("<IonTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slot(value) {
    throw new Error("<IonTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<IonTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<IonTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var IonTabs_default = IonTabs2;

// node_modules/ionic-svelte/components/IonPage.svelte
var { console: console_1 } = globals;
var file2 = "node_modules/ionic-svelte/components/IonPage.svelte";
function create_fragment2(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "ion-page");
      add_location(div, file2, 34, 0, 964);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, fly, { x: 1e3, duration: 300 });
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(div, fly, { x: -1e3, duration: 300 });
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_outro)
        div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("IonPage", slots, ["default"]);
  const ionViewWillEnter = () => {
  };
  const ionViewDidEnter = () => {
  };
  const ionViewWillLeave = void 0;
  const ionViewDidLeave = () => {
  };
  ionViewWillEnter();
  onMount(() => {
    ionViewDidEnter();
  });
  onDestroy(() => {
    if (ionViewWillLeave != void 0) {
      console.warn(`ionViewWillLeave is not implemented - use beforeNavigate in $app/navigation. See  https://github.com/sveltejs/kit/issues/5879`);
    }
    ionViewDidLeave();
  });
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<IonPage> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    fly,
    onDestroy,
    onMount,
    ionViewWillEnter,
    ionViewDidEnter,
    ionViewWillLeave,
    ionViewDidLeave
  });
  return [
    ionViewWillEnter,
    ionViewDidEnter,
    ionViewWillLeave,
    ionViewDidLeave,
    $$scope,
    slots
  ];
}
var IonPage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      ionViewWillEnter: 0,
      ionViewDidEnter: 1,
      ionViewWillLeave: 2,
      ionViewDidLeave: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "IonPage",
      options,
      id: create_fragment2.name
    });
  }
  get ionViewWillEnter() {
    return this.$$.ctx[0];
  }
  set ionViewWillEnter(value) {
    throw new Error("<IonPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ionViewDidEnter() {
    return this.$$.ctx[1];
  }
  set ionViewDidEnter(value) {
    throw new Error("<IonPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ionViewWillLeave() {
    return this.$$.ctx[2];
  }
  set ionViewWillLeave(value) {
    throw new Error("<IonPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ionViewDidLeave() {
    return this.$$.ctx[3];
  }
  set ionViewDidLeave(value) {
    throw new Error("<IonPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var IonPage_default = IonPage;

// node_modules/ionic-svelte/components/IonNav.svelte
var file3 = "node_modules/ionic-svelte/components/IonNav.svelte";
function create_fragment3(ctx) {
  let ion_nav;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      ion_nav = element("ion-nav");
      this.h();
    },
    l: function claim(nodes) {
      ion_nav = claim_element(nodes, "ION-NAV", {
        animated: true,
        animation: true,
        "root-params": true,
        "swipe-gesture": true,
        root: true
      });
      children(ion_nav).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_custom_element_data(
        ion_nav,
        "animated",
        /*animated*/
        ctx[0]
      );
      set_custom_element_data(
        ion_nav,
        "animation",
        /*animation*/
        ctx[1]
      );
      set_custom_element_data(
        ion_nav,
        "root-params",
        /*rootParams*/
        ctx[2]
      );
      set_custom_element_data(
        ion_nav,
        "swipe-gesture",
        /*swipeGesture*/
        ctx[3]
      );
      set_custom_element_data(
        ion_nav,
        "root",
        /*rootComponent*/
        ctx[5]
      );
      add_location(ion_nav, file3, 58, 0, 1288);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ion_nav, anchor);
      ctx[9](ion_nav);
      if (!mounted) {
        dispose = [
          listen_dev(
            ion_nav,
            "ionNavDidChange",
            /*ionNavDidChange_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            ion_nav,
            "ionNavWillChange",
            /*ionNavWillChange_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*animated*/
      1) {
        set_custom_element_data(
          ion_nav,
          "animated",
          /*animated*/
          ctx2[0]
        );
      }
      if (dirty & /*animation*/
      2) {
        set_custom_element_data(
          ion_nav,
          "animation",
          /*animation*/
          ctx2[1]
        );
      }
      if (dirty & /*rootParams*/
      4) {
        set_custom_element_data(
          ion_nav,
          "root-params",
          /*rootParams*/
          ctx2[2]
        );
      }
      if (dirty & /*swipeGesture*/
      8) {
        set_custom_element_data(
          ion_nav,
          "swipe-gesture",
          /*swipeGesture*/
          ctx2[3]
        );
      }
      if (dirty & /*rootComponent*/
      32) {
        set_custom_element_data(
          ion_nav,
          "root",
          /*rootComponent*/
          ctx2[5]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ion_nav);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("IonNav", slots, []);
  let { root } = $$props;
  let { animated = true } = $$props;
  let { animation } = $$props;
  let { rootParams } = $$props;
  let { swipeGesture } = $$props;
  let ionNav;
  let rootComponent;
  const createHTMLCompFromSvelte2 = (component, componentProps = {}) => {
    const divWrapper = document.createElement("div");
    const contentID = "id" + Date.now();
    divWrapper.id = contentID;
    let navContent = document.createElement("div");
    divWrapper.appendChild(navContent);
    document.body.appendChild(divWrapper);
    const props = { ...componentProps };
    const svelteComponent = new component({ target: navContent, props });
    return divWrapper;
  };
  onMount(() => {
    $$invalidate(5, rootComponent = createHTMLCompFromSvelte2(root, {}));
  });
  $$self.$$.on_mount.push(function() {
    if (root === void 0 && !("root" in $$props || $$self.$$.bound[$$self.$$.props["root"]])) {
      console.warn("<IonNav> was created without expected prop 'root'");
    }
    if (animation === void 0 && !("animation" in $$props || $$self.$$.bound[$$self.$$.props["animation"]])) {
      console.warn("<IonNav> was created without expected prop 'animation'");
    }
    if (rootParams === void 0 && !("rootParams" in $$props || $$self.$$.bound[$$self.$$.props["rootParams"]])) {
      console.warn("<IonNav> was created without expected prop 'rootParams'");
    }
    if (swipeGesture === void 0 && !("swipeGesture" in $$props || $$self.$$.bound[$$self.$$.props["swipeGesture"]])) {
      console.warn("<IonNav> was created without expected prop 'swipeGesture'");
    }
  });
  const writable_props = ["root", "animated", "animation", "rootParams", "swipeGesture"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<IonNav> was created with unknown prop '${key}'`);
  });
  function ionNavDidChange_handler(event) {
    bubble.call(this, $$self, event);
  }
  function ionNavWillChange_handler(event) {
    bubble.call(this, $$self, event);
  }
  function ion_nav_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ionNav = $$value;
      $$invalidate(4, ionNav);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(6, root = $$props2.root);
    if ("animated" in $$props2)
      $$invalidate(0, animated = $$props2.animated);
    if ("animation" in $$props2)
      $$invalidate(1, animation = $$props2.animation);
    if ("rootParams" in $$props2)
      $$invalidate(2, rootParams = $$props2.rootParams);
    if ("swipeGesture" in $$props2)
      $$invalidate(3, swipeGesture = $$props2.swipeGesture);
  };
  $$self.$capture_state = () => ({
    onMount,
    root,
    animated,
    animation,
    rootParams,
    swipeGesture,
    ionNav,
    rootComponent,
    createHTMLCompFromSvelte: createHTMLCompFromSvelte2
  });
  $$self.$inject_state = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(6, root = $$props2.root);
    if ("animated" in $$props2)
      $$invalidate(0, animated = $$props2.animated);
    if ("animation" in $$props2)
      $$invalidate(1, animation = $$props2.animation);
    if ("rootParams" in $$props2)
      $$invalidate(2, rootParams = $$props2.rootParams);
    if ("swipeGesture" in $$props2)
      $$invalidate(3, swipeGesture = $$props2.swipeGesture);
    if ("ionNav" in $$props2)
      $$invalidate(4, ionNav = $$props2.ionNav);
    if ("rootComponent" in $$props2)
      $$invalidate(5, rootComponent = $$props2.rootComponent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    animated,
    animation,
    rootParams,
    swipeGesture,
    ionNav,
    rootComponent,
    root,
    ionNavDidChange_handler,
    ionNavWillChange_handler,
    ion_nav_binding
  ];
}
var IonNav2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      root: 6,
      animated: 0,
      animation: 1,
      rootParams: 2,
      swipeGesture: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "IonNav",
      options,
      id: create_fragment3.name
    });
  }
  get root() {
    throw new Error("<IonNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<IonNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animated() {
    throw new Error("<IonNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animated(value) {
    throw new Error("<IonNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animation() {
    throw new Error("<IonNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animation(value) {
    throw new Error("<IonNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootParams() {
    throw new Error("<IonNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rootParams(value) {
    throw new Error("<IonNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swipeGesture() {
    throw new Error("<IonNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swipeGesture(value) {
    throw new Error("<IonNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var IonNav_default = IonNav2;

// node_modules/ionic-svelte/index.ts
var setupIonicSvelte = async (config3) => {
  console.warn(`setupIonicSvelte will be deprecated - use setupIonicBase and add import 'ionic-svelte/components/all'; - see https://github.com/Tommertom/svelte-ionic-npm/blob/main/CHANGELOG.md#0530 and also for module-shaking options to reduce the size of your bundle. `);
  initialize(config3);
  defineIonComponents();
  if (typeof document !== "undefined") {
    document.documentElement.classList.add("ion-ce");
  }
};
var setupIonicBase = async (config3) => {
  initialize(config3);
  if (typeof document !== "undefined") {
    document.documentElement.classList.add("ion-ce");
  }
};
var registerMenu = (menuId) => {
  const query = "ion-menu[menu-id='" + menuId + "']";
  const menu = document.querySelector(query);
  if (menu) {
    menuController._register(menu);
  }
  return !!menu;
};
export {
  IonNav_default as IonNav,
  IonPage_default as IonPage,
  IonTabs_default as IonTabs,
  IonicSlides,
  IonicSwiper,
  actionSheetController,
  alertController,
  backButton,
  backButtonSubscribeWithPriority,
  createAnimation2 as createAnimation,
  createGesture,
  defineComponent,
  getPlatforms3 as getPlatforms,
  getQueryParam,
  getTimeGivenProgression,
  height,
  iosTransitionAnimation,
  is,
  isLandscape,
  isPlatform3 as isPlatform,
  isPortrait,
  isRTL,
  keyboardDidHide,
  keyboardDidShow,
  keydown,
  loadingController,
  mdTransitionAnimation,
  menuController,
  modalController3 as modalController,
  navController,
  networkStatus,
  pause,
  pickerController,
  popoverController3 as popoverController,
  prefersDark,
  registerMenu,
  resize,
  resume,
  setupIonicBase,
  setupIonicSvelte,
  setupPlatforms,
  testUserAgent,
  toastController,
  toggleDarkTheme,
  url,
  width
};
/*! Bundled license information:

@ionic/core/dist/esm-es5/cubic-bezier-e78d1307.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/dist/esm-es5/gesture-controller-17060b7c.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/dist/esm-es5/index-422b6e83.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/dist/esm-es5/ionic-global-c74e4951.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/dist/esm-es5/index-6661fe90.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/dist/esm-es5/hardware-back-button-490df115.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/dist/esm-es5/index-2b839939.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/dist/esm-es5/overlays-58fa8e4d.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/dist/esm-es5/index.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/components/ion-icon.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/components/ion-picker-column.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/components/ion-picker-column-internal.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/components/ion-picker-internal.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/components/ion-select-popover.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/components/index.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)

@ionic/core/dist/collection/global/config.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)
*/
//# sourceMappingURL=ionic-svelte.js.map
