import {
  ACESFilmicToneMapping,
  AmbientLight,
  Audio,
  AudioListener,
  AudioLoader,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Camera,
  Clock,
  Color,
  CylinderGeometry,
  DefaultLoadingManager,
  DirectionalLight,
  DoubleSide,
  Euler,
  EventDispatcher,
  Float32BufferAttribute,
  Fog,
  FogExp2,
  Frustum,
  Group,
  HemisphereLight,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  InterleavedBufferAttribute,
  Line,
  Line3,
  LineBasicMaterial,
  LineSegments,
  LinearEncoding,
  MOUSE,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  NoToneMapping,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PCFSoftShadowMap,
  PerspectiveCamera,
  PlaneGeometry,
  PointLight,
  PositionalAudio,
  Quaternion,
  Raycaster,
  Scene,
  ShaderLib,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  Spherical,
  SpotLight,
  TOUCH,
  Texture,
  TextureLoader,
  TorusGeometry,
  UniformsLib,
  UniformsUtils,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  WebGLRenderer,
  WireframeGeometry,
  sRGBEncoding
} from "./chunk-UMN7JHZN.js";
import {
  derived,
  readable,
  writable
} from "./chunk-ADM3CLVU.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  append_styles,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_store_value,
  space,
  subscribe,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-3PEI35UK.js";

// node_modules/three/examples/jsm/shaders/CopyShader.js
var CopyShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "opacity": { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`
  )
};

// node_modules/three/examples/jsm/postprocessing/Pass.js
var Pass = class {
  constructor() {
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
};
var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _geometry = new BufferGeometry();
_geometry.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
_geometry.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
var FullScreenQuad = class {
  constructor(material) {
    this._mesh = new Mesh(_geometry, material);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this._mesh, _camera);
  }
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
};

// node_modules/three/examples/jsm/postprocessing/ShaderPass.js
var ShaderPass = class extends Pass {
  constructor(shader, textureID) {
    super();
    this.textureID = textureID !== void 0 ? textureID : "tDiffuse";
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else if (shader) {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this.fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
  dispose() {
    this.material.dispose();
    this.fsQuad.dispose();
  }
};

// node_modules/three/examples/jsm/postprocessing/MaskPass.js
var MaskPass = class extends Pass {
  constructor(scene, camera) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  }
  render(renderer, writeBuffer, readBuffer) {
    const context = renderer.getContext();
    const state = renderer.state;
    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);
    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);
    let writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);
    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    state.buffers.stencil.setLocked(true);
  }
};
var ClearMaskPass = class extends Pass {
  constructor() {
    super();
    this.needsSwap = false;
  }
  render(renderer) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
};

// node_modules/three/examples/jsm/postprocessing/EffectComposer.js
var EffectComposer = class {
  constructor(renderer, renderTarget) {
    this.renderer = renderer;
    if (renderTarget === void 0) {
      const size = renderer.getSize(new Vector2());
      this._pixelRatio = renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio);
      renderTarget.texture.name = "EffectComposer.rt1";
    } else {
      this._pixelRatio = 1;
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];
    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new Clock();
  }
  swapBuffers() {
    const tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  }
  addPass(pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
    }
  }
  isLastEnabledPass(passIndex) {
    for (let i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }
    return true;
  }
  render(deltaTime) {
    if (deltaTime === void 0) {
      deltaTime = this.clock.getDelta();
    }
    const currentRenderTarget = this.renderer.getRenderTarget();
    let maskActive = false;
    for (let i = 0, il = this.passes.length; i < il; i++) {
      const pass = this.passes[i];
      if (pass.enabled === false)
        continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
      if (pass.needsSwap) {
        if (maskActive) {
          const context = this.renderer.getContext();
          const stencil = this.renderer.state.buffers.stencil;
          stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          stencil.setFunc(context.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      if (MaskPass !== void 0) {
        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  }
  reset(renderTarget) {
    if (renderTarget === void 0) {
      const size = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (let i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(effectiveWidth, effectiveHeight);
    }
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.copyPass.dispose();
  }
};

// node_modules/three/examples/jsm/postprocessing/RenderPass.js
var RenderPass = class extends Pass {
  constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
    this.clear = true;
    this.clearDepth = false;
    this.needsSwap = false;
    this._oldClearColor = new Color();
  }
  render(renderer, writeBuffer, readBuffer) {
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    let oldClearAlpha, oldOverrideMaterial;
    if (this.overrideMaterial !== void 0) {
      oldOverrideMaterial = this.scene.overrideMaterial;
      this.scene.overrideMaterial = this.overrideMaterial;
    }
    if (this.clearColor) {
      renderer.getClearColor(this._oldClearColor);
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }
    if (this.clearDepth) {
      renderer.clearDepth();
    }
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);
    if (this.clearColor) {
      renderer.setClearColor(this._oldClearColor, oldClearAlpha);
    }
    if (this.overrideMaterial !== void 0) {
      this.scene.overrideMaterial = oldOverrideMaterial;
    }
    renderer.autoClear = oldAutoClear;
  }
};

// node_modules/@threlte/core/dist/lib/renderer.js
var createRendererAndComposer = (ctx, canvas, rendererParameters) => {
  ctx.renderer = new WebGLRenderer({
    powerPreference: "high-performance",
    canvas,
    antialias: true,
    alpha: true,
    ...rendererParameters
  });
  ctx.composer = new EffectComposer(ctx.renderer);
  ctx.composer.addPass(new RenderPass(ctx.scene, get_store_value(ctx.camera)));
};
var setRendererColorOutput = (ctx, linear, flat) => {
  if (!ctx.renderer)
    return;
  if (linear) {
    ctx.renderer.outputEncoding = LinearEncoding;
  } else {
    ctx.renderer.outputEncoding = sRGBEncoding;
  }
  if (flat) {
    ctx.renderer.toneMapping = NoToneMapping;
  } else {
    ctx.renderer.toneMapping = ACESFilmicToneMapping;
  }
};
var setRendererAndComposerSize = (ctx, size, dpr) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (!ctx.renderer || !ctx.composer)
    return;
  (_b = (_a = ctx.renderer).setSize) == null ? void 0 : _b.call(_a, size.width, size.height);
  (_d = (_c = ctx.renderer).setPixelRatio) == null ? void 0 : _d.call(_c, dpr);
  (_f = (_e = ctx.composer).setSize) == null ? void 0 : _f.call(_e, size.width, size.height);
  (_h = (_g = ctx.composer).setPixelRatio) == null ? void 0 : _h.call(_g, dpr);
};
var setRendererShadows = (ctx, shadows, shadowMapType) => {
  if (!ctx.renderer)
    return;
  ctx.renderer.shadowMap.enabled = shadows;
  ctx.renderer.shadowMap.type = shadowMapType;
};

// node_modules/@threlte/core/dist/lib/getThrelteUserData.js
var getThrelteUserData = (object) => {
  return object.userData;
};

// node_modules/@threlte/core/dist/lib/interactivity.js
var setPointerFromEvent = (ctx, e) => {
  ctx.pointer.update((v2) => {
    if (!ctx.renderer)
      return v2;
    return v2.set(e.offsetX / ctx.renderer.domElement.clientWidth * 2 - 1, -(e.offsetY / ctx.renderer.domElement.clientHeight) * 2 + 1);
  });
};
var runRaycaster = (rootCtx, pointer, camera, objects) => {
  rootCtx.raycaster.setFromCamera(pointer, camera);
  return rootCtx.raycaster.intersectObjects(objects, false);
};
var targetChanged = (a, b) => {
  if (a.object.uuid !== b.object.uuid)
    return true;
  if (a.instanceId !== b.instanceId)
    return true;
  return false;
};
var useEventRaycast = (ctx, rootCtx, renderCtx) => {
  let camera;
  const unsubscribeCamera = ctx.camera.subscribe((value) => camera = value);
  onDestroy(unsubscribeCamera);
  let pointer;
  const unsubscribePointer = ctx.pointer.subscribe((value) => pointer = value);
  onDestroy(unsubscribePointer);
  let pointerDownOn;
  const onEvent = (e) => {
    var _a, _b;
    e.preventDefault();
    const eventType = e.type;
    ctx.pointerOverCanvas.set(true);
    renderCtx.pointerInvalidated = true;
    setPointerFromEvent(ctx, e);
    const intersection = getFirstIntersection(rootCtx, pointer, camera);
    if (eventType === "pointerdown") {
      pointerDownOn = intersection ? { object: intersection.object, instanceId: intersection.instanceId } : null;
    }
    if (eventType === "click") {
      if (!isValidClickEvent(intersection, pointerDownOn)) {
        pointerDownOn = null;
        return;
      }
      pointerDownOn = null;
    }
    if (!intersection)
      return;
    (_b = (_a = getThrelteUserData(intersection.object)).eventDispatcher) == null ? void 0 : _b.call(_a, eventType, {
      ...intersection,
      event: e
    });
  };
  return {
    onClick: onEvent,
    onContextMenu: onEvent,
    onPointerUp: onEvent,
    onPointerDown: onEvent,
    onPointerMove: onEvent
  };
};
function getFirstIntersection(rootCtx, pointer, camera) {
  if (rootCtx.interactiveObjects.size === 0 || rootCtx.raycastableObjects.size === 0)
    return null;
  const intersects = runRaycaster(rootCtx, pointer, camera, Array.from(rootCtx.raycastableObjects));
  if (intersects.length === 0 || !rootCtx.interactiveObjects.has(intersects[0].object))
    return null;
  return intersects[0];
}
function isValidClickEvent(intersection, pointerDownOn) {
  if (!intersection || !pointerDownOn)
    return false;
  return intersection.object.uuid === pointerDownOn.object.uuid && intersection.instanceId === pointerDownOn.instanceId;
}
var useFrameloopRaycast = (ctx, rootCtx) => {
  let pointerOverCanvas;
  const unsubscribePointerOverCanvas = ctx.pointerOverCanvas.subscribe((value) => pointerOverCanvas = value);
  onDestroy(unsubscribePointerOverCanvas);
  let camera;
  const unsubscribeCamera = ctx.camera.subscribe((value) => camera = value);
  onDestroy(unsubscribeCamera);
  let pointer;
  const unsubscribePointer = ctx.pointer.subscribe((value) => pointer = value);
  onDestroy(unsubscribePointer);
  const raycast = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (rootCtx.interactiveObjects.size === 0 || rootCtx.raycastableObjects.size === 0) {
      return;
    }
    const intersects = pointerOverCanvas ? runRaycaster(rootCtx, pointer, camera, Array.from(rootCtx.raycastableObjects)) : [];
    const intersection = intersects.length && rootCtx.interactiveObjects.has(intersects[0].object) ? intersects[0] : null;
    if (!intersection) {
      if (rootCtx.lastIntersection) {
        (_b = (_a = getThrelteUserData(rootCtx.lastIntersection.object)).eventDispatcher) == null ? void 0 : _b.call(_a, "pointerleave", rootCtx.lastIntersection);
      }
    } else {
      if (!rootCtx.lastIntersection) {
        (_d = (_c = getThrelteUserData(intersection.object)).eventDispatcher) == null ? void 0 : _d.call(_c, "pointerenter", intersection);
      } else if (rootCtx.lastIntersection && targetChanged(rootCtx.lastIntersection, intersection)) {
        (_f = (_e = getThrelteUserData(rootCtx.lastIntersection.object)).eventDispatcher) == null ? void 0 : _f.call(_e, "pointerleave", rootCtx.lastIntersection);
        (_h = (_g = getThrelteUserData(intersection.object)).eventDispatcher) == null ? void 0 : _h.call(_g, "pointerenter", intersection);
      }
    }
    rootCtx.lastIntersection = intersection;
  };
  return {
    raycast
  };
};

// node_modules/@threlte/core/dist/lib/browser.js
var browser = typeof window !== "undefined";

// node_modules/@threlte/core/dist/hooks/useRaf.js
var useRaf = (cb) => {
  if (!browser)
    return;
  let handle;
  const tick2 = () => {
    cb();
    handle = requestAnimationFrame(tick2);
  };
  tick2();
  onDestroy(() => {
    if (!handle)
      return;
    cancelAnimationFrame(handle);
  });
};

// node_modules/@threlte/core/dist/lib/frameloop.js
var runFrameloopCallbacks = (ctx, renderCtx) => {
  if (renderCtx.frameHandlers.size === 0)
    return;
  if (renderCtx.debugFrameloop) {
    let genericFrameHandlers = 0;
    renderCtx.frameHandlers.forEach((h) => {
      if (h.debugFrameloopMessage) {
        renderCtx.invalidations[h.debugFrameloopMessage] = h.debugFrameloopMessage in renderCtx.invalidations ? renderCtx.invalidations[h.debugFrameloopMessage] + 1 : 1;
      } else {
        ++genericFrameHandlers;
      }
    });
    if (genericFrameHandlers > 0)
      renderCtx.invalidations["onFrame"] = renderCtx.frameHandlers.size;
  }
  const anyHasOrder = Array.from(renderCtx.frameHandlers).reduce((acc, h) => h.order ? true : acc, false);
  const delta = ctx.clock.getDelta();
  if (anyHasOrder) {
    Array.from(renderCtx.frameHandlers).sort((a, b) => (a.order ?? 0) > (b.order ?? 0) ? 1 : -1).forEach((h) => h.fn(ctx, delta));
  } else {
    renderCtx.frameHandlers.forEach((h) => h.fn(ctx, delta));
  }
};
var debugFrame = (renderCtx) => {
  if (!renderCtx.debugFrameloop)
    return;
  renderCtx.frame += 1;
  console.log(`frame: ${renderCtx.frame}${Object.keys(renderCtx.invalidations).length > 0 ? ", requested by ↴" : ""}`);
  if (Object.keys(renderCtx.invalidations).length > 0)
    console.table(renderCtx.invalidations);
  renderCtx.invalidations = {};
};
var useFrameloop = (ctx, rootCtx, renderCtx, disposalCtx) => {
  let camera = get_store_value(ctx.camera);
  const unsubscribeCamera = ctx.camera.subscribe((c) => camera = c);
  onDestroy(unsubscribeCamera);
  const { raycast } = useFrameloopRaycast(ctx, rootCtx);
  useRaf(() => {
    disposalCtx.dispose();
    const shouldRender = renderCtx.frameloop === "always" || renderCtx.frameloop === "demand" && (renderCtx.frameInvalidated || renderCtx.frameHandlers.size > 0) || renderCtx.frameloop === "never" && renderCtx.advance;
    const shouldRaycast = shouldRender || renderCtx.pointerInvalidated;
    if (shouldRaycast) {
      raycast();
      renderCtx.pointerInvalidated = false;
    }
    if (!shouldRender)
      return;
    if (!camera || !ctx.composer || !ctx.renderer)
      return;
    runFrameloopCallbacks(ctx, renderCtx);
    if (ctx.composer.passes.length > 1) {
      ctx.composer.render();
    } else {
      ctx.renderer.render(ctx.scene, camera);
    }
    debugFrame(renderCtx);
    renderCtx.frameInvalidated = false;
    renderCtx.advance = false;
  });
};

// node_modules/@threlte/core/dist/lib/defaultCamera.js
var getDefaultCamera = () => {
  const defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1e3);
  getThrelteUserData(defaultCamera).threlteDefaultCamera = true;
  defaultCamera.position.z = 5;
  defaultCamera.lookAt(0, 0, 0);
  return defaultCamera;
};
var setDefaultCameraAspectOnSizeChange = (ctx) => {
  const unsubscribe = ctx.size.subscribe((size) => {
    if (getThrelteUserData(get_store_value(ctx.camera)).threlteDefaultCamera) {
      ctx.camera.update((c) => {
        const cam = c;
        cam.aspect = size.width / size.height;
        cam.updateProjectionMatrix();
        ctx.invalidate("Default camera: aspect ratio changed");
        return cam;
      });
    }
  });
  onDestroy(unsubscribe);
};

// node_modules/@threlte/core/dist/lib/contexts.js
var createContexts = (linear, flat, dpr, userSize, parentSize, debugFrameloop, frameloop) => {
  const audioCtx = {
    audioListeners: /* @__PURE__ */ new Map(),
    addAudioListener: (listener, id) => {
      id = id ?? "default";
      if (audioCtx.audioListeners.has(id)) {
        console.warn(`An AudioListener with the id "${id}" has already been added, aborting.`);
        return;
      }
      audioCtx.audioListeners.set(id, listener);
    },
    removeAudioListener: (id) => {
      id = id ?? "default";
      if (!audioCtx.audioListeners.has(id)) {
        console.warn(`No AudioListener with the id "${id}" found, aborting.`);
        return;
      }
      audioCtx.audioListeners.delete(id);
    },
    getAudioListener: (id) => {
      id = id ?? "default";
      if (!audioCtx.audioListeners.has(id)) {
        console.warn(`No AudioListener with the id "${id}" found, aborting.`);
        return;
      }
      return audioCtx.audioListeners.get(id);
    }
  };
  const renderCtx = {
    debugFrameloop,
    frameloop,
    frame: 0,
    frameInvalidated: true,
    pointerInvalidated: true,
    invalidations: {},
    frameHandlers: /* @__PURE__ */ new Set(),
    advance: false
  };
  const ctx = {
    size: derived([userSize, parentSize], ([uSize, pSize]) => {
      return uSize ? uSize : pSize;
    }),
    pointer: writable(new Vector2()),
    pointerOverCanvas: writable(false),
    clock: new Clock(),
    camera: writable(getDefaultCamera()),
    scene: new Scene(),
    renderer: void 0,
    composer: void 0,
    invalidate: (debugFrameloopMessage) => {
      renderCtx.frameInvalidated = true;
      if (renderCtx.debugFrameloop && debugFrameloopMessage) {
        renderCtx.invalidations[debugFrameloopMessage] = renderCtx.invalidations[debugFrameloopMessage] ? renderCtx.invalidations[debugFrameloopMessage] + 1 : 1;
      }
    },
    advance: () => {
      renderCtx.advance = true;
    }
  };
  const rootCtx = {
    flat: writable(flat),
    linear: writable(linear),
    dpr: writable(dpr),
    setCamera: (camera) => {
      ctx.camera.set(camera);
      if (!ctx.composer)
        return;
      ctx.composer.passes.forEach((pass) => {
        if (pass instanceof RenderPass) {
          pass.camera = camera;
        }
      });
      ctx.invalidate("Canvas: setting camera");
    },
    raycastableObjects: /* @__PURE__ */ new Set(),
    interactiveObjects: /* @__PURE__ */ new Set(),
    raycaster: new Raycaster(),
    lastIntersection: null,
    addRaycastableObject: (object) => {
      rootCtx.raycastableObjects.add(object);
    },
    removeRaycastableObject: (object) => {
      rootCtx.raycastableObjects.delete(object);
    },
    addInteractiveObject: (object) => {
      rootCtx.interactiveObjects.add(object);
    },
    removeInteractiveObject: (object) => {
      rootCtx.interactiveObjects.delete(object);
    },
    addPass: (pass) => {
      if (!ctx.composer)
        return;
      ctx.composer.addPass(pass);
      ctx.invalidate("Canvas: adding pass");
    },
    removePass: (pass) => {
      if (!ctx.composer)
        return;
      ctx.composer.removePass(pass);
      ctx.invalidate("Canvas: removing pass");
    }
  };
  const disposalCtx = {
    dispose: async (force = false) => {
      await tick();
      if (!disposalCtx.shouldDispose && !force)
        return;
      disposalCtx.disposableObjects.forEach((mounted, object) => {
        var _a;
        if (mounted === 0 || force) {
          (_a = object == null ? void 0 : object.dispose) == null ? void 0 : _a.call(object);
          disposalCtx.disposableObjects.delete(object);
        }
      });
      disposalCtx.shouldDispose = false;
    },
    collectDisposableObjects: (object, objects) => {
      const disposables = objects ?? [];
      if (!object)
        return disposables;
      if ((object == null ? void 0 : object.dispose) && typeof object.dispose === "function" && object.type !== "Scene") {
        disposables.push(object);
      }
      Object.entries(object).forEach(([propKey, propValue]) => {
        if (propKey === "parent" || propKey === "children" || typeof propValue !== "object")
          return;
        const value = propValue;
        if (value == null ? void 0 : value.dispose) {
          disposalCtx.collectDisposableObjects(value, disposables);
        }
      });
      return disposables;
    },
    addDisposableObjects: (objects) => {
      objects.forEach((obj) => {
        const currentValue = disposalCtx.disposableObjects.get(obj);
        if (currentValue) {
          disposalCtx.disposableObjects.set(obj, currentValue + 1);
        } else {
          disposalCtx.disposableObjects.set(obj, 1);
        }
      });
    },
    removeDisposableObjects: (objects) => {
      if (objects.length === 0)
        return;
      objects.forEach((obj) => {
        const currentValue = disposalCtx.disposableObjects.get(obj);
        if (currentValue && currentValue > 0) {
          disposalCtx.disposableObjects.set(obj, currentValue - 1);
        }
      });
      disposalCtx.shouldDispose = true;
    },
    disposableObjects: /* @__PURE__ */ new Map(),
    shouldDispose: false
  };
  setContext("threlte", ctx);
  setContext("threlte-root", rootCtx);
  setContext("threlte-render-context", renderCtx);
  setContext("threlte-audio-context", audioCtx);
  setContext("threlte-disposal-context", disposalCtx);
  const getCtx = () => ctx;
  const getRootCtx = () => rootCtx;
  const getRenderCtx = () => renderCtx;
  const getAudioCtx = () => audioCtx;
  const getDisposalCtx = () => disposalCtx;
  return {
    ctx,
    rootCtx,
    renderCtx,
    audioCtx,
    disposalCtx,
    getCtx,
    getRootCtx,
    getRenderCtx,
    getAudioCtx,
    getDisposalCtx
  };
};

// node_modules/@threlte/core/dist/lib/createObjectStore.js
function createObjectStore(object, onChange) {
  const objectStore = writable(object);
  let unwrappedObject = object;
  const unsubscribeObjectStore = objectStore.subscribe((o) => unwrappedObject = o);
  onDestroy(unsubscribeObjectStore);
  const set = (newObject) => {
    if ((newObject == null ? void 0 : newObject.uuid) === (unwrappedObject == null ? void 0 : unwrappedObject.uuid))
      return;
    const oldObject = unwrappedObject;
    objectStore.set(newObject);
    onChange == null ? void 0 : onChange(newObject, oldObject);
  };
  const update = (callback) => {
    const newObject = callback(unwrappedObject);
    if ((newObject == null ? void 0 : newObject.uuid) === (unwrappedObject == null ? void 0 : unwrappedObject.uuid))
      return;
    const oldObject = unwrappedObject;
    objectStore.set(newObject);
    onChange == null ? void 0 : onChange(newObject, oldObject);
  };
  return {
    ...objectStore,
    set,
    update
  };
}

// node_modules/@threlte/core/dist/hooks/useThrelte.js
var useThrelte = () => {
  return getContext("threlte");
};

// node_modules/@threlte/core/dist/internal/HierarchicalObject.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var useHierarchicalObject = () => {
  return {
    onChildMount: getContext("threlte-hierarchical-object-on-mount"),
    onChildDestroy: getContext("threlte-hierarchical-object-on-destroy")
  };
};
var useParent = () => {
  return getContext("threlte-hierarchical-parent-context");
};
function instance($$self, $$props, $$invalidate) {
  var _a;
  let $parentStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HierarchicalObject", slots, ["default"]);
  let { object = void 0 } = $$props;
  let { children: children2 = [] } = $$props;
  let { onChildMount = void 0 } = $$props;
  const onChildMountProxy = (child) => {
    children2.push(child);
    $$invalidate(1, children2);
    onChildMount == null ? void 0 : onChildMount(child);
  };
  let { onChildDestroy = void 0 } = $$props;
  const onChildDestroyProxy = (child) => {
    const index = children2.findIndex((c) => c.uuid === child.uuid);
    if (index !== -1)
      children2.splice(index, 1);
    $$invalidate(1, children2);
    onChildDestroy == null ? void 0 : onChildDestroy(child);
  };
  const { invalidate } = useThrelte();
  const parentStore = useParent();
  validate_store(parentStore, "parentStore");
  component_subscribe($$self, parentStore, (value) => $$invalidate(6, $parentStore = value));
  let { parent = $parentStore } = $$props;
  const parentCallbacks = useHierarchicalObject();
  if (object) {
    (_a = parentCallbacks.onChildMount) == null ? void 0 : _a.call(parentCallbacks, object);
    invalidate("HierarchicalObject: object added");
  }
  const objectStore = createObjectStore(object, (newObject, oldObject) => {
    var _a2, _b;
    if (oldObject) {
      (_a2 = parentCallbacks.onChildDestroy) == null ? void 0 : _a2.call(parentCallbacks, oldObject);
      invalidate("HierarchicalObject: object added");
    }
    if (newObject) {
      (_b = parentCallbacks.onChildMount) == null ? void 0 : _b.call(parentCallbacks, newObject);
      invalidate("HierarchicalObject: object removed");
    }
  });
  onDestroy(() => {
    var _a2;
    if (object) {
      (_a2 = parentCallbacks.onChildDestroy) == null ? void 0 : _a2.call(parentCallbacks, object);
      invalidate("HierarchicalObject: object removed");
    }
  });
  setContext("threlte-hierarchical-object-on-mount", onChildMountProxy);
  setContext("threlte-hierarchical-object-on-destroy", onChildDestroyProxy);
  setContext("threlte-hierarchical-parent-context", objectStore);
  const writable_props = ["object", "children", "onChildMount", "onChildDestroy", "parent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HierarchicalObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(3, object = $$props2.object);
    if ("children" in $$props2)
      $$invalidate(1, children2 = $$props2.children);
    if ("onChildMount" in $$props2)
      $$invalidate(4, onChildMount = $$props2.onChildMount);
    if ("onChildDestroy" in $$props2)
      $$invalidate(5, onChildDestroy = $$props2.onChildDestroy);
    if ("parent" in $$props2)
      $$invalidate(2, parent = $$props2.parent);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    setContext,
    useThrelte,
    createObjectStore,
    useHierarchicalObject,
    useParent,
    object,
    children: children2,
    onChildMount,
    onChildMountProxy,
    onChildDestroy,
    onChildDestroyProxy,
    invalidate,
    parentStore,
    parent,
    parentCallbacks,
    objectStore,
    $parentStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(3, object = $$props2.object);
    if ("children" in $$props2)
      $$invalidate(1, children2 = $$props2.children);
    if ("onChildMount" in $$props2)
      $$invalidate(4, onChildMount = $$props2.onChildMount);
    if ("onChildDestroy" in $$props2)
      $$invalidate(5, onChildDestroy = $$props2.onChildDestroy);
    if ("parent" in $$props2)
      $$invalidate(2, parent = $$props2.parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$parentStore*/
    64) {
      $:
        $$invalidate(2, parent = $parentStore);
    }
    if ($$self.$$.dirty & /*object*/
    8) {
      $:
        objectStore.set(object);
    }
  };
  return [
    parentStore,
    children2,
    parent,
    object,
    onChildMount,
    onChildDestroy,
    $parentStore,
    $$scope,
    slots
  ];
}
var HierarchicalObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      object: 3,
      children: 1,
      onChildMount: 4,
      onChildDestroy: 5,
      parent: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HierarchicalObject",
      options,
      id: create_fragment.name
    });
  }
  get object() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChildMount() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChildMount(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChildDestroy() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChildDestroy(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HierarchicalObject_default = HierarchicalObject;

// node_modules/@threlte/core/dist/internal/SceneGraphObject.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(5:0) <HierarchicalObject   {object}   onChildMount={(child) => object.add(child)}   onChildDestroy={(child) => object.remove(child)} >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let hierarchicalobject;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      object: (
        /*object*/
        ctx[0]
      ),
      onChildMount: (
        /*func*/
        ctx[2]
      ),
      onChildDestroy: (
        /*func_1*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hierarchicalobject_changes = {};
      if (dirty & /*object*/
      1)
        hierarchicalobject_changes.object = /*object*/
        ctx2[0];
      if (dirty & /*object*/
      1)
        hierarchicalobject_changes.onChildMount = /*func*/
        ctx2[2];
      if (dirty & /*object*/
      1)
        hierarchicalobject_changes.onChildDestroy = /*func_1*/
        ctx2[3];
      if (dirty & /*$$scope*/
      16) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hierarchicalobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SceneGraphObject", slots, ["default"]);
  let { object } = $$props;
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<SceneGraphObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SceneGraphObject> was created with unknown prop '${key}'`);
  });
  const func = (child) => object.add(child);
  const func_1 = (child) => object.remove(child);
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(0, object = $$props2.object);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ HierarchicalObject: HierarchicalObject_default, object });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(0, object = $$props2.object);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [object, slots, func, func_1, $$scope];
}
var SceneGraphObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { object: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SceneGraphObject",
      options,
      id: create_fragment2.name
    });
  }
  get object() {
    throw new Error("<SceneGraphObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<SceneGraphObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SceneGraphObject_default = SceneGraphObject;

// node_modules/@threlte/core/dist/hooks/useParentSize.js
var useParentSize = () => {
  const parentSizeStore = writable({ width: 0, height: 0 });
  let parentSize = { width: 0, height: 0 };
  const unsubscribeParentSize = parentSizeStore.subscribe((s) => parentSize = s);
  onDestroy(unsubscribeParentSize);
  let el;
  const proxy = () => {
    const currentParentSize = parentSize;
    if (!el)
      return;
    if (!el.parentElement)
      return;
    const { clientWidth, clientHeight } = el.parentElement;
    if (clientWidth !== currentParentSize.width || clientHeight !== currentParentSize.height) {
      parentSizeStore.set({
        width: clientWidth,
        height: clientHeight
      });
    }
  };
  const parentSizeAction = (node) => {
    el = node;
    proxy();
    window.addEventListener("resize", proxy);
  };
  if (!browser) {
    return {
      parentSize: parentSizeStore,
      parentSizeAction
    };
  }
  onDestroy(() => {
    window.removeEventListener("resize", proxy);
  });
  return {
    parentSizeAction,
    parentSize: parentSizeStore
  };
};

// node_modules/@threlte/core/dist/Canvas.svelte
var file = "node_modules/@threlte/core/dist/Canvas.svelte";
function add_css(target) {
  append_styles(target, "svelte-z3m47x", "canvas.svelte-z3m47x{display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FudmFzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF5RkUsb0JBQU8sQ0FDTCxPQUFPLENBQUUsS0FDWCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDYW52YXMuc3ZlbHRlIl19 */");
}
function create_if_block(ctx) {
  let scenegraphobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*ctx*/
        ctx[0].scene
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const scenegraphobject_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(82:2) {#if initialized}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[33],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[33],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[33]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[33],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(83:4) <SceneGraphObject object={ctx.scene}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let canvas_1;
  let parentSizeAction_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*initialized*/
    ctx[2] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      canvas_1 = element("canvas");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      canvas_1 = claim_element(nodes, "CANVAS", { class: true });
      var canvas_1_nodes = children(canvas_1);
      if (if_block)
        if_block.l(canvas_1_nodes);
      canvas_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(canvas_1, "class", "svelte-z3m47x");
      add_location(canvas_1, file, 70, 0, 2934);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, canvas_1, anchor);
      if (if_block)
        if_block.m(canvas_1, null);
      ctx[30](canvas_1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(parentSizeAction_action = /*parentSizeAction*/
          ctx[3].call(null, canvas_1)),
          listen_dev(
            canvas_1,
            "click",
            /*onClick*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "contextmenu",
            /*onContextMenu*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointerup",
            /*onPointerUp*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointerdown",
            /*onPointerDown*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointermove",
            /*onPointerMove*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointerenter",
            /*pointerenter_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointerleave",
            /*pointerleave_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*initialized*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*initialized*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(canvas_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(canvas_1);
      if (if_block)
        if_block.d();
      ctx[30](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var invalidationHandlers = /* @__PURE__ */ new Set();
var invalidateGlobally = (debugFrameloopMessage) => {
  invalidationHandlers.forEach((fn) => fn(debugFrameloopMessage));
};
function instance3($$self, $$props, $$invalidate) {
  let $dprStore;
  let $derivedSize;
  let $flatStore;
  let $linearStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Canvas", slots, ["default"]);
  let { dpr = browser ? window.devicePixelRatio : 1 } = $$props;
  let { flat = false } = $$props;
  let { linear = false } = $$props;
  let { frameloop = "demand" } = $$props;
  let { debugFrameloop = false } = $$props;
  let { shadows = true } = $$props;
  let { shadowMapType = PCFSoftShadowMap } = $$props;
  let { size = void 0 } = $$props;
  let { rendererParameters = void 0 } = $$props;
  let canvas;
  let initialized = false;
  const userSize = writable(size);
  const { parentSize, parentSizeAction } = useParentSize();
  const contexts = createContexts(linear, flat, dpr, userSize, parentSize, debugFrameloop, frameloop);
  const { getCtx, renderCtx, disposalCtx } = contexts;
  const { ctx, rootCtx, audioCtx } = contexts;
  setDefaultCameraAspectOnSizeChange(ctx);
  invalidationHandlers.add(ctx.invalidate);
  onDestroy(() => {
    invalidationHandlers.delete(ctx.invalidate);
  });
  const { size: derivedSize, scene } = ctx;
  validate_store(derivedSize, "derivedSize");
  component_subscribe($$self, derivedSize, (value) => $$invalidate(26, $derivedSize = value));
  const { flat: flatStore, linear: linearStore, dpr: dprStore } = rootCtx;
  validate_store(flatStore, "flatStore");
  component_subscribe($$self, flatStore, (value) => $$invalidate(27, $flatStore = value));
  validate_store(linearStore, "linearStore");
  component_subscribe($$self, linearStore, (value) => $$invalidate(28, $linearStore = value));
  validate_store(dprStore, "dprStore");
  component_subscribe($$self, dprStore, (value) => $$invalidate(25, $dprStore = value));
  setContext("threlte-parent", writable(scene));
  onMount(() => {
    if (!canvas)
      return;
    createRendererAndComposer(ctx, canvas, rendererParameters);
    setRendererColorOutput(ctx, $linearStore, $flatStore);
    setRendererAndComposerSize(ctx, $derivedSize, $dprStore);
    setRendererShadows(ctx, shadows, shadowMapType);
    $$invalidate(2, initialized = true);
  });
  useFrameloop(ctx, rootCtx, renderCtx, disposalCtx);
  const { onClick, onContextMenu, onPointerDown: onPointerDown2, onPointerMove: onPointerMove2, onPointerUp: onPointerUp2 } = useEventRaycast(ctx, rootCtx, renderCtx);
  onDestroy(() => {
    disposalCtx.dispose(true);
  });
  const writable_props = [
    "dpr",
    "flat",
    "linear",
    "frameloop",
    "debugFrameloop",
    "shadows",
    "shadowMapType",
    "size",
    "rendererParameters"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Canvas> was created with unknown prop '${key}'`);
  });
  function canvas_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvas = $$value;
      $$invalidate(1, canvas);
    });
  }
  const pointerenter_handler = () => getCtx().pointerOverCanvas.set(true);
  const pointerleave_handler = () => getCtx().pointerOverCanvas.set(false);
  $$self.$$set = ($$props2) => {
    if ("dpr" in $$props2)
      $$invalidate(14, dpr = $$props2.dpr);
    if ("flat" in $$props2)
      $$invalidate(15, flat = $$props2.flat);
    if ("linear" in $$props2)
      $$invalidate(16, linear = $$props2.linear);
    if ("frameloop" in $$props2)
      $$invalidate(17, frameloop = $$props2.frameloop);
    if ("debugFrameloop" in $$props2)
      $$invalidate(18, debugFrameloop = $$props2.debugFrameloop);
    if ("shadows" in $$props2)
      $$invalidate(19, shadows = $$props2.shadows);
    if ("shadowMapType" in $$props2)
      $$invalidate(20, shadowMapType = $$props2.shadowMapType);
    if ("size" in $$props2)
      $$invalidate(21, size = $$props2.size);
    if ("rendererParameters" in $$props2)
      $$invalidate(22, rendererParameters = $$props2.rendererParameters);
    if ("$$scope" in $$props2)
      $$invalidate(33, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    setContext,
    writable,
    PCFSoftShadowMap,
    useParentSize,
    SceneGraphObject: SceneGraphObject_default,
    browser,
    createContexts,
    setDefaultCameraAspectOnSizeChange,
    useFrameloop,
    useEventRaycast,
    createRendererAndComposer,
    setRendererAndComposerSize,
    setRendererColorOutput,
    setRendererShadows,
    invalidationHandlers,
    invalidateGlobally,
    dpr,
    flat,
    linear,
    frameloop,
    debugFrameloop,
    shadows,
    shadowMapType,
    size,
    rendererParameters,
    canvas,
    initialized,
    userSize,
    parentSize,
    parentSizeAction,
    contexts,
    getCtx,
    renderCtx,
    disposalCtx,
    ctx,
    rootCtx,
    audioCtx,
    derivedSize,
    scene,
    flatStore,
    linearStore,
    dprStore,
    onClick,
    onContextMenu,
    onPointerDown: onPointerDown2,
    onPointerMove: onPointerMove2,
    onPointerUp: onPointerUp2,
    $dprStore,
    $derivedSize,
    $flatStore,
    $linearStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("dpr" in $$props2)
      $$invalidate(14, dpr = $$props2.dpr);
    if ("flat" in $$props2)
      $$invalidate(15, flat = $$props2.flat);
    if ("linear" in $$props2)
      $$invalidate(16, linear = $$props2.linear);
    if ("frameloop" in $$props2)
      $$invalidate(17, frameloop = $$props2.frameloop);
    if ("debugFrameloop" in $$props2)
      $$invalidate(18, debugFrameloop = $$props2.debugFrameloop);
    if ("shadows" in $$props2)
      $$invalidate(19, shadows = $$props2.shadows);
    if ("shadowMapType" in $$props2)
      $$invalidate(20, shadowMapType = $$props2.shadowMapType);
    if ("size" in $$props2)
      $$invalidate(21, size = $$props2.size);
    if ("rendererParameters" in $$props2)
      $$invalidate(22, rendererParameters = $$props2.rendererParameters);
    if ("canvas" in $$props2)
      $$invalidate(1, canvas = $$props2.canvas);
    if ("initialized" in $$props2)
      $$invalidate(2, initialized = $$props2.initialized);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*size*/
    2097152) {
      $:
        userSize.set(size);
    }
    if ($$self.$$.dirty[0] & /*linear*/
    65536) {
      $:
        set_store_value(linearStore, $linearStore = linear, $linearStore);
    }
    if ($$self.$$.dirty[0] & /*flat*/
    32768) {
      $:
        set_store_value(flatStore, $flatStore = flat, $flatStore);
    }
    if ($$self.$$.dirty[0] & /*dpr*/
    16384) {
      $:
        set_store_value(dprStore, $dprStore = dpr, $dprStore);
    }
    if ($$self.$$.dirty[0] & /*$linearStore, $flatStore*/
    402653184) {
      $:
        setRendererColorOutput(getCtx(), $linearStore, $flatStore);
    }
    if ($$self.$$.dirty[0] & /*$derivedSize, $dprStore*/
    100663296) {
      $:
        setRendererAndComposerSize(getCtx(), $derivedSize, $dprStore);
    }
    if ($$self.$$.dirty[0] & /*shadows, shadowMapType*/
    1572864) {
      $:
        setRendererShadows(getCtx(), shadows, shadowMapType);
    }
  };
  return [
    ctx,
    canvas,
    initialized,
    parentSizeAction,
    getCtx,
    derivedSize,
    flatStore,
    linearStore,
    dprStore,
    onClick,
    onContextMenu,
    onPointerDown2,
    onPointerMove2,
    onPointerUp2,
    dpr,
    flat,
    linear,
    frameloop,
    debugFrameloop,
    shadows,
    shadowMapType,
    size,
    rendererParameters,
    rootCtx,
    audioCtx,
    $dprStore,
    $derivedSize,
    $flatStore,
    $linearStore,
    slots,
    canvas_1_binding,
    pointerenter_handler,
    pointerleave_handler,
    $$scope
  ];
}
var Canvas = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        dpr: 14,
        flat: 15,
        linear: 16,
        frameloop: 17,
        debugFrameloop: 18,
        shadows: 19,
        shadowMapType: 20,
        size: 21,
        rendererParameters: 22,
        ctx: 0,
        rootCtx: 23,
        audioCtx: 24
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Canvas",
      options,
      id: create_fragment3.name
    });
  }
  get dpr() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dpr(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flat() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flat(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linear() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linear(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frameloop() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frameloop(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debugFrameloop() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debugFrameloop(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadows() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadows(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadowMapType() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadowMapType(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rendererParameters() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rendererParameters(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ctx() {
    return this.$$.ctx[0];
  }
  set ctx(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootCtx() {
    return this.$$.ctx[23];
  }
  set rootCtx(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audioCtx() {
    return this.$$.ctx[24];
  }
  set audioCtx(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Canvas_default = Canvas;

// node_modules/@threlte/core/dist/hooks/useThrelteRoot.js
var useThrelteRoot = () => {
  return getContext("threlte-root");
};

// node_modules/@threlte/core/dist/hooks/useThrelteDisposal.js
var useThrelteDisposal = () => {
  return getContext("threlte-disposal-context");
};

// node_modules/@threlte/core/dist/internal/DisposableObject.svelte
function create_fragment4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var contextName = "threlte-disposable-object-context";
function instance4($$self, $$props, $$invalidate) {
  let $mergedDispose;
  let $parentDispose;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DisposableObject", slots, ["default"]);
  const { collectDisposableObjects, addDisposableObjects, removeDisposableObjects } = useThrelteDisposal();
  let { object = void 0 } = $$props;
  let previousObject = object;
  let { dispose = void 0 } = $$props;
  const parentDispose = getContext(contextName);
  validate_store(parentDispose, "parentDispose");
  component_subscribe($$self, parentDispose, (value) => $$invalidate(7, $parentDispose = value));
  const mergedDispose = writable(dispose ?? $parentDispose ?? true);
  validate_store(mergedDispose, "mergedDispose");
  component_subscribe($$self, mergedDispose, (value) => $$invalidate(6, $mergedDispose = value));
  setContext(contextName, mergedDispose);
  let disposables = $mergedDispose ? collectDisposableObjects(object) : [];
  addDisposableObjects(disposables);
  onDestroy(() => {
    removeDisposableObjects(disposables);
  });
  const writable_props = ["object", "dispose"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DisposableObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("dispose" in $$props2)
      $$invalidate(3, dispose = $$props2.dispose);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    setContext,
    writable,
    useThrelteDisposal,
    collectDisposableObjects,
    addDisposableObjects,
    removeDisposableObjects,
    object,
    previousObject,
    dispose,
    contextName,
    parentDispose,
    mergedDispose,
    disposables,
    $mergedDispose,
    $parentDispose
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("previousObject" in $$props2)
      $$invalidate(4, previousObject = $$props2.previousObject);
    if ("dispose" in $$props2)
      $$invalidate(3, dispose = $$props2.dispose);
    if ("disposables" in $$props2)
      $$invalidate(5, disposables = $$props2.disposables);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dispose, $parentDispose*/
    136) {
      $:
        mergedDispose.set(dispose ?? $parentDispose ?? true);
    }
    if ($$self.$$.dirty & /*object, previousObject, disposables, $mergedDispose*/
    116) {
      $: {
        if (object !== previousObject) {
          removeDisposableObjects(disposables);
          $$invalidate(5, disposables = $mergedDispose ? collectDisposableObjects(object) : []);
          addDisposableObjects(disposables);
          $$invalidate(4, previousObject = object);
        }
      }
    }
  };
  return [
    parentDispose,
    mergedDispose,
    object,
    dispose,
    previousObject,
    disposables,
    $mergedDispose,
    $parentDispose,
    $$scope,
    slots
  ];
}
var DisposableObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { object: 2, dispose: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DisposableObject",
      options,
      id: create_fragment4.name
    });
  }
  get object() {
    throw new Error("<DisposableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<DisposableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<DisposableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<DisposableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DisposableObject_default = DisposableObject;

// node_modules/@threlte/core/dist/internal/LayerableObject.svelte
function create_fragment5(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let $layers;
  let $objectStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LayerableObject", slots, []);
  let { object } = $$props;
  const objectStore = createObjectStore(object);
  validate_store(objectStore, "objectStore");
  component_subscribe($$self, objectStore, (value) => $$invalidate(4, $objectStore = value));
  const layers = getContext("threlte-layers");
  validate_store(layers, "layers");
  component_subscribe($$self, layers, (value) => $$invalidate(3, $layers = value));
  const { invalidate } = useThrelte();
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<LayerableObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LayerableObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
  };
  $$self.$capture_state = () => ({
    getContext,
    useThrelte,
    createObjectStore,
    object,
    objectStore,
    layers,
    invalidate,
    $layers,
    $objectStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*object*/
    4) {
      $:
        objectStore.set(object);
    }
    if ($$self.$$.dirty & /*$layers, $objectStore*/
    24) {
      $: {
        if ($layers === "all") {
          $objectStore.layers.enableAll();
        } else if ($layers === "none") {
          $objectStore.layers.disableAll();
        } else if (Array.isArray($layers)) {
          for (let index = 0; index < 32; index += 1) {
            const layerIndex = index;
            const enabled = $layers.includes(layerIndex);
            if (enabled) {
              $objectStore.layers.enable(index);
            } else {
              $objectStore.layers.disable(index);
            }
          }
        } else if ($layers !== void 0) {
          $objectStore.layers.set($layers);
        }
        invalidate("LayerableObject");
      }
    }
  };
  return [objectStore, layers, object, $layers, $objectStore];
}
var LayerableObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { object: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LayerableObject",
      options,
      id: create_fragment5.name
    });
  }
  get object() {
    throw new Error("<LayerableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<LayerableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LayerableObject_default = LayerableObject;

// node_modules/@threlte/core/dist/hooks/useFrame.js
var useFrame = (fn, options) => {
  if (!browser) {
    return {
      start: () => void 0,
      stop: () => void 0,
      started: readable(false)
    };
  }
  const renderCtx = getContext("threlte-render-context");
  const handler = {
    fn,
    order: options == null ? void 0 : options.order,
    debugFrameloopMessage: options == null ? void 0 : options.debugFrameloopMessage
  };
  const started = writable(false);
  const stop = () => {
    renderCtx.frameHandlers.delete(handler);
    started.set(false);
  };
  const start = () => {
    renderCtx.frameHandlers.add(handler);
    started.set(true);
  };
  if ((options == null ? void 0 : options.autostart) ?? true) {
    start();
  }
  onDestroy(() => {
    stop();
  });
  return {
    start,
    stop,
    started: {
      subscribe: started.subscribe
    }
  };
};

// node_modules/@threlte/core/dist/lib/useTicked.js
var useTicked = () => {
  const ticked = writable(false);
  const init2 = async () => {
    await tick();
    ticked.set(true);
  };
  init2();
  return ticked;
};

// node_modules/@threlte/core/dist/internal/TransformableObject.svelte
function create_fragment6(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $objectStore;
  let $ticked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransformableObject", slots, []);
  let { object } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  const targetWorldPos = new Vector3();
  const dispatch = createEventDispatcher();
  const { invalidate } = useThrelte();
  const ticked = useTicked();
  validate_store(ticked, "ticked");
  component_subscribe($$self, ticked, (value) => $$invalidate(8, $ticked = value));
  const dispatchTransform = async () => {
    if (!$ticked)
      await tick();
    dispatch("transform");
  };
  const onTransform = async () => {
    invalidate("TransformableObject: transformed");
    await dispatchTransform();
  };
  getThrelteUserData(object).onTransform = onTransform;
  const { start: startLookingAt, stop: stopLookingAt } = useFrame(
    async () => {
      if (lookAt && !rotation && lookAt instanceof Object3D) {
        lookAt.getWorldPosition(targetWorldPos);
        object.lookAt(targetWorldPos);
        await dispatchTransform();
      }
    },
    {
      autostart: false,
      debugFrameloopMessage: "TransformableObject: tracking object"
    }
  );
  const objectStore = createObjectStore(object);
  validate_store(objectStore, "objectStore");
  component_subscribe($$self, objectStore, (value) => $$invalidate(7, $objectStore = value));
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<TransformableObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object", "position", "scale", "rotation", "lookAt"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TransformableObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("position" in $$props2)
      $$invalidate(3, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(4, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(5, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(6, lookAt = $$props2.lookAt);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    tick,
    Object3D,
    Vector3,
    useFrame,
    useThrelte,
    createObjectStore,
    getThrelteUserData,
    useTicked,
    object,
    position,
    scale,
    rotation,
    lookAt,
    targetWorldPos,
    dispatch,
    invalidate,
    ticked,
    dispatchTransform,
    onTransform,
    startLookingAt,
    stopLookingAt,
    objectStore,
    $objectStore,
    $ticked
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("position" in $$props2)
      $$invalidate(3, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(4, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(5, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(6, lookAt = $$props2.lookAt);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*object*/
    4) {
      $:
        objectStore.set(object);
    }
    if ($$self.$$.dirty & /*position, $objectStore, lookAt, rotation*/
    232) {
      $: {
        if (position) {
          $objectStore.position.set(position.x ?? 0, position.y ?? 0, position.z ?? 0);
          onTransform();
        }
        if (lookAt && !rotation) {
          if (lookAt instanceof Object3D) {
            startLookingAt();
          } else {
            stopLookingAt();
            $objectStore.lookAt(lookAt.x ?? 0, lookAt.y ?? 0, lookAt.z ?? 0);
            onTransform();
          }
        }
        if (!lookAt) {
          stopLookingAt();
        }
      }
    }
    if ($$self.$$.dirty & /*scale, $objectStore*/
    144) {
      $: {
        if (scale) {
          if (typeof scale === "number") {
            $objectStore.scale.set(scale, scale, scale);
          } else {
            $objectStore.scale.set(scale.x ?? 1, scale.y ?? 1, scale.z ?? 1);
          }
          onTransform();
        }
      }
    }
    if ($$self.$$.dirty & /*rotation, $objectStore*/
    160) {
      $: {
        if (rotation) {
          $objectStore.rotation.set(rotation.x ?? 0, rotation.y ?? 0, rotation.z ?? 0, rotation.order ?? "XYZ");
          onTransform();
        }
      }
    }
  };
  return [ticked, objectStore, object, position, scale, rotation, lookAt, $objectStore];
}
var TransformableObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      object: 2,
      position: 3,
      scale: 4,
      rotation: 5,
      lookAt: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransformableObject",
      options,
      id: create_fragment6.name
    });
  }
  get object() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransformableObject_default = TransformableObject;

// node_modules/@threlte/core/dist/internal/ViewportAwareObject.svelte
function create_fragment7(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $started;
  let $ticked;
  let $camera;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ViewportAwareObject", slots, []);
  let { object } = $$props;
  let { viewportAware = false } = $$props;
  const dispatch = createEventDispatcher();
  const { camera, invalidate } = useThrelte();
  validate_store(camera, "camera");
  component_subscribe($$self, camera, (value) => $$invalidate(8, $camera = value));
  const frustum = new Frustum();
  const projScreenMatrix = new Matrix4();
  const objectIsMesh = (objOrMesh) => {
    return objOrMesh.type === "Mesh";
  };
  const v3World = new Vector3();
  const checkInViewport = () => {
    if (!$camera)
      return true;
    projScreenMatrix.multiplyMatrices($camera.projectionMatrix, $camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
    if (objectIsMesh(object)) {
      return frustum.intersectsObject(object);
    } else {
      object.getWorldPosition(v3World);
      return frustum.containsPoint(v3World);
    }
  };
  const ticked = useTicked();
  validate_store(ticked, "ticked");
  component_subscribe($$self, ticked, (value) => $$invalidate(7, $ticked = value));
  let { inViewport = checkInViewport() } = $$props;
  const dispatchEvent = async (isInViewport) => {
    if (isInViewport) {
      if (!$ticked)
        await tick();
      dispatch("viewportenter", object);
    } else {
      if (!$ticked)
        await tick();
      dispatch("viewportleave", object);
    }
  };
  const { start, stop, started } = useFrame(
    () => {
      const v = checkInViewport();
      if (inViewport === void 0) {
        $$invalidate(3, inViewport = checkInViewport());
        dispatchEvent(inViewport);
      } else if (v !== inViewport) {
        dispatchEvent(v);
        $$invalidate(3, inViewport = v);
      }
    },
    {
      autostart: viewportAware,
      debugFrameloopMessage: "ViewportAwareObject: tracking viewport visibility"
    }
  );
  validate_store(started, "started");
  component_subscribe($$self, started, (value) => $$invalidate(6, $started = value));
  invalidate("ViewportAwareObject");
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<ViewportAwareObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object", "viewportAware", "inViewport"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ViewportAwareObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(4, object = $$props2.object);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(3, inViewport = $$props2.inViewport);
  };
  $$self.$capture_state = () => ({
    useTicked,
    createEventDispatcher,
    tick,
    Frustum,
    Matrix4,
    Mesh,
    Object3D,
    Vector3,
    useFrame,
    useThrelte,
    object,
    viewportAware,
    dispatch,
    camera,
    invalidate,
    frustum,
    projScreenMatrix,
    objectIsMesh,
    v3World,
    checkInViewport,
    ticked,
    inViewport,
    dispatchEvent,
    start,
    stop,
    started,
    $started,
    $ticked,
    $camera
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(4, object = $$props2.object);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(3, inViewport = $$props2.inViewport);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*viewportAware, $started*/
    96) {
      $:
        if (viewportAware && !$started) {
          start();
        } else if (!viewportAware && $started) {
          stop();
        }
    }
  };
  return [camera, ticked, started, inViewport, object, viewportAware, $started];
}
var ViewportAwareObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      object: 4,
      viewportAware: 5,
      inViewport: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ViewportAwareObject",
      options,
      id: create_fragment7.name
    });
  }
  get object() {
    throw new Error("<ViewportAwareObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<ViewportAwareObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<ViewportAwareObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<ViewportAwareObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<ViewportAwareObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<ViewportAwareObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ViewportAwareObject_default = ViewportAwareObject;

// node_modules/@threlte/core/dist/instances/Object3DInstance.svelte
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(49:2) <SceneGraphObject {object}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let scenegraphobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*object*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const scenegraphobject_changes = {};
      if (dirty & /*object*/
      2)
        scenegraphobject_changes.object = /*object*/
        ctx2[1];
      if (dirty & /*$$scope*/
      262144) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(48:0) <DisposableObject {object} {dispose}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let layerableobject;
  let t0;
  let transformableobject;
  let t1;
  let disposableobject;
  let t2;
  let viewportawareobject;
  let updating_inViewport;
  let current;
  layerableobject = new LayerableObject_default({
    props: { object: (
      /*object*/
      ctx[1]
    ) },
    $$inline: true
  });
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*object*/
        ctx[1]
      ),
      position: (
        /*position*/
        ctx[2]
      ),
      rotation: (
        /*rotation*/
        ctx[4]
      ),
      scale: (
        /*scale*/
        ctx[3]
      ),
      lookAt: (
        /*lookAt*/
        ctx[5]
      )
    },
    $$inline: true
  });
  disposableobject = new DisposableObject_default({
    props: {
      object: (
        /*object*/
        ctx[1]
      ),
      dispose: (
        /*dispose*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function viewportawareobject_inViewport_binding(value) {
    ctx[15](value);
  }
  let viewportawareobject_props = {
    object: (
      /*object*/
      ctx[1]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    )
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    viewportawareobject_props.inViewport = /*inViewport*/
    ctx[0];
  }
  viewportawareobject = new ViewportAwareObject_default({
    props: viewportawareobject_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(viewportawareobject, "inViewport", viewportawareobject_inViewport_binding));
  viewportawareobject.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[16]
  );
  viewportawareobject.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[17]
  );
  const block = {
    c: function create() {
      create_component(layerableobject.$$.fragment);
      t0 = space();
      create_component(transformableobject.$$.fragment);
      t1 = space();
      create_component(disposableobject.$$.fragment);
      t2 = space();
      create_component(viewportawareobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(layerableobject.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(transformableobject.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(disposableobject.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(viewportawareobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(layerableobject, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(transformableobject, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(disposableobject, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(viewportawareobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const layerableobject_changes = {};
      if (dirty & /*object*/
      2)
        layerableobject_changes.object = /*object*/
        ctx2[1];
      layerableobject.$set(layerableobject_changes);
      const transformableobject_changes = {};
      if (dirty & /*object*/
      2)
        transformableobject_changes.object = /*object*/
        ctx2[1];
      if (dirty & /*position*/
      4)
        transformableobject_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*rotation*/
      16)
        transformableobject_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*scale*/
      8)
        transformableobject_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*lookAt*/
      32)
        transformableobject_changes.lookAt = /*lookAt*/
        ctx2[5];
      transformableobject.$set(transformableobject_changes);
      const disposableobject_changes = {};
      if (dirty & /*object*/
      2)
        disposableobject_changes.object = /*object*/
        ctx2[1];
      if (dirty & /*dispose*/
      128)
        disposableobject_changes.dispose = /*dispose*/
        ctx2[7];
      if (dirty & /*$$scope, object*/
      262146) {
        disposableobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      disposableobject.$set(disposableobject_changes);
      const viewportawareobject_changes = {};
      if (dirty & /*object*/
      2)
        viewportawareobject_changes.object = /*object*/
        ctx2[1];
      if (dirty & /*viewportAware*/
      64)
        viewportawareobject_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        viewportawareobject_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      viewportawareobject.$set(viewportawareobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layerableobject.$$.fragment, local);
      transition_in(transformableobject.$$.fragment, local);
      transition_in(disposableobject.$$.fragment, local);
      transition_in(viewportawareobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layerableobject.$$.fragment, local);
      transition_out(transformableobject.$$.fragment, local);
      transition_out(disposableobject.$$.fragment, local);
      transition_out(viewportawareobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layerableobject, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(transformableobject, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(disposableobject, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(viewportawareobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Object3DInstance", slots, ["default"]);
  let { object } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  const { invalidate } = useThrelte();
  const getObject = () => object;
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<Object3DInstance> was created without expected prop 'object'");
    }
  });
  const writable_props = [
    "object",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "dispose",
    "userData"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Object3DInstance> was created with unknown prop '${key}'`);
  });
  function viewportawareobject_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(1, object = $$props2.object);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(8, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(9, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(10, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(11, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(12, visible = $$props2.visible);
    if ("dispose" in $$props2)
      $$invalidate(7, dispose = $$props2.dispose);
    if ("userData" in $$props2)
      $$invalidate(13, userData = $$props2.userData);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useThrelte,
    DisposableObject: DisposableObject_default,
    LayerableObject: LayerableObject_default,
    SceneGraphObject: SceneGraphObject_default,
    TransformableObject: TransformableObject_default,
    ViewportAwareObject: ViewportAwareObject_default,
    object,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    dispose,
    userData,
    invalidate,
    getObject
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(1, object = $$props2.object);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(8, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(9, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(10, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(11, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(12, visible = $$props2.visible);
    if ("dispose" in $$props2)
      $$invalidate(7, dispose = $$props2.dispose);
    if ("userData" in $$props2)
      $$invalidate(13, userData = $$props2.userData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*visible, castShadow, receiveShadow, frustumCulled, renderOrder, userData*/
    16128) {
      $: {
        if (visible !== void 0)
          getObject().visible = visible;
        if (castShadow !== void 0)
          getObject().castShadow = castShadow;
        if (receiveShadow !== void 0)
          getObject().receiveShadow = receiveShadow;
        if (frustumCulled !== void 0)
          getObject().frustumCulled = frustumCulled;
        if (renderOrder !== void 0)
          getObject().renderOrder = renderOrder;
        if (userData !== void 0) {
          getObject().userData = { ...getObject().userData, ...userData };
        }
        invalidate("Object3DInstance: props changed");
      }
    }
  };
  return [
    inViewport,
    object,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    dispose,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    slots,
    viewportawareobject_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Object3DInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      object: 1,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 0,
      castShadow: 8,
      receiveShadow: 9,
      frustumCulled: 10,
      renderOrder: 11,
      visible: 12,
      dispose: 7,
      userData: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Object3DInstance",
      options,
      id: create_fragment8.name
    });
  }
  get object() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Object3DInstance_default = Object3DInstance;

// node_modules/@threlte/core/dist/instances/CameraInstance.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(27:0) <Object3DInstance   object={camera}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {position}   {scale}   {rotation}   {viewportAware}   {visible}   {userData}   {dispose}   on:viewportenter   on:viewportleave   bind:inViewport >",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[18](value);
  }
  let object3dinstance_props = {
    object: (
      /*camera*/
      ctx[1]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    userData: (
      /*userData*/
      ctx[12]
    ),
    dispose: (
      /*dispose*/
      ctx[13]
    ),
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[19]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[20]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*camera*/
      2)
        object3dinstance_changes.object = /*camera*/
        ctx2[1];
      if (dirty & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*userData*/
      4096)
        object3dinstance_changes.userData = /*userData*/
        ctx2[12];
      if (dirty & /*dispose*/
      8192)
        object3dinstance_changes.dispose = /*dispose*/
        ctx2[13];
      if (dirty & /*$$scope*/
      2097152) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let $cam;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CameraInstance", slots, ["default"]);
  let { camera } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { useCamera: useCamera2 = false } = $$props;
  const cam = createObjectStore(camera);
  validate_store(cam, "cam");
  component_subscribe($$self, cam, (value) => $$invalidate(16, $cam = value));
  const { setCamera } = useThrelteRoot();
  $$self.$$.on_mount.push(function() {
    if (camera === void 0 && !("camera" in $$props || $$self.$$.bound[$$self.$$.props["camera"]])) {
      console.warn("<CameraInstance> was created without expected prop 'camera'");
    }
  });
  const writable_props = [
    "camera",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "useCamera"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CameraInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("camera" in $$props2)
      $$invalidate(1, camera = $$props2.camera);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("useCamera" in $$props2)
      $$invalidate(15, useCamera2 = $$props2.useCamera);
    if ("$$scope" in $$props2)
      $$invalidate(21, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useThrelteRoot,
    createObjectStore,
    Object3DInstance: Object3DInstance_default,
    camera,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    useCamera: useCamera2,
    cam,
    setCamera,
    $cam
  });
  $$self.$inject_state = ($$props2) => {
    if ("camera" in $$props2)
      $$invalidate(1, camera = $$props2.camera);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("useCamera" in $$props2)
      $$invalidate(15, useCamera2 = $$props2.useCamera);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*camera*/
    2) {
      $:
        cam.set(camera);
    }
    if ($$self.$$.dirty & /*useCamera, $cam*/
    98304) {
      $:
        if (useCamera2) {
          setCamera($cam);
        }
    }
  };
  return [
    inViewport,
    camera,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    cam,
    useCamera2,
    $cam,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var CameraInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      camera: 1,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 0,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      userData: 12,
      dispose: 13,
      useCamera: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CameraInstance",
      options,
      id: create_fragment9.name
    });
  }
  get camera() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set camera(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useCamera() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useCamera(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CameraInstance_default = CameraInstance;

// node_modules/@threlte/core/dist/cameras/OrthographicCamera.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(49:0) <CameraInstance   {camera}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {lookAt}   {useCamera} >",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let camerainstance;
  let updating_inViewport;
  let current;
  function camerainstance_inViewport_binding(value) {
    ctx[25](value);
  }
  let camerainstance_props = {
    camera: (
      /*camera*/
      ctx[0]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    userData: (
      /*userData*/
      ctx[12]
    ),
    dispose: (
      /*dispose*/
      ctx[13]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    useCamera: (
      /*useCamera*/
      ctx[14]
    ),
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    camerainstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  camerainstance = new CameraInstance_default({
    props: camerainstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(camerainstance, "inViewport", camerainstance_inViewport_binding));
  camerainstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[26]
  );
  camerainstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[27]
  );
  const block = {
    c: function create() {
      create_component(camerainstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(camerainstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(camerainstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const camerainstance_changes = {};
      if (dirty & /*camera*/
      1)
        camerainstance_changes.camera = /*camera*/
        ctx2[0];
      if (dirty & /*position*/
      4)
        camerainstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        camerainstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        camerainstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      128)
        camerainstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        camerainstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        camerainstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        camerainstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*visible*/
      2048)
        camerainstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*userData*/
      4096)
        camerainstance_changes.userData = /*userData*/
        ctx2[12];
      if (dirty & /*dispose*/
      8192)
        camerainstance_changes.dispose = /*dispose*/
        ctx2[13];
      if (dirty & /*viewportAware*/
      64)
        camerainstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*lookAt*/
      32)
        camerainstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*useCamera*/
      16384)
        camerainstance_changes.useCamera = /*useCamera*/
        ctx2[14];
      if (dirty & /*$$scope*/
      268435456) {
        camerainstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      2) {
        updating_inViewport = true;
        camerainstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      camerainstance.$set(camerainstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(camerainstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(camerainstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(camerainstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let $size;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OrthographicCamera", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { useCamera: useCamera2 = true } = $$props;
  let { near = void 0 } = $$props;
  let { far = void 0 } = $$props;
  let { left = void 0 } = $$props;
  let { right = void 0 } = $$props;
  let { top = void 0 } = $$props;
  let { bottom = void 0 } = $$props;
  let { zoom = void 0 } = $$props;
  const { size, invalidate } = useThrelte();
  validate_store(size, "size");
  component_subscribe($$self, size, (value) => $$invalidate(23, $size = value));
  const { setCamera } = useThrelteRoot();
  const camera = new OrthographicCamera(left ?? $size.width / -2, right ?? $size.width / 2, top ?? $size.height / 2, bottom ?? $size.height / -2, near, far);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "useCamera",
    "near",
    "far",
    "left",
    "right",
    "top",
    "bottom",
    "zoom"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<OrthographicCamera> was created with unknown prop '${key}'`);
  });
  function camerainstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("useCamera" in $$props2)
      $$invalidate(14, useCamera2 = $$props2.useCamera);
    if ("near" in $$props2)
      $$invalidate(16, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(17, far = $$props2.far);
    if ("left" in $$props2)
      $$invalidate(18, left = $$props2.left);
    if ("right" in $$props2)
      $$invalidate(19, right = $$props2.right);
    if ("top" in $$props2)
      $$invalidate(20, top = $$props2.top);
    if ("bottom" in $$props2)
      $$invalidate(21, bottom = $$props2.bottom);
    if ("zoom" in $$props2)
      $$invalidate(22, zoom = $$props2.zoom);
    if ("$$scope" in $$props2)
      $$invalidate(28, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeOrthographicCamera: OrthographicCamera,
    useThrelte,
    useThrelteRoot,
    CameraInstance: CameraInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    useCamera: useCamera2,
    near,
    far,
    left,
    right,
    top,
    bottom,
    zoom,
    size,
    invalidate,
    setCamera,
    camera,
    $size
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("useCamera" in $$props2)
      $$invalidate(14, useCamera2 = $$props2.useCamera);
    if ("near" in $$props2)
      $$invalidate(16, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(17, far = $$props2.far);
    if ("left" in $$props2)
      $$invalidate(18, left = $$props2.left);
    if ("right" in $$props2)
      $$invalidate(19, right = $$props2.right);
    if ("top" in $$props2)
      $$invalidate(20, top = $$props2.top);
    if ("bottom" in $$props2)
      $$invalidate(21, bottom = $$props2.bottom);
    if ("zoom" in $$props2)
      $$invalidate(22, zoom = $$props2.zoom);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*left, $size, right, top, bottom, near, far, zoom, camera*/
    16711681) {
      $: {
        $$invalidate(0, camera.left = left ?? $size.width / -2, camera);
        $$invalidate(0, camera.right = right ?? $size.width / 2, camera);
        $$invalidate(0, camera.top = top ?? $size.height / 2, camera);
        $$invalidate(0, camera.bottom = bottom ?? $size.height / -2, camera);
        if (near !== void 0)
          $$invalidate(0, camera.near = near, camera);
        if (far !== void 0)
          $$invalidate(0, camera.far = far, camera);
        if (zoom !== void 0)
          $$invalidate(0, camera.zoom = zoom, camera);
        camera.updateProjectionMatrix();
        invalidate("OrthographicCamera: frustum changed");
      }
    }
    if ($$self.$$.dirty & /*useCamera, camera*/
    16385) {
      $:
        if (useCamera2)
          setCamera(camera);
    }
  };
  return [
    camera,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    useCamera2,
    size,
    near,
    far,
    left,
    right,
    top,
    bottom,
    zoom,
    $size,
    slots,
    camerainstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var OrthographicCamera2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 1,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      userData: 12,
      dispose: 13,
      useCamera: 14,
      near: 16,
      far: 17,
      left: 18,
      right: 19,
      top: 20,
      bottom: 21,
      zoom: 22,
      camera: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OrthographicCamera",
      options,
      id: create_fragment10.name
    });
  }
  get position() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useCamera() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useCamera(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get near() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set near(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get far() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set far(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get left() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get right() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set right(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottom() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottom(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoom() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoom(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get camera() {
    return this.$$.ctx[0];
  }
  set camera(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OrthographicCamera_default = OrthographicCamera2;

// node_modules/@threlte/core/dist/cameras/PerspectiveCamera.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[24],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(42:0) <CameraInstance   {camera}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {lookAt}   {useCamera} >",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let camerainstance;
  let updating_inViewport;
  let current;
  function camerainstance_inViewport_binding(value) {
    ctx[21](value);
  }
  let camerainstance_props = {
    camera: (
      /*camera*/
      ctx[0]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    userData: (
      /*userData*/
      ctx[11]
    ),
    dispose: (
      /*dispose*/
      ctx[12]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[13]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    useCamera: (
      /*useCamera*/
      ctx[14]
    ),
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    camerainstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  camerainstance = new CameraInstance_default({
    props: camerainstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(camerainstance, "inViewport", camerainstance_inViewport_binding));
  camerainstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[22]
  );
  camerainstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[23]
  );
  const block = {
    c: function create() {
      create_component(camerainstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(camerainstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(camerainstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const camerainstance_changes = {};
      if (dirty & /*camera*/
      1)
        camerainstance_changes.camera = /*camera*/
        ctx2[0];
      if (dirty & /*position*/
      4)
        camerainstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        camerainstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        camerainstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      64)
        camerainstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        camerainstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*frustumCulled*/
      256)
        camerainstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        camerainstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        camerainstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*userData*/
      2048)
        camerainstance_changes.userData = /*userData*/
        ctx2[11];
      if (dirty & /*dispose*/
      4096)
        camerainstance_changes.dispose = /*dispose*/
        ctx2[12];
      if (dirty & /*viewportAware*/
      8192)
        camerainstance_changes.viewportAware = /*viewportAware*/
        ctx2[13];
      if (dirty & /*lookAt*/
      32)
        camerainstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*useCamera*/
      16384)
        camerainstance_changes.useCamera = /*useCamera*/
        ctx2[14];
      if (dirty & /*$$scope*/
      16777216) {
        camerainstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      2) {
        updating_inViewport = true;
        camerainstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      camerainstance.$set(camerainstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(camerainstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(camerainstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(camerainstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let $size;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PerspectiveCamera", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { useCamera: useCamera2 = true } = $$props;
  let { near = void 0 } = $$props;
  let { far = void 0 } = $$props;
  let { fov = void 0 } = $$props;
  const { size, invalidate } = useThrelte();
  validate_store(size, "size");
  component_subscribe($$self, size, (value) => $$invalidate(19, $size = value));
  const camera = new PerspectiveCamera(fov, $size.width / $size.height, near, far);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "viewportAware",
    "inViewport",
    "useCamera",
    "near",
    "far",
    "fov"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PerspectiveCamera> was created with unknown prop '${key}'`);
  });
  function camerainstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("viewportAware" in $$props2)
      $$invalidate(13, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("useCamera" in $$props2)
      $$invalidate(14, useCamera2 = $$props2.useCamera);
    if ("near" in $$props2)
      $$invalidate(16, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(17, far = $$props2.far);
    if ("fov" in $$props2)
      $$invalidate(18, fov = $$props2.fov);
    if ("$$scope" in $$props2)
      $$invalidate(24, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreePerspectiveCamera: PerspectiveCamera,
    useThrelte,
    CameraInstance: CameraInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    viewportAware,
    inViewport,
    useCamera: useCamera2,
    near,
    far,
    fov,
    size,
    invalidate,
    camera,
    $size
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("viewportAware" in $$props2)
      $$invalidate(13, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("useCamera" in $$props2)
      $$invalidate(14, useCamera2 = $$props2.useCamera);
    if ("near" in $$props2)
      $$invalidate(16, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(17, far = $$props2.far);
    if ("fov" in $$props2)
      $$invalidate(18, fov = $$props2.fov);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$size, camera*/
    524289) {
      $: {
        $$invalidate(0, camera.aspect = $size.width / $size.height, camera);
        camera.updateProjectionMatrix();
        invalidate("PerspectiveCamera: aspect changed");
      }
    }
    if ($$self.$$.dirty & /*near, far, fov, camera*/
    458753) {
      $: {
        if (near !== void 0)
          $$invalidate(0, camera.near = near, camera);
        if (far !== void 0)
          $$invalidate(0, camera.far = far, camera);
        if (fov !== void 0)
          $$invalidate(0, camera.fov = fov, camera);
        camera.updateProjectionMatrix();
        invalidate("PerspectiveCamera: props changed");
      }
    }
  };
  return [
    camera,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    viewportAware,
    useCamera2,
    size,
    near,
    far,
    fov,
    $size,
    slots,
    camerainstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var PerspectiveCamera2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      castShadow: 6,
      receiveShadow: 7,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      userData: 11,
      dispose: 12,
      viewportAware: 13,
      inViewport: 1,
      useCamera: 14,
      near: 16,
      far: 17,
      fov: 18,
      camera: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PerspectiveCamera",
      options,
      id: create_fragment11.name
    });
  }
  get position() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useCamera() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useCamera(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get near() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set near(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get far() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set far(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fov() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fov(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get camera() {
    return this.$$.ctx[0];
  }
  set camera(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PerspectiveCamera_default = PerspectiveCamera2;

// node_modules/@threlte/core/dist/hooks/useThrelteAudio.js
var useThrelteAudio = () => {
  return getContext("threlte-audio-context");
};

// node_modules/@threlte/core/dist/audio/AudioListener.svelte
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(32:0) <Object3DInstance   object={listener}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {castShadow}   {receiveShadow}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[19](value);
  }
  let object3dinstance_props = {
    object: (
      /*listener*/
      ctx[13]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[4]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    userData: (
      /*userData*/
      ctx[11]
    ),
    dispose: (
      /*dispose*/
      ctx[12]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[20]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*position*/
      2)
        object3dinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty & /*scale*/
      4)
        object3dinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty & /*rotation*/
      8)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty & /*lookAt*/
      16)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[4];
      if (dirty & /*frustumCulled*/
      256)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        object3dinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*userData*/
      2048)
        object3dinstance_changes.userData = /*userData*/
        ctx2[11];
      if (dirty & /*dispose*/
      4096)
        object3dinstance_changes.dispose = /*dispose*/
        ctx2[12];
      if (dirty & /*castShadow*/
      64)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*viewportAware*/
      32)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty & /*$$scope*/
      4194304) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AudioListener", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { masterVolume = void 0 } = $$props;
  const listener = new AudioListener();
  const context = listener.context;
  const resumeContext = async () => await listener.context.resume();
  const { addAudioListener, removeAudioListener } = useThrelteAudio();
  addAudioListener(listener, id);
  onDestroy(() => {
    removeAudioListener(id);
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "id",
    "masterVolume"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AudioListener> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("id" in $$props2)
      $$invalidate(14, id = $$props2.id);
    if ("masterVolume" in $$props2)
      $$invalidate(15, masterVolume = $$props2.masterVolume);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    ThreeAudioListener: AudioListener,
    useThrelteAudio,
    Object3DInstance: Object3DInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    id,
    masterVolume,
    listener,
    context,
    resumeContext,
    addAudioListener,
    removeAudioListener
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("id" in $$props2)
      $$invalidate(14, id = $$props2.id);
    if ("masterVolume" in $$props2)
      $$invalidate(15, masterVolume = $$props2.masterVolume);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*masterVolume*/
    32768) {
      $:
        if (masterVolume !== void 0)
          listener.setMasterVolume(masterVolume);
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    listener,
    id,
    masterVolume,
    context,
    resumeContext,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var AudioListener2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      position: 1,
      scale: 2,
      rotation: 3,
      lookAt: 4,
      viewportAware: 5,
      inViewport: 0,
      castShadow: 6,
      receiveShadow: 7,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      userData: 11,
      dispose: 12,
      id: 14,
      masterVolume: 15,
      listener: 13,
      context: 16,
      resumeContext: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AudioListener",
      options,
      id: create_fragment12.name
    });
  }
  get position() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get masterVolume() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set masterVolume(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listener() {
    return this.$$.ctx[13];
  }
  set listener(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    return this.$$.ctx[16];
  }
  set context(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resumeContext() {
    return this.$$.ctx[17];
  }
  set resumeContext(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AudioListener_default = AudioListener2;

// node_modules/@threlte/core/dist/hooks/useLoader.js
var loaders = [];
var useLoader = (loader2, memoizeFn) => {
  const maybeLoader = loaders.find((ll) => ll instanceof loader2);
  if (maybeLoader)
    return maybeLoader;
  const newLoader = memoizeFn();
  loaders.push(newLoader);
  return newLoader;
};

// node_modules/@threlte/core/dist/instances/AudioInstance.svelte
var { console: console_1 } = globals;
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(149:0) <Object3DInstance   object={audio}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {castShadow}   {receiveShadow}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[26](value);
  }
  let object3dinstance_props = {
    object: (
      /*audio*/
      ctx[0]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    userData: (
      /*userData*/
      ctx[12]
    ),
    dispose: (
      /*dispose*/
      ctx[13]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[27]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[28]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const object3dinstance_changes = {};
      if (dirty[0] & /*audio*/
      1)
        object3dinstance_changes.object = /*audio*/
        ctx2[0];
      if (dirty[0] & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty[0] & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty[0] & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty[0] & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty[0] & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty[0] & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty[0] & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty[0] & /*userData*/
      4096)
        object3dinstance_changes.userData = /*userData*/
        ctx2[12];
      if (dirty[0] & /*dispose*/
      8192)
        object3dinstance_changes.dispose = /*dispose*/
        ctx2[13];
      if (dirty[0] & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty[0] & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty[0] & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty[0] & /*$$scope*/
      536870912) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      2) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AudioInstance", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { source = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { filters = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { audio } = $$props;
  const play = async (delay) => {
    if (audio.context.state !== "running") {
      await audio.context.resume();
    }
    delay && typeof delay === "number" ? audio.play(delay) : audio.play();
    setDetune(detune);
    return audio;
  };
  const pause = () => audio.pause();
  const stop = () => {
    if (!audio.source)
      return audio;
    return audio.stop();
  };
  const setDetune = (detune2) => {
    if (detune2 !== void 0 && audio.source && audio.source.detune) {
      audio.setDetune(detune2);
    }
  };
  const dispatch = createEventDispatcher();
  const loader2 = useLoader(AudioLoader, () => new AudioLoader(DefaultLoadingManager));
  const loadBufferFromUrl = (url) => {
    return new Promise((resolve2, reject) => {
      loader2.load(
        url,
        (buffer) => {
          dispatch("load", buffer);
          resolve2(buffer);
        },
        (e) => {
          dispatch("progress", e);
        },
        (e) => {
          dispatch("error", e);
          reject(e);
        }
      );
    });
  };
  let previousSource;
  const onSourceChange = async (newSource, signal) => {
    if (!newSource) {
      previousSource = newSource;
      stop();
      return;
    }
    if (!newSource || newSource === previousSource) {
      stop();
      return;
    }
    previousSource = newSource;
    let aborted = false;
    const onAbort = () => {
      aborted = true;
    };
    signal.addEventListener("abort", onAbort, { once: true });
    if (typeof newSource === "string") {
      const buffer = await loadBufferFromUrl(newSource);
      if (aborted)
        return;
      stop();
      audio.setBuffer(buffer);
    } else if (newSource instanceof AudioBuffer) {
      if (aborted)
        return;
      stop();
      audio.setBuffer(newSource);
    } else if (newSource instanceof HTMLMediaElement) {
      if (aborted)
        return;
      stop();
      audio.setMediaElementSource(newSource);
    } else if (newSource instanceof MediaStream) {
      if (aborted)
        return;
      stop();
      audio.setMediaStreamSource(newSource);
    } else if (newSource instanceof AudioBufferSourceNode) {
      if (aborted)
        return;
      stop();
      audio.setNodeSource(newSource);
    }
    signal.removeEventListener("abort", onAbort);
  };
  let ac;
  onDestroy(() => {
    try {
      stop();
      if (ac)
        ac.abort;
      if (audio.source)
        audio.disconnect();
    } catch (error) {
      console.warn("Error unmounting <AudioInstance>");
      console.error(error);
    }
  });
  $$self.$$.on_mount.push(function() {
    if (audio === void 0 && !("audio" in $$props || $$self.$$.bound[$$self.$$.props["audio"]])) {
      console_1.warn("<AudioInstance> was created without expected prop 'audio'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "autoplay",
    "detune",
    "source",
    "volume",
    "loop",
    "filters",
    "playbackRate",
    "audio"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<AudioInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("autoplay" in $$props2)
      $$invalidate(14, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(15, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(16, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(17, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(18, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(19, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(20, playbackRate = $$props2.playbackRate);
    if ("audio" in $$props2)
      $$invalidate(0, audio = $$props2.audio);
    if ("$$scope" in $$props2)
      $$invalidate(29, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    DefaultLoadingManager,
    Audio,
    AudioLoader,
    PositionalAudio,
    useLoader,
    Object3DInstance: Object3DInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    audio,
    play,
    pause,
    stop,
    setDetune,
    dispatch,
    loader: loader2,
    loadBufferFromUrl,
    previousSource,
    onSourceChange,
    ac
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("autoplay" in $$props2)
      $$invalidate(14, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(15, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(16, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(17, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(18, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(19, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(20, playbackRate = $$props2.playbackRate);
    if ("audio" in $$props2)
      $$invalidate(0, audio = $$props2.audio);
    if ("previousSource" in $$props2)
      previousSource = $$props2.previousSource;
    if ("ac" in $$props2)
      $$invalidate(24, ac = $$props2.ac);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*autoplay*/
    16384) {
      $:
        if (autoplay !== void 0)
          $$invalidate(0, audio.autoplay = autoplay, audio);
    }
    if ($$self.$$.dirty[0] & /*detune*/
    32768) {
      $:
        setDetune(detune);
    }
    if ($$self.$$.dirty[0] & /*volume, audio*/
    131073) {
      $:
        if (volume !== void 0)
          audio.setVolume(volume);
    }
    if ($$self.$$.dirty[0] & /*loop, audio*/
    262145) {
      $:
        if (loop !== void 0)
          audio.setLoop(loop);
    }
    if ($$self.$$.dirty[0] & /*filters, audio*/
    524289) {
      $:
        if (filters !== void 0)
          Array.isArray(filters) ? audio.setFilters(filters) : audio.setFilter(filters);
    }
    if ($$self.$$.dirty[0] & /*playbackRate, audio*/
    1048577) {
      $:
        if (playbackRate !== void 0)
          audio.setPlaybackRate(playbackRate);
    }
    if ($$self.$$.dirty[0] & /*ac, source*/
    16842752) {
      $: {
        if (ac)
          ac.abort();
        $$invalidate(24, ac = new AbortController());
        onSourceChange(source, ac.signal);
      }
    }
  };
  return [
    audio,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    play,
    pause,
    stop,
    ac,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var AudioInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        position: 2,
        scale: 3,
        rotation: 4,
        lookAt: 5,
        viewportAware: 6,
        inViewport: 1,
        castShadow: 7,
        receiveShadow: 8,
        frustumCulled: 9,
        renderOrder: 10,
        visible: 11,
        userData: 12,
        dispose: 13,
        autoplay: 14,
        detune: 15,
        source: 16,
        volume: 17,
        loop: 18,
        filters: 19,
        playbackRate: 20,
        audio: 0,
        play: 21,
        pause: 22,
        stop: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AudioInstance",
      options,
      id: create_fragment13.name
    });
  }
  get position() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filters() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filters(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audio() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set audio(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    return this.$$.ctx[21];
  }
  set play(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    return this.$$.ctx[22];
  }
  set pause(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    return this.$$.ctx[23];
  }
  set stop(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AudioInstance_default = AudioInstance;

// node_modules/@threlte/core/dist/audio/Audio.svelte
var { Error: Error_1 } = globals;
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(36:0) <AudioInstance   {audio}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {castShadow}   {receiveShadow}   {viewportAware}   {autoplay}   {source}   {detune}   {loop}   {filters}   {playbackRate}   {volume}   bind:inViewport   on:viewportenter   on:viewportleave   on:load   on:progress   on:error   bind:play   bind:pause   bind:stop >",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let audioinstance;
  let updating_inViewport;
  let updating_play;
  let updating_pause;
  let updating_stop;
  let current;
  function audioinstance_inViewport_binding(value) {
    ctx[26](value);
  }
  function audioinstance_play_binding(value) {
    ctx[27](value);
  }
  function audioinstance_pause_binding(value) {
    ctx[28](value);
  }
  function audioinstance_stop_binding(value) {
    ctx[29](value);
  }
  let audioinstance_props = {
    audio: (
      /*audio*/
      ctx[23]
    ),
    position: (
      /*position*/
      ctx[4]
    ),
    scale: (
      /*scale*/
      ctx[5]
    ),
    rotation: (
      /*rotation*/
      ctx[6]
    ),
    lookAt: (
      /*lookAt*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[11]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[12]
    ),
    visible: (
      /*visible*/
      ctx[13]
    ),
    userData: (
      /*userData*/
      ctx[14]
    ),
    dispose: (
      /*dispose*/
      ctx[15]
    ),
    castShadow: (
      /*castShadow*/
      ctx[9]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[10]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[8]
    ),
    autoplay: (
      /*autoplay*/
      ctx[16]
    ),
    source: (
      /*source*/
      ctx[18]
    ),
    detune: (
      /*detune*/
      ctx[17]
    ),
    loop: (
      /*loop*/
      ctx[20]
    ),
    filters: (
      /*filters*/
      ctx[21]
    ),
    playbackRate: (
      /*playbackRate*/
      ctx[22]
    ),
    volume: (
      /*volume*/
      ctx[19]
    ),
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    audioinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  if (
    /*play*/
    ctx[1] !== void 0
  ) {
    audioinstance_props.play = /*play*/
    ctx[1];
  }
  if (
    /*pause*/
    ctx[2] !== void 0
  ) {
    audioinstance_props.pause = /*pause*/
    ctx[2];
  }
  if (
    /*stop*/
    ctx[3] !== void 0
  ) {
    audioinstance_props.stop = /*stop*/
    ctx[3];
  }
  audioinstance = new AudioInstance_default({
    props: audioinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(audioinstance, "inViewport", audioinstance_inViewport_binding));
  binding_callbacks.push(() => bind(audioinstance, "play", audioinstance_play_binding));
  binding_callbacks.push(() => bind(audioinstance, "pause", audioinstance_pause_binding));
  binding_callbacks.push(() => bind(audioinstance, "stop", audioinstance_stop_binding));
  audioinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[30]
  );
  audioinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[31]
  );
  audioinstance.$on(
    "load",
    /*load_handler*/
    ctx[32]
  );
  audioinstance.$on(
    "progress",
    /*progress_handler*/
    ctx[33]
  );
  audioinstance.$on(
    "error",
    /*error_handler*/
    ctx[34]
  );
  const block = {
    c: function create() {
      create_component(audioinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(audioinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(audioinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const audioinstance_changes = {};
      if (dirty[0] & /*position*/
      16)
        audioinstance_changes.position = /*position*/
        ctx2[4];
      if (dirty[0] & /*scale*/
      32)
        audioinstance_changes.scale = /*scale*/
        ctx2[5];
      if (dirty[0] & /*rotation*/
      64)
        audioinstance_changes.rotation = /*rotation*/
        ctx2[6];
      if (dirty[0] & /*lookAt*/
      128)
        audioinstance_changes.lookAt = /*lookAt*/
        ctx2[7];
      if (dirty[0] & /*frustumCulled*/
      2048)
        audioinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[11];
      if (dirty[0] & /*renderOrder*/
      4096)
        audioinstance_changes.renderOrder = /*renderOrder*/
        ctx2[12];
      if (dirty[0] & /*visible*/
      8192)
        audioinstance_changes.visible = /*visible*/
        ctx2[13];
      if (dirty[0] & /*userData*/
      16384)
        audioinstance_changes.userData = /*userData*/
        ctx2[14];
      if (dirty[0] & /*dispose*/
      32768)
        audioinstance_changes.dispose = /*dispose*/
        ctx2[15];
      if (dirty[0] & /*castShadow*/
      512)
        audioinstance_changes.castShadow = /*castShadow*/
        ctx2[9];
      if (dirty[0] & /*receiveShadow*/
      1024)
        audioinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[10];
      if (dirty[0] & /*viewportAware*/
      256)
        audioinstance_changes.viewportAware = /*viewportAware*/
        ctx2[8];
      if (dirty[0] & /*autoplay*/
      65536)
        audioinstance_changes.autoplay = /*autoplay*/
        ctx2[16];
      if (dirty[0] & /*source*/
      262144)
        audioinstance_changes.source = /*source*/
        ctx2[18];
      if (dirty[0] & /*detune*/
      131072)
        audioinstance_changes.detune = /*detune*/
        ctx2[17];
      if (dirty[0] & /*loop*/
      1048576)
        audioinstance_changes.loop = /*loop*/
        ctx2[20];
      if (dirty[0] & /*filters*/
      2097152)
        audioinstance_changes.filters = /*filters*/
        ctx2[21];
      if (dirty[0] & /*playbackRate*/
      4194304)
        audioinstance_changes.playbackRate = /*playbackRate*/
        ctx2[22];
      if (dirty[0] & /*volume*/
      524288)
        audioinstance_changes.volume = /*volume*/
        ctx2[19];
      if (dirty[1] & /*$$scope*/
      16) {
        audioinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        audioinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      if (!updating_play && dirty[0] & /*play*/
      2) {
        updating_play = true;
        audioinstance_changes.play = /*play*/
        ctx2[1];
        add_flush_callback(() => updating_play = false);
      }
      if (!updating_pause && dirty[0] & /*pause*/
      4) {
        updating_pause = true;
        audioinstance_changes.pause = /*pause*/
        ctx2[2];
        add_flush_callback(() => updating_pause = false);
      }
      if (!updating_stop && dirty[0] & /*stop*/
      8) {
        updating_stop = true;
        audioinstance_changes.stop = /*stop*/
        ctx2[3];
        add_flush_callback(() => updating_stop = false);
      }
      audioinstance.$set(audioinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(audioinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(audioinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(audioinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Audio", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { source = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { filters = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { play = void 0 } = $$props;
  let { pause = void 0 } = $$props;
  let { stop = void 0 } = $$props;
  let { id = void 0 } = $$props;
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener(id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${id} found.`);
  }
  const audio = new Audio(listener);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "autoplay",
    "detune",
    "source",
    "volume",
    "loop",
    "filters",
    "playbackRate",
    "play",
    "pause",
    "stop",
    "id"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Audio> was created with unknown prop '${key}'`);
  });
  function audioinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function audioinstance_play_binding(value) {
    play = value;
    $$invalidate(1, play);
  }
  function audioinstance_pause_binding(value) {
    pause = value;
    $$invalidate(2, pause);
  }
  function audioinstance_stop_binding(value) {
    stop = value;
    $$invalidate(3, stop);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function progress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function error_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(5, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(6, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(7, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(9, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(10, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(11, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(12, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(13, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(14, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(15, dispose = $$props2.dispose);
    if ("autoplay" in $$props2)
      $$invalidate(16, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(17, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(18, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(19, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(20, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(21, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(22, playbackRate = $$props2.playbackRate);
    if ("play" in $$props2)
      $$invalidate(1, play = $$props2.play);
    if ("pause" in $$props2)
      $$invalidate(2, pause = $$props2.pause);
    if ("stop" in $$props2)
      $$invalidate(3, stop = $$props2.stop);
    if ("id" in $$props2)
      $$invalidate(24, id = $$props2.id);
    if ("$$scope" in $$props2)
      $$invalidate(35, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeAudio: Audio,
    useThrelteAudio,
    AudioInstance: AudioInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    play,
    pause,
    stop,
    id,
    getAudioListener,
    listener,
    audio
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(5, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(6, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(7, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(9, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(10, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(11, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(12, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(13, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(14, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(15, dispose = $$props2.dispose);
    if ("autoplay" in $$props2)
      $$invalidate(16, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(17, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(18, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(19, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(20, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(21, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(22, playbackRate = $$props2.playbackRate);
    if ("play" in $$props2)
      $$invalidate(1, play = $$props2.play);
    if ("pause" in $$props2)
      $$invalidate(2, pause = $$props2.pause);
    if ("stop" in $$props2)
      $$invalidate(3, stop = $$props2.stop);
    if ("id" in $$props2)
      $$invalidate(24, id = $$props2.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    play,
    pause,
    stop,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    audio,
    id,
    slots,
    audioinstance_inViewport_binding,
    audioinstance_play_binding,
    audioinstance_pause_binding,
    audioinstance_stop_binding,
    viewportenter_handler,
    viewportleave_handler,
    load_handler,
    progress_handler,
    error_handler,
    $$scope
  ];
}
var Audio2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance14,
      create_fragment14,
      safe_not_equal,
      {
        position: 4,
        scale: 5,
        rotation: 6,
        lookAt: 7,
        viewportAware: 8,
        inViewport: 0,
        castShadow: 9,
        receiveShadow: 10,
        frustumCulled: 11,
        renderOrder: 12,
        visible: 13,
        userData: 14,
        dispose: 15,
        autoplay: 16,
        detune: 17,
        source: 18,
        volume: 19,
        loop: 20,
        filters: 21,
        playbackRate: 22,
        play: 1,
        pause: 2,
        stop: 3,
        id: 24,
        audio: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Audio",
      options,
      id: create_fragment14.name
    });
  }
  get position() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filters() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filters(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set play(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pause(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stop(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audio() {
    return this.$$.ctx[23];
  }
  set audio(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Audio_default = Audio2;

// node_modules/@threlte/core/dist/audio/PositionalAudio.svelte
var { Error: Error_12 } = globals;
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[30].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(54:0) <AudioInstance   {audio}   {position}   {filters}   {playbackRate}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {castShadow}   {receiveShadow}   {viewportAware}   {autoplay}   {source}   {detune}   {loop}   {volume}   bind:inViewport   on:viewportenter   on:viewportleave   on:load   on:progress   on:error   bind:play   bind:pause   bind:stop >",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let audioinstance;
  let updating_inViewport;
  let updating_play;
  let updating_pause;
  let updating_stop;
  let current;
  function audioinstance_inViewport_binding(value) {
    ctx[31](value);
  }
  function audioinstance_play_binding(value) {
    ctx[32](value);
  }
  function audioinstance_pause_binding(value) {
    ctx[33](value);
  }
  function audioinstance_stop_binding(value) {
    ctx[34](value);
  }
  let audioinstance_props = {
    audio: (
      /*audio*/
      ctx[23]
    ),
    position: (
      /*position*/
      ctx[4]
    ),
    filters: (
      /*filters*/
      ctx[21]
    ),
    playbackRate: (
      /*playbackRate*/
      ctx[22]
    ),
    scale: (
      /*scale*/
      ctx[5]
    ),
    rotation: (
      /*rotation*/
      ctx[6]
    ),
    lookAt: (
      /*lookAt*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[11]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[12]
    ),
    visible: (
      /*visible*/
      ctx[13]
    ),
    userData: (
      /*userData*/
      ctx[14]
    ),
    dispose: (
      /*dispose*/
      ctx[15]
    ),
    castShadow: (
      /*castShadow*/
      ctx[9]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[10]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[8]
    ),
    autoplay: (
      /*autoplay*/
      ctx[16]
    ),
    source: (
      /*source*/
      ctx[18]
    ),
    detune: (
      /*detune*/
      ctx[17]
    ),
    loop: (
      /*loop*/
      ctx[20]
    ),
    volume: (
      /*volume*/
      ctx[19]
    ),
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    audioinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  if (
    /*play*/
    ctx[1] !== void 0
  ) {
    audioinstance_props.play = /*play*/
    ctx[1];
  }
  if (
    /*pause*/
    ctx[2] !== void 0
  ) {
    audioinstance_props.pause = /*pause*/
    ctx[2];
  }
  if (
    /*stop*/
    ctx[3] !== void 0
  ) {
    audioinstance_props.stop = /*stop*/
    ctx[3];
  }
  audioinstance = new AudioInstance_default({
    props: audioinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(audioinstance, "inViewport", audioinstance_inViewport_binding));
  binding_callbacks.push(() => bind(audioinstance, "play", audioinstance_play_binding));
  binding_callbacks.push(() => bind(audioinstance, "pause", audioinstance_pause_binding));
  binding_callbacks.push(() => bind(audioinstance, "stop", audioinstance_stop_binding));
  audioinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[35]
  );
  audioinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[36]
  );
  audioinstance.$on(
    "load",
    /*load_handler*/
    ctx[37]
  );
  audioinstance.$on(
    "progress",
    /*progress_handler*/
    ctx[38]
  );
  audioinstance.$on(
    "error",
    /*error_handler*/
    ctx[39]
  );
  const block = {
    c: function create() {
      create_component(audioinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(audioinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(audioinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const audioinstance_changes = {};
      if (dirty[0] & /*position*/
      16)
        audioinstance_changes.position = /*position*/
        ctx2[4];
      if (dirty[0] & /*filters*/
      2097152)
        audioinstance_changes.filters = /*filters*/
        ctx2[21];
      if (dirty[0] & /*playbackRate*/
      4194304)
        audioinstance_changes.playbackRate = /*playbackRate*/
        ctx2[22];
      if (dirty[0] & /*scale*/
      32)
        audioinstance_changes.scale = /*scale*/
        ctx2[5];
      if (dirty[0] & /*rotation*/
      64)
        audioinstance_changes.rotation = /*rotation*/
        ctx2[6];
      if (dirty[0] & /*lookAt*/
      128)
        audioinstance_changes.lookAt = /*lookAt*/
        ctx2[7];
      if (dirty[0] & /*frustumCulled*/
      2048)
        audioinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[11];
      if (dirty[0] & /*renderOrder*/
      4096)
        audioinstance_changes.renderOrder = /*renderOrder*/
        ctx2[12];
      if (dirty[0] & /*visible*/
      8192)
        audioinstance_changes.visible = /*visible*/
        ctx2[13];
      if (dirty[0] & /*userData*/
      16384)
        audioinstance_changes.userData = /*userData*/
        ctx2[14];
      if (dirty[0] & /*dispose*/
      32768)
        audioinstance_changes.dispose = /*dispose*/
        ctx2[15];
      if (dirty[0] & /*castShadow*/
      512)
        audioinstance_changes.castShadow = /*castShadow*/
        ctx2[9];
      if (dirty[0] & /*receiveShadow*/
      1024)
        audioinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[10];
      if (dirty[0] & /*viewportAware*/
      256)
        audioinstance_changes.viewportAware = /*viewportAware*/
        ctx2[8];
      if (dirty[0] & /*autoplay*/
      65536)
        audioinstance_changes.autoplay = /*autoplay*/
        ctx2[16];
      if (dirty[0] & /*source*/
      262144)
        audioinstance_changes.source = /*source*/
        ctx2[18];
      if (dirty[0] & /*detune*/
      131072)
        audioinstance_changes.detune = /*detune*/
        ctx2[17];
      if (dirty[0] & /*loop*/
      1048576)
        audioinstance_changes.loop = /*loop*/
        ctx2[20];
      if (dirty[0] & /*volume*/
      524288)
        audioinstance_changes.volume = /*volume*/
        ctx2[19];
      if (dirty[1] & /*$$scope*/
      512) {
        audioinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        audioinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      if (!updating_play && dirty[0] & /*play*/
      2) {
        updating_play = true;
        audioinstance_changes.play = /*play*/
        ctx2[1];
        add_flush_callback(() => updating_play = false);
      }
      if (!updating_pause && dirty[0] & /*pause*/
      4) {
        updating_pause = true;
        audioinstance_changes.pause = /*pause*/
        ctx2[2];
        add_flush_callback(() => updating_pause = false);
      }
      if (!updating_stop && dirty[0] & /*stop*/
      8) {
        updating_stop = true;
        audioinstance_changes.stop = /*stop*/
        ctx2[3];
        add_flush_callback(() => updating_stop = false);
      }
      audioinstance.$set(audioinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(audioinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(audioinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(audioinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PositionalAudio", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { source = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { filters = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { play = void 0 } = $$props;
  let { pause = void 0 } = $$props;
  let { stop = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { directionalCone = void 0 } = $$props;
  let { refDistance = void 0 } = $$props;
  let { rolloffFactor = void 0 } = $$props;
  let { distanceModel = void 0 } = $$props;
  let { maxDistance = void 0 } = $$props;
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener(id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${id} found.`);
  }
  const audio = new PositionalAudio(listener);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "autoplay",
    "detune",
    "source",
    "volume",
    "loop",
    "filters",
    "playbackRate",
    "play",
    "pause",
    "stop",
    "id",
    "directionalCone",
    "refDistance",
    "rolloffFactor",
    "distanceModel",
    "maxDistance"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PositionalAudio> was created with unknown prop '${key}'`);
  });
  function audioinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function audioinstance_play_binding(value) {
    play = value;
    $$invalidate(1, play);
  }
  function audioinstance_pause_binding(value) {
    pause = value;
    $$invalidate(2, pause);
  }
  function audioinstance_stop_binding(value) {
    stop = value;
    $$invalidate(3, stop);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function progress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function error_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(5, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(6, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(7, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(9, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(10, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(11, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(12, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(13, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(14, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(15, dispose = $$props2.dispose);
    if ("autoplay" in $$props2)
      $$invalidate(16, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(17, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(18, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(19, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(20, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(21, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(22, playbackRate = $$props2.playbackRate);
    if ("play" in $$props2)
      $$invalidate(1, play = $$props2.play);
    if ("pause" in $$props2)
      $$invalidate(2, pause = $$props2.pause);
    if ("stop" in $$props2)
      $$invalidate(3, stop = $$props2.stop);
    if ("id" in $$props2)
      $$invalidate(24, id = $$props2.id);
    if ("directionalCone" in $$props2)
      $$invalidate(25, directionalCone = $$props2.directionalCone);
    if ("refDistance" in $$props2)
      $$invalidate(26, refDistance = $$props2.refDistance);
    if ("rolloffFactor" in $$props2)
      $$invalidate(27, rolloffFactor = $$props2.rolloffFactor);
    if ("distanceModel" in $$props2)
      $$invalidate(28, distanceModel = $$props2.distanceModel);
    if ("maxDistance" in $$props2)
      $$invalidate(29, maxDistance = $$props2.maxDistance);
    if ("$$scope" in $$props2)
      $$invalidate(40, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreePositionalAudio: PositionalAudio,
    useThrelteAudio,
    AudioInstance: AudioInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    play,
    pause,
    stop,
    id,
    directionalCone,
    refDistance,
    rolloffFactor,
    distanceModel,
    maxDistance,
    getAudioListener,
    listener,
    audio
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(5, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(6, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(7, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(9, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(10, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(11, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(12, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(13, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(14, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(15, dispose = $$props2.dispose);
    if ("autoplay" in $$props2)
      $$invalidate(16, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(17, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(18, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(19, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(20, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(21, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(22, playbackRate = $$props2.playbackRate);
    if ("play" in $$props2)
      $$invalidate(1, play = $$props2.play);
    if ("pause" in $$props2)
      $$invalidate(2, pause = $$props2.pause);
    if ("stop" in $$props2)
      $$invalidate(3, stop = $$props2.stop);
    if ("id" in $$props2)
      $$invalidate(24, id = $$props2.id);
    if ("directionalCone" in $$props2)
      $$invalidate(25, directionalCone = $$props2.directionalCone);
    if ("refDistance" in $$props2)
      $$invalidate(26, refDistance = $$props2.refDistance);
    if ("rolloffFactor" in $$props2)
      $$invalidate(27, rolloffFactor = $$props2.rolloffFactor);
    if ("distanceModel" in $$props2)
      $$invalidate(28, distanceModel = $$props2.distanceModel);
    if ("maxDistance" in $$props2)
      $$invalidate(29, maxDistance = $$props2.maxDistance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*refDistance, rolloffFactor, distanceModel, maxDistance, directionalCone*/
    1040187392) {
      $: {
        if (refDistance !== void 0)
          audio.setRefDistance(refDistance);
        if (rolloffFactor !== void 0)
          audio.setRolloffFactor(rolloffFactor);
        if (distanceModel !== void 0)
          audio.setDistanceModel(distanceModel);
        if (maxDistance !== void 0)
          audio.setMaxDistance(maxDistance);
        if (directionalCone !== void 0) {
          audio.setDirectionalCone(directionalCone.coneInnerAngle, directionalCone.coneOuterAngle, directionalCone.coneOuterGain);
        }
      }
    }
  };
  return [
    inViewport,
    play,
    pause,
    stop,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    audio,
    id,
    directionalCone,
    refDistance,
    rolloffFactor,
    distanceModel,
    maxDistance,
    slots,
    audioinstance_inViewport_binding,
    audioinstance_play_binding,
    audioinstance_pause_binding,
    audioinstance_stop_binding,
    viewportenter_handler,
    viewportleave_handler,
    load_handler,
    progress_handler,
    error_handler,
    $$scope
  ];
}
var PositionalAudio2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        position: 4,
        scale: 5,
        rotation: 6,
        lookAt: 7,
        viewportAware: 8,
        inViewport: 0,
        castShadow: 9,
        receiveShadow: 10,
        frustumCulled: 11,
        renderOrder: 12,
        visible: 13,
        userData: 14,
        dispose: 15,
        autoplay: 16,
        detune: 17,
        source: 18,
        volume: 19,
        loop: 20,
        filters: 21,
        playbackRate: 22,
        play: 1,
        pause: 2,
        stop: 3,
        id: 24,
        directionalCone: 25,
        refDistance: 26,
        rolloffFactor: 27,
        distanceModel: 28,
        maxDistance: 29,
        audio: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PositionalAudio",
      options,
      id: create_fragment15.name
    });
  }
  get position() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filters() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filters(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set play(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pause(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stop(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get directionalCone() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set directionalCone(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refDistance() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set refDistance(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rolloffFactor() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rolloffFactor(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distanceModel() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distanceModel(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxDistance() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxDistance(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audio() {
    return this.$$.ctx[23];
  }
  set audio(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PositionalAudio_default = PositionalAudio2;

// node_modules/three/examples/jsm/helpers/PositionalAudioHelper.js
var PositionalAudioHelper = class extends Line {
  constructor(audio, range = 1, divisionsInnerAngle = 16, divisionsOuterAngle = 2) {
    const geometry = new BufferGeometry();
    const divisions = divisionsInnerAngle + divisionsOuterAngle * 2;
    const positions = new Float32Array((divisions * 3 + 3) * 3);
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    const materialInnerAngle = new LineBasicMaterial({ color: 65280 });
    const materialOuterAngle = new LineBasicMaterial({ color: 16776960 });
    super(geometry, [materialOuterAngle, materialInnerAngle]);
    this.audio = audio;
    this.range = range;
    this.divisionsInnerAngle = divisionsInnerAngle;
    this.divisionsOuterAngle = divisionsOuterAngle;
    this.type = "PositionalAudioHelper";
    this.update();
  }
  update() {
    const audio = this.audio;
    const range = this.range;
    const divisionsInnerAngle = this.divisionsInnerAngle;
    const divisionsOuterAngle = this.divisionsOuterAngle;
    const coneInnerAngle = MathUtils.degToRad(audio.panner.coneInnerAngle);
    const coneOuterAngle = MathUtils.degToRad(audio.panner.coneOuterAngle);
    const halfConeInnerAngle = coneInnerAngle / 2;
    const halfConeOuterAngle = coneOuterAngle / 2;
    let start = 0;
    let count = 0;
    let i;
    let stride;
    const geometry = this.geometry;
    const positionAttribute = geometry.attributes.position;
    geometry.clearGroups();
    function generateSegment(from, to, divisions, materialIndex) {
      const step = (to - from) / divisions;
      positionAttribute.setXYZ(start, 0, 0, 0);
      count++;
      for (i = from; i < to; i += step) {
        stride = start + count;
        positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);
        positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);
        positionAttribute.setXYZ(stride + 2, 0, 0, 0);
        count += 3;
      }
      geometry.addGroup(start, count, materialIndex);
      start += count;
      count = 0;
    }
    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);
    positionAttribute.needsUpdate = true;
    if (coneInnerAngle === coneOuterAngle)
      this.material[0].visible = false;
  }
  dispose() {
    this.geometry.dispose();
    this.material[0].dispose();
    this.material[1].dispose();
  }
};

// node_modules/@threlte/core/dist/helpers/PositionalAudioHelper.svelte
var { console: console_12 } = globals;
function create_if_block2(ctx) {
  let object3dinstance;
  let current;
  object3dinstance = new Object3DInstance_default({
    props: { dispose: true, object: (
      /*helper*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const object3dinstance_changes = {};
      if (dirty & /*helper*/
      1)
        object3dinstance_changes.object = /*helper*/
        ctx2[0];
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(15:0) {#if helper}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*helper*/
    ctx[0] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*helper*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*helper*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PositionalAudioHelper", slots, []);
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(2, $parent = value));
  let helper;
  if (!($parent instanceof PositionalAudio)) {
    console.warn("<PositionalAudioHelper> can only be used as a direct child of <PositionalAudio>");
  } else {
    helper = new PositionalAudioHelper($parent);
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_12.warn(`<PositionalAudioHelper> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    PositionalAudio,
    ThreePositionalAudioHelper: PositionalAudioHelper,
    Object3DInstance: Object3DInstance_default,
    useParent,
    parent,
    helper,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("helper" in $$props2)
      $$invalidate(0, helper = $$props2.helper);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [helper, parent];
}
var PositionalAudioHelper2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PositionalAudioHelper",
      options,
      id: create_fragment16.name
    });
  }
};
var PositionalAudioHelper_default = PositionalAudioHelper2;

// node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var OrbitControls = class extends EventDispatcher {
  constructor(object, domElement) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = null;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update() {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max < -Math.PI)
            max += twoPI;
          else if (max > Math.PI)
            max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown2);
      scope.domElement.removeEventListener("pointercancel", onPointerCancel);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove2);
      scope.domElement.removeEventListener("pointerup", onPointerUp2);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        scope._domElementKeyEvents = null;
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = function() {
      const v = new Vector3();
      return function panLeft2(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();
    const panUp = function() {
      const v = new Vector3();
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();
    const pan = function() {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element2 = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element2.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element2.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element2.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element2.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element2 = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element2.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element2.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, -scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(-scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element2 = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element2.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element2.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown2(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove2);
        scope.domElement.addEventListener("pointerup", onPointerUp2);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove2(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp2(event) {
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove2);
        scope.domElement.removeEventListener("pointerup", onPointerUp2);
      }
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i].pointerId == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown2);
    scope.domElement.addEventListener("pointercancel", onPointerCancel);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
};

// node_modules/@threlte/core/dist/controls/OrbitControls.svelte
var { Error: Error_13 } = globals;
function create_fragment17(ctx) {
  let disposableobject;
  let t;
  let transformableobject;
  let current;
  disposableobject = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[2]
      ),
      object: (
        /*controls*/
        ctx[0]
      )
    },
    $$inline: true
  });
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*targetObject*/
        ctx[4]
      ),
      position: (
        /*target*/
        ctx[1]
      )
    },
    $$inline: true
  });
  transformableobject.$on(
    "transform",
    /*updateControls*/
    ctx[5]
  );
  const block = {
    c: function create() {
      create_component(disposableobject.$$.fragment);
      t = space();
      create_component(transformableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(transformableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(transformableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject_changes = {};
      if (dirty[0] & /*dispose*/
      4)
        disposableobject_changes.dispose = /*dispose*/
        ctx2[2];
      if (dirty[0] & /*controls*/
      1)
        disposableobject_changes.object = /*controls*/
        ctx2[0];
      disposableobject.$set(disposableobject_changes);
      const transformableobject_changes = {};
      if (dirty[0] & /*target*/
      2)
        transformableobject_changes.position = /*target*/
        ctx2[1];
      transformableobject.$set(transformableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject.$$.fragment, local);
      transition_in(transformableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject.$$.fragment, local);
      transition_out(transformableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(transformableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OrbitControls", slots, []);
  let { autoRotate = void 0 } = $$props;
  let { autoRotateSpeed = void 0 } = $$props;
  let { dampingFactor = void 0 } = $$props;
  let { enableDamping = void 0 } = $$props;
  let { enabled = void 0 } = $$props;
  let { enablePan = void 0 } = $$props;
  let { enableRotate = void 0 } = $$props;
  let { enableZoom = void 0 } = $$props;
  let { keyPanSpeed = void 0 } = $$props;
  let { keys = void 0 } = $$props;
  let { maxAzimuthAngle = void 0 } = $$props;
  let { maxDistance = void 0 } = $$props;
  let { maxPolarAngle = void 0 } = $$props;
  let { maxZoom = void 0 } = $$props;
  let { minAzimuthAngle = void 0 } = $$props;
  let { minDistance = void 0 } = $$props;
  let { minPolarAngle = void 0 } = $$props;
  let { minZoom = void 0 } = $$props;
  let { mouseButtons = void 0 } = $$props;
  let { panSpeed = void 0 } = $$props;
  let { rotateSpeed = void 0 } = $$props;
  let { screenSpacePanning = void 0 } = $$props;
  let { touches = void 0 } = $$props;
  let { zoomSpeed = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(30, $parent = value));
  const { renderer, invalidate } = useThrelte();
  if (!renderer)
    throw new Error("Threlte Context missing: Is <OrbitControls> a child of <Canvas>?");
  if (!($parent instanceof Camera)) {
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  }
  const dispatch = createEventDispatcher();
  const onChange = () => {
    invalidate("Orbitcontrols: change event");
    dispatch("change");
  };
  const onStart = () => dispatch("start");
  const onEnd = () => dispatch("end");
  const controls = new OrbitControls($parent, renderer.domElement);
  getThrelteUserData($parent).orbitControls = controls;
  controls.addEventListener("change", onChange);
  controls.addEventListener("start", onStart);
  controls.addEventListener("end", onEnd);
  onDestroy(() => {
    if ($parent) {
      delete getThrelteUserData($parent).orbitControls;
    }
    controls.removeEventListener("change", onChange);
    controls.removeEventListener("start", onStart);
    controls.removeEventListener("end", onEnd);
  });
  const { start, stop } = useFrame(() => controls.update(), {
    autostart: false,
    debugFrameloopMessage: "OrbitControlts: updating controls"
  });
  const targetObject = new Object3D();
  const updateControls = () => {
    $$invalidate(0, controls.target = targetObject.position, controls);
    controls.update();
    invalidate("OrbitControls: target changed");
  };
  const writable_props = [
    "autoRotate",
    "autoRotateSpeed",
    "dampingFactor",
    "enableDamping",
    "enabled",
    "enablePan",
    "enableRotate",
    "enableZoom",
    "keyPanSpeed",
    "keys",
    "maxAzimuthAngle",
    "maxDistance",
    "maxPolarAngle",
    "maxZoom",
    "minAzimuthAngle",
    "minDistance",
    "minPolarAngle",
    "minZoom",
    "mouseButtons",
    "panSpeed",
    "rotateSpeed",
    "screenSpacePanning",
    "touches",
    "zoomSpeed",
    "target",
    "dispose"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<OrbitControls> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("autoRotate" in $$props2)
      $$invalidate(6, autoRotate = $$props2.autoRotate);
    if ("autoRotateSpeed" in $$props2)
      $$invalidate(7, autoRotateSpeed = $$props2.autoRotateSpeed);
    if ("dampingFactor" in $$props2)
      $$invalidate(8, dampingFactor = $$props2.dampingFactor);
    if ("enableDamping" in $$props2)
      $$invalidate(9, enableDamping = $$props2.enableDamping);
    if ("enabled" in $$props2)
      $$invalidate(10, enabled = $$props2.enabled);
    if ("enablePan" in $$props2)
      $$invalidate(11, enablePan = $$props2.enablePan);
    if ("enableRotate" in $$props2)
      $$invalidate(12, enableRotate = $$props2.enableRotate);
    if ("enableZoom" in $$props2)
      $$invalidate(13, enableZoom = $$props2.enableZoom);
    if ("keyPanSpeed" in $$props2)
      $$invalidate(14, keyPanSpeed = $$props2.keyPanSpeed);
    if ("keys" in $$props2)
      $$invalidate(15, keys = $$props2.keys);
    if ("maxAzimuthAngle" in $$props2)
      $$invalidate(16, maxAzimuthAngle = $$props2.maxAzimuthAngle);
    if ("maxDistance" in $$props2)
      $$invalidate(17, maxDistance = $$props2.maxDistance);
    if ("maxPolarAngle" in $$props2)
      $$invalidate(18, maxPolarAngle = $$props2.maxPolarAngle);
    if ("maxZoom" in $$props2)
      $$invalidate(19, maxZoom = $$props2.maxZoom);
    if ("minAzimuthAngle" in $$props2)
      $$invalidate(20, minAzimuthAngle = $$props2.minAzimuthAngle);
    if ("minDistance" in $$props2)
      $$invalidate(21, minDistance = $$props2.minDistance);
    if ("minPolarAngle" in $$props2)
      $$invalidate(22, minPolarAngle = $$props2.minPolarAngle);
    if ("minZoom" in $$props2)
      $$invalidate(23, minZoom = $$props2.minZoom);
    if ("mouseButtons" in $$props2)
      $$invalidate(24, mouseButtons = $$props2.mouseButtons);
    if ("panSpeed" in $$props2)
      $$invalidate(25, panSpeed = $$props2.panSpeed);
    if ("rotateSpeed" in $$props2)
      $$invalidate(26, rotateSpeed = $$props2.rotateSpeed);
    if ("screenSpacePanning" in $$props2)
      $$invalidate(27, screenSpacePanning = $$props2.screenSpacePanning);
    if ("touches" in $$props2)
      $$invalidate(28, touches = $$props2.touches);
    if ("zoomSpeed" in $$props2)
      $$invalidate(29, zoomSpeed = $$props2.zoomSpeed);
    if ("target" in $$props2)
      $$invalidate(1, target = $$props2.target);
    if ("dispose" in $$props2)
      $$invalidate(2, dispose = $$props2.dispose);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    Camera,
    Object3D,
    ThreeOrbitControls: OrbitControls,
    useFrame,
    useThrelte,
    DisposableObject: DisposableObject_default,
    useParent,
    TransformableObject: TransformableObject_default,
    getThrelteUserData,
    autoRotate,
    autoRotateSpeed,
    dampingFactor,
    enableDamping,
    enabled,
    enablePan,
    enableRotate,
    enableZoom,
    keyPanSpeed,
    keys,
    maxAzimuthAngle,
    maxDistance,
    maxPolarAngle,
    maxZoom,
    minAzimuthAngle,
    minDistance,
    minPolarAngle,
    minZoom,
    mouseButtons,
    panSpeed,
    rotateSpeed,
    screenSpacePanning,
    touches,
    zoomSpeed,
    target,
    dispose,
    parent,
    renderer,
    invalidate,
    dispatch,
    onChange,
    onStart,
    onEnd,
    controls,
    start,
    stop,
    targetObject,
    updateControls,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("autoRotate" in $$props2)
      $$invalidate(6, autoRotate = $$props2.autoRotate);
    if ("autoRotateSpeed" in $$props2)
      $$invalidate(7, autoRotateSpeed = $$props2.autoRotateSpeed);
    if ("dampingFactor" in $$props2)
      $$invalidate(8, dampingFactor = $$props2.dampingFactor);
    if ("enableDamping" in $$props2)
      $$invalidate(9, enableDamping = $$props2.enableDamping);
    if ("enabled" in $$props2)
      $$invalidate(10, enabled = $$props2.enabled);
    if ("enablePan" in $$props2)
      $$invalidate(11, enablePan = $$props2.enablePan);
    if ("enableRotate" in $$props2)
      $$invalidate(12, enableRotate = $$props2.enableRotate);
    if ("enableZoom" in $$props2)
      $$invalidate(13, enableZoom = $$props2.enableZoom);
    if ("keyPanSpeed" in $$props2)
      $$invalidate(14, keyPanSpeed = $$props2.keyPanSpeed);
    if ("keys" in $$props2)
      $$invalidate(15, keys = $$props2.keys);
    if ("maxAzimuthAngle" in $$props2)
      $$invalidate(16, maxAzimuthAngle = $$props2.maxAzimuthAngle);
    if ("maxDistance" in $$props2)
      $$invalidate(17, maxDistance = $$props2.maxDistance);
    if ("maxPolarAngle" in $$props2)
      $$invalidate(18, maxPolarAngle = $$props2.maxPolarAngle);
    if ("maxZoom" in $$props2)
      $$invalidate(19, maxZoom = $$props2.maxZoom);
    if ("minAzimuthAngle" in $$props2)
      $$invalidate(20, minAzimuthAngle = $$props2.minAzimuthAngle);
    if ("minDistance" in $$props2)
      $$invalidate(21, minDistance = $$props2.minDistance);
    if ("minPolarAngle" in $$props2)
      $$invalidate(22, minPolarAngle = $$props2.minPolarAngle);
    if ("minZoom" in $$props2)
      $$invalidate(23, minZoom = $$props2.minZoom);
    if ("mouseButtons" in $$props2)
      $$invalidate(24, mouseButtons = $$props2.mouseButtons);
    if ("panSpeed" in $$props2)
      $$invalidate(25, panSpeed = $$props2.panSpeed);
    if ("rotateSpeed" in $$props2)
      $$invalidate(26, rotateSpeed = $$props2.rotateSpeed);
    if ("screenSpacePanning" in $$props2)
      $$invalidate(27, screenSpacePanning = $$props2.screenSpacePanning);
    if ("touches" in $$props2)
      $$invalidate(28, touches = $$props2.touches);
    if ("zoomSpeed" in $$props2)
      $$invalidate(29, zoomSpeed = $$props2.zoomSpeed);
    if ("target" in $$props2)
      $$invalidate(1, target = $$props2.target);
    if ("dispose" in $$props2)
      $$invalidate(2, dispose = $$props2.dispose);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*autoRotate, autoRotateSpeed, dampingFactor, enableDamping, enabled, enablePan, enableRotate, enableZoom, keyPanSpeed, keys, maxAzimuthAngle, maxDistance, maxPolarAngle, maxZoom, minAzimuthAngle, minDistance, minPolarAngle, minZoom, mouseButtons, panSpeed, rotateSpeed, screenSpacePanning, touches, zoomSpeed, controls*/
    1073741761) {
      $: {
        if (autoRotate !== void 0)
          $$invalidate(0, controls.autoRotate = autoRotate, controls);
        if (autoRotateSpeed !== void 0)
          $$invalidate(0, controls.autoRotateSpeed = autoRotateSpeed, controls);
        if (dampingFactor !== void 0)
          $$invalidate(0, controls.dampingFactor = dampingFactor, controls);
        if (enableDamping !== void 0)
          $$invalidate(0, controls.enableDamping = enableDamping, controls);
        if (enabled !== void 0)
          $$invalidate(0, controls.enabled = enabled, controls);
        if (enablePan !== void 0)
          $$invalidate(0, controls.enablePan = enablePan, controls);
        if (enableRotate !== void 0)
          $$invalidate(0, controls.enableRotate = enableRotate, controls);
        if (enableZoom !== void 0)
          $$invalidate(0, controls.enableZoom = enableZoom, controls);
        if (keyPanSpeed !== void 0)
          $$invalidate(0, controls.keyPanSpeed = keyPanSpeed, controls);
        if (keys !== void 0)
          $$invalidate(0, controls.keys = keys, controls);
        if (maxAzimuthAngle !== void 0)
          $$invalidate(0, controls.maxAzimuthAngle = maxAzimuthAngle, controls);
        if (maxDistance !== void 0)
          $$invalidate(0, controls.maxDistance = maxDistance, controls);
        if (maxPolarAngle !== void 0)
          $$invalidate(0, controls.maxPolarAngle = maxPolarAngle, controls);
        if (maxZoom !== void 0)
          $$invalidate(0, controls.maxZoom = maxZoom, controls);
        if (minAzimuthAngle !== void 0)
          $$invalidate(0, controls.minAzimuthAngle = minAzimuthAngle, controls);
        if (minDistance !== void 0)
          $$invalidate(0, controls.minDistance = minDistance, controls);
        if (minPolarAngle !== void 0)
          $$invalidate(0, controls.minPolarAngle = minPolarAngle, controls);
        if (minZoom !== void 0)
          $$invalidate(0, controls.minZoom = minZoom, controls);
        if (mouseButtons !== void 0)
          $$invalidate(0, controls.mouseButtons = mouseButtons, controls);
        if (panSpeed !== void 0)
          $$invalidate(0, controls.panSpeed = panSpeed, controls);
        if (rotateSpeed !== void 0)
          $$invalidate(0, controls.rotateSpeed = rotateSpeed, controls);
        if (screenSpacePanning !== void 0)
          $$invalidate(0, controls.screenSpacePanning = screenSpacePanning, controls);
        if (touches !== void 0)
          $$invalidate(0, controls.touches = touches, controls);
        if (zoomSpeed !== void 0)
          $$invalidate(0, controls.zoomSpeed = zoomSpeed, controls);
        controls.update();
        invalidate("OrbitControls: props changed");
      }
    }
    if ($$self.$$.dirty[0] & /*autoRotate, enableDamping*/
    576) {
      $: {
        if (autoRotate || enableDamping)
          start();
        else
          stop();
      }
    }
  };
  return [
    controls,
    target,
    dispose,
    parent,
    targetObject,
    updateControls,
    autoRotate,
    autoRotateSpeed,
    dampingFactor,
    enableDamping,
    enabled,
    enablePan,
    enableRotate,
    enableZoom,
    keyPanSpeed,
    keys,
    maxAzimuthAngle,
    maxDistance,
    maxPolarAngle,
    maxZoom,
    minAzimuthAngle,
    minDistance,
    minPolarAngle,
    minZoom,
    mouseButtons,
    panSpeed,
    rotateSpeed,
    screenSpacePanning,
    touches,
    zoomSpeed
  ];
}
var OrbitControls2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        autoRotate: 6,
        autoRotateSpeed: 7,
        dampingFactor: 8,
        enableDamping: 9,
        enabled: 10,
        enablePan: 11,
        enableRotate: 12,
        enableZoom: 13,
        keyPanSpeed: 14,
        keys: 15,
        maxAzimuthAngle: 16,
        maxDistance: 17,
        maxPolarAngle: 18,
        maxZoom: 19,
        minAzimuthAngle: 20,
        minDistance: 21,
        minPolarAngle: 22,
        minZoom: 23,
        mouseButtons: 24,
        panSpeed: 25,
        rotateSpeed: 26,
        screenSpacePanning: 27,
        touches: 28,
        zoomSpeed: 29,
        target: 1,
        dispose: 2,
        controls: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OrbitControls",
      options,
      id: create_fragment17.name
    });
  }
  get autoRotate() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoRotate(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoRotateSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoRotateSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dampingFactor() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dampingFactor(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableDamping() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableDamping(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enabled() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabled(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enablePan() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enablePan(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableRotate() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableRotate(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableZoom() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableZoom(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyPanSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyPanSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keys() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxAzimuthAngle() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxAzimuthAngle(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxDistance() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxDistance(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxPolarAngle() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxPolarAngle(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxZoom() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxZoom(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minAzimuthAngle() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minAzimuthAngle(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minDistance() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minDistance(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minPolarAngle() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minPolarAngle(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minZoom() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minZoom(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mouseButtons() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mouseButtons(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotateSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotateSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get screenSpacePanning() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set screenSpacePanning(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touches() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touches(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controls() {
    return this.$$.ctx[0];
  }
  set controls(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OrbitControls_default = OrbitControls2;

// node_modules/three/examples/jsm/controls/TransformControls.js
var _raycaster = new Raycaster();
var _tempVector = new Vector3();
var _tempVector2 = new Vector3();
var _tempQuaternion = new Quaternion();
var _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var _changeEvent2 = { type: "change" };
var _mouseDownEvent = { type: "mouseDown" };
var _mouseUpEvent = { type: "mouseUp", mode: null };
var _objectChangeEvent = { type: "objectChange" };
var TransformControls = class extends Object3D {
  constructor(camera, domElement) {
    super();
    if (domElement === void 0) {
      console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
      domElement = document;
    }
    this.isTransformControls = true;
    this.visible = false;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    const _gizmo = new TransformControlsGizmo();
    this._gizmo = _gizmo;
    this.add(_gizmo);
    const _plane = new TransformControlsPlane();
    this._plane = _plane;
    this.add(_plane);
    const scope = this;
    function defineProperty(propName, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            _plane[propName] = value;
            _gizmo[propName] = value;
            scope.dispatchEvent({ type: propName + "-changed", value });
            scope.dispatchEvent(_changeEvent2);
          }
        }
      });
      scope[propName] = defaultValue;
      _plane[propName] = defaultValue;
      _gizmo[propName] = defaultValue;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    if (this.object !== void 0) {
      this.object.updateMatrixWorld();
      if (this.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);
      }
      this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);
      this._parentQuaternionInv.copy(this._parentQuaternion).invert();
      this._worldQuaternionInv.copy(this.worldQuaternion).invert();
    }
    this.camera.updateMatrixWorld();
    this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);
    if (this.camera.isOrthographicCamera) {
      this.camera.getWorldDirection(this.eye).negate();
    } else {
      this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
    }
    super.updateMatrixWorld(this);
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer.button !== 0)
      return;
    if (this.axis !== null) {
      _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space2 = this.space;
    if (mode === "scale") {
      space2 = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space2 = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer.button !== -1)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect)
      return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1)
        this._offset.x = 0;
      if (axis.indexOf("Y") === -1)
        this._offset.y = 0;
      if (axis.indexOf("Z") === -1)
        this._offset.z = 0;
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space2 === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space2 === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0)
          d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      if (axis === "E") {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      } else if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space2 === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        this.rotationAngle = this._offset.dot(_tempVector.cross(this.eye).normalize()) * ROTATION_SPEED;
      }
      if (this.rotationSnap)
        this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space2 === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent2);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer.button !== 0)
      return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.traverse(function(child) {
      if (child.geometry)
        child.geometry.dispose();
      if (child.material)
        child.material.dispose();
    });
  }
  // Set current object
  attach(object) {
    this.object = object;
    this.visible = true;
    return this;
  }
  // Detach from object
  detach() {
    this.object = void 0;
    this.visible = false;
    this.axis = null;
    return this;
  }
  reset() {
    if (!this.enabled)
      return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent2);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  getRaycaster() {
    return _raycaster;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  setSize(size) {
    this.size = size;
  }
  setSpace(space2) {
    this.space = space2;
  }
};
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled)
    return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled)
    return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled)
    return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled)
    return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
var _tempEuler = new Euler();
var _alignVector = new Vector3(0, 1, 0);
var _zeroVector = new Vector3(0, 0, 0);
var _lookAtMatrix = new Matrix4();
var _tempQuaternion2 = new Quaternion();
var _identityQuaternion = new Quaternion();
var _dirVector = new Vector3();
var _tempMatrix = new Matrix4();
var _unitX = new Vector3(1, 0, 0);
var _unitY = new Vector3(0, 1, 0);
var _unitZ = new Vector3(0, 0, 1);
var _v1 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space2 = this.mode === "scale" ? "local" : this.space;
    const quaternion = space2 === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space2 = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale")
      space2 = "local";
    _v1.copy(_unitX).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v2.copy(_unitY).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v2);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2);
            _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
};

// node_modules/@threlte/core/dist/controls/TransformControls.svelte
var { Error: Error_14, Object: Object_1 } = globals;
function create_fragment18(ctx) {
  let disposableobject;
  let t;
  let layerableobject;
  let current;
  disposableobject = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[0]
      ),
      object: (
        /*transformControls*/
        ctx[1]
      )
    },
    $$inline: true
  });
  layerableobject = new LayerableObject_default({
    props: { object: (
      /*transformControls*/
      ctx[1]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(disposableobject.$$.fragment);
      t = space();
      create_component(layerableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(layerableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(layerableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const disposableobject_changes = {};
      if (dirty & /*dispose*/
      1)
        disposableobject_changes.dispose = /*dispose*/
        ctx2[0];
      if (dirty & /*transformControls*/
      2)
        disposableobject_changes.object = /*transformControls*/
        ctx2[1];
      disposableobject.$set(disposableobject_changes);
      const layerableobject_changes = {};
      if (dirty & /*transformControls*/
      2)
        layerableobject_changes.object = /*transformControls*/
        ctx2[1];
      layerableobject.$set(layerableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject.$$.fragment, local);
      transition_in(layerableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject.$$.fragment, local);
      transition_out(layerableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(layerableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let $parent;
  let $camera;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransformControls", slots, []);
  let { autoPauseOrbitControls = true } = $$props;
  let { mode = void 0 } = $$props;
  let { axis = null } = $$props;
  let { dragging = false } = $$props;
  let { enabled = void 0 } = $$props;
  let { translationSnap = void 0 } = $$props;
  let { scaleSnap = void 0 } = $$props;
  let { rotationSnap = void 0 } = $$props;
  let { showX = void 0 } = $$props;
  let { showY = void 0 } = $$props;
  let { showZ = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { space: space2 = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  const { camera, renderer, invalidate, scene } = useThrelte();
  validate_store(camera, "camera");
  component_subscribe($$self, camera, (value) => $$invalidate(20, $camera = value));
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(19, $parent = value));
  if (!$parent)
    throw new Error("TransformControls: parent not defined. Is this component a child of <Canvas>?");
  const dispatch = createEventDispatcher();
  const maybeGetCameraOrbitControls = () => {
    if (!$camera)
      return;
    return getThrelteUserData($camera).orbitControls;
  };
  let enabledStateBeforeAutoPause;
  const cleanupAutoPause = () => {
    if (enabledStateBeforeAutoPause !== void 0) {
      const orbitControls = maybeGetCameraOrbitControls();
      if (orbitControls)
        orbitControls.enabled = enabledStateBeforeAutoPause;
      enabledStateBeforeAutoPause = void 0;
    }
  };
  onDestroy(cleanupAutoPause);
  const eventMap = {
    change: (e) => {
      var _a, _b;
      if ($parent)
        (_b = (_a = getThrelteUserData($parent)).onTransform) == null ? void 0 : _b.call(_a);
      invalidate("TransformControls: change event");
      dispatch("change", e);
    },
    "camera-changed": (e) => dispatch("camera-changed", e),
    "object-changed": (e) => dispatch("object-changed", e),
    "enabled-changed": (e) => dispatch("enabled-changed", e),
    "axis-changed": (e) => {
      $$invalidate(4, axis = e.value);
      dispatch("axis-changed", e);
    },
    "mode-changed": (e) => dispatch("mode-changed", e),
    "translationSnap-changed": (e) => dispatch("translationSnap-changed", e),
    "rotationSnap-changed": (e) => dispatch("rotationSnap-changed", e),
    "scaleSnap-changed": (e) => dispatch("scaleSnap-changed", e),
    "space-changed": (e) => dispatch("space-changed", e),
    "size-changed": (e) => dispatch("size-changed", e),
    "dragging-changed": (e) => {
      $$invalidate(5, dragging = e.value);
      autopause: {
        if (autoPauseOrbitControls) {
          const orbitControls = maybeGetCameraOrbitControls();
          if (!orbitControls)
            break autopause;
          const shouldBeEnabled = !e.value;
          if (orbitControls.enabled === shouldBeEnabled)
            break autopause;
          if (e.value) {
            enabledStateBeforeAutoPause = orbitControls.enabled;
          }
          orbitControls.enabled = shouldBeEnabled;
        }
      }
      dispatch("dragging-changed", e);
    },
    "showX-changed": (e) => dispatch("showX-changed", e),
    "showY-changed": (e) => dispatch("showY-changed", e),
    "showZ-changed": (e) => dispatch("showZ-changed", e),
    "worldPosition-changed": (e) => dispatch("worldPosition-changed", e),
    "worldPositionStart-changed": (e) => dispatch("worldPositionStart-changed", e),
    "worldQuaternion-changed": (e) => dispatch("worldQuaternion-changed", e),
    "worldQuaternionStart-changed": (e) => dispatch("worldQuaternionStart-changed", e),
    "cameraPosition-changed": (e) => dispatch("cameraPosition-changed", e),
    "cameraQuaternion-changed": (e) => dispatch("cameraQuaternion-changed", e),
    "pointStart-changed": (e) => dispatch("pointStart-changed", e),
    "pointEnd-changed": (e) => dispatch("pointEnd-changed", e),
    "rotationAxis-changed": (e) => dispatch("rotationAxis-changed", e),
    "rotationAngle-changed": (e) => dispatch("rotationAngle-changed", e),
    "eye-changed": (e) => dispatch("eye-changed", e),
    mouseDown: () => dispatch("mouseDown"),
    mouseUp: () => dispatch("mouseUp"),
    objectChange: () => dispatch("objectChange")
  };
  if (!renderer) {
    throw new Error("TransformControls: renderer is undefined, is this component a child of <Canvas>?");
  }
  const transformControls = new TransformControls($camera, renderer.domElement);
  const reset = () => transformControls.reset();
  transformControls.attach($parent);
  const addListeners = () => {
    Object.entries(eventMap).forEach(([key, fn]) => {
      transformControls.addEventListener(key, fn);
    });
  };
  const removeListeners = () => {
    Object.entries(eventMap).forEach(([key, fn]) => {
      transformControls.removeEventListener(key, fn);
    });
  };
  addListeners();
  scene.add(transformControls);
  onDestroy(() => {
    transformControls.detach();
    scene.remove(transformControls);
    removeListeners();
  });
  const writable_props = [
    "autoPauseOrbitControls",
    "mode",
    "axis",
    "dragging",
    "enabled",
    "translationSnap",
    "scaleSnap",
    "rotationSnap",
    "showX",
    "showY",
    "showZ",
    "size",
    "space",
    "dispose"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TransformControls> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("autoPauseOrbitControls" in $$props2)
      $$invalidate(6, autoPauseOrbitControls = $$props2.autoPauseOrbitControls);
    if ("mode" in $$props2)
      $$invalidate(7, mode = $$props2.mode);
    if ("axis" in $$props2)
      $$invalidate(4, axis = $$props2.axis);
    if ("dragging" in $$props2)
      $$invalidate(5, dragging = $$props2.dragging);
    if ("enabled" in $$props2)
      $$invalidate(8, enabled = $$props2.enabled);
    if ("translationSnap" in $$props2)
      $$invalidate(9, translationSnap = $$props2.translationSnap);
    if ("scaleSnap" in $$props2)
      $$invalidate(10, scaleSnap = $$props2.scaleSnap);
    if ("rotationSnap" in $$props2)
      $$invalidate(11, rotationSnap = $$props2.rotationSnap);
    if ("showX" in $$props2)
      $$invalidate(12, showX = $$props2.showX);
    if ("showY" in $$props2)
      $$invalidate(13, showY = $$props2.showY);
    if ("showZ" in $$props2)
      $$invalidate(14, showZ = $$props2.showZ);
    if ("size" in $$props2)
      $$invalidate(15, size = $$props2.size);
    if ("space" in $$props2)
      $$invalidate(16, space2 = $$props2.space);
    if ("dispose" in $$props2)
      $$invalidate(0, dispose = $$props2.dispose);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    TransformControls,
    useThrelte,
    DisposableObject: DisposableObject_default,
    useParent,
    LayerableObject: LayerableObject_default,
    getThrelteUserData,
    autoPauseOrbitControls,
    mode,
    axis,
    dragging,
    enabled,
    translationSnap,
    scaleSnap,
    rotationSnap,
    showX,
    showY,
    showZ,
    size,
    space: space2,
    dispose,
    camera,
    renderer,
    invalidate,
    scene,
    parent,
    dispatch,
    maybeGetCameraOrbitControls,
    enabledStateBeforeAutoPause,
    cleanupAutoPause,
    eventMap,
    transformControls,
    reset,
    addListeners,
    removeListeners,
    $parent,
    $camera
  });
  $$self.$inject_state = ($$props2) => {
    if ("autoPauseOrbitControls" in $$props2)
      $$invalidate(6, autoPauseOrbitControls = $$props2.autoPauseOrbitControls);
    if ("mode" in $$props2)
      $$invalidate(7, mode = $$props2.mode);
    if ("axis" in $$props2)
      $$invalidate(4, axis = $$props2.axis);
    if ("dragging" in $$props2)
      $$invalidate(5, dragging = $$props2.dragging);
    if ("enabled" in $$props2)
      $$invalidate(8, enabled = $$props2.enabled);
    if ("translationSnap" in $$props2)
      $$invalidate(9, translationSnap = $$props2.translationSnap);
    if ("scaleSnap" in $$props2)
      $$invalidate(10, scaleSnap = $$props2.scaleSnap);
    if ("rotationSnap" in $$props2)
      $$invalidate(11, rotationSnap = $$props2.rotationSnap);
    if ("showX" in $$props2)
      $$invalidate(12, showX = $$props2.showX);
    if ("showY" in $$props2)
      $$invalidate(13, showY = $$props2.showY);
    if ("showZ" in $$props2)
      $$invalidate(14, showZ = $$props2.showZ);
    if ("size" in $$props2)
      $$invalidate(15, size = $$props2.size);
    if ("space" in $$props2)
      $$invalidate(16, space2 = $$props2.space);
    if ("dispose" in $$props2)
      $$invalidate(0, dispose = $$props2.dispose);
    if ("enabledStateBeforeAutoPause" in $$props2)
      enabledStateBeforeAutoPause = $$props2.enabledStateBeforeAutoPause;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*autoPauseOrbitControls*/
    64) {
      $:
        if (!autoPauseOrbitControls)
          cleanupAutoPause();
    }
    if ($$self.$$.dirty & /*enabled*/
    256) {
      $:
        if (enabled !== void 0)
          $$invalidate(1, transformControls.enabled = enabled, transformControls);
    }
    if ($$self.$$.dirty & /*showX*/
    4096) {
      $:
        if (showX !== void 0)
          $$invalidate(1, transformControls.showX = showX, transformControls);
    }
    if ($$self.$$.dirty & /*showY*/
    8192) {
      $:
        if (showY !== void 0)
          $$invalidate(1, transformControls.showY = showY, transformControls);
    }
    if ($$self.$$.dirty & /*showZ*/
    16384) {
      $:
        if (showZ !== void 0)
          $$invalidate(1, transformControls.showZ = showZ, transformControls);
    }
    if ($$self.$$.dirty & /*mode, transformControls*/
    130) {
      $:
        if (mode !== void 0)
          transformControls.setMode(mode);
    }
    if ($$self.$$.dirty & /*translationSnap, transformControls*/
    514) {
      $:
        if (translationSnap !== void 0)
          transformControls.setTranslationSnap(translationSnap);
    }
    if ($$self.$$.dirty & /*scaleSnap, transformControls*/
    1026) {
      $:
        if (scaleSnap !== void 0)
          transformControls.setScaleSnap(scaleSnap);
    }
    if ($$self.$$.dirty & /*rotationSnap, transformControls*/
    2050) {
      $:
        if (rotationSnap !== void 0)
          transformControls.setRotationSnap(rotationSnap);
    }
    if ($$self.$$.dirty & /*size, transformControls*/
    32770) {
      $:
        if (size !== void 0)
          transformControls.setSize(size);
    }
    if ($$self.$$.dirty & /*space, transformControls*/
    65538) {
      $:
        if (space2 !== void 0)
          transformControls.setSpace(space2);
    }
  };
  return [
    dispose,
    transformControls,
    camera,
    parent,
    axis,
    dragging,
    autoPauseOrbitControls,
    mode,
    enabled,
    translationSnap,
    scaleSnap,
    rotationSnap,
    showX,
    showY,
    showZ,
    size,
    space2,
    reset
  ];
}
var TransformControls_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      autoPauseOrbitControls: 6,
      mode: 7,
      axis: 4,
      dragging: 5,
      enabled: 8,
      translationSnap: 9,
      scaleSnap: 10,
      rotationSnap: 11,
      showX: 12,
      showY: 13,
      showZ: 14,
      size: 15,
      space: 16,
      dispose: 0,
      reset: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransformControls_1",
      options,
      id: create_fragment18.name
    });
  }
  get autoPauseOrbitControls() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPauseOrbitControls(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mode() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mode(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get axis() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set axis(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enabled() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabled(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationSnap() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translationSnap(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleSnap() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleSnap(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotationSnap() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotationSnap(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showX() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showX(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showY() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showY(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showZ() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showZ(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get space() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set space(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error_14("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reset() {
    return this.$$.ctx[17];
  }
  set reset(value) {
    throw new Error_14("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransformControls_default = TransformControls_1;

// node_modules/@threlte/core/dist/effects/Pass.svelte
function create_fragment19(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pass", slots, []);
  let { pass } = $$props;
  const { addPass, removePass } = useThrelteRoot();
  addPass(pass);
  useFrame(
    () => {
    },
    { debugFrameloopMessage: "Pass component" }
  );
  onDestroy(() => {
    removePass(pass);
  });
  $$self.$$.on_mount.push(function() {
    if (pass === void 0 && !("pass" in $$props || $$self.$$.bound[$$self.$$.props["pass"]])) {
      console.warn("<Pass> was created without expected prop 'pass'");
    }
  });
  const writable_props = ["pass"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Pass> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("pass" in $$props2)
      $$invalidate(0, pass = $$props2.pass);
  };
  $$self.$capture_state = () => ({
    useFrame,
    onDestroy,
    useThrelteRoot,
    pass,
    addPass,
    removePass
  });
  $$self.$inject_state = ($$props2) => {
    if ("pass" in $$props2)
      $$invalidate(0, pass = $$props2.pass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [pass];
}
var Pass2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { pass: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pass",
      options,
      id: create_fragment19.name
    });
  }
  get pass() {
    throw new Error("<Pass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pass(value) {
    throw new Error("<Pass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pass_default = Pass2;

// node_modules/@threlte/core/dist/lib/colors.js
var convertColorRepresentationToColor = (colorRep, linear) => {
  if (linear)
    return new Color(colorRep);
  return new Color().setHex(new Color(colorRep).getHex()).convertSRGBToLinear();
};

// node_modules/@threlte/core/dist/instances/LightInstance.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(32:0) <Object3DInstance   object={light}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {position}   {scale}   {rotation}   {viewportAware}   {visible}   {userData}   {dispose}   on:viewportenter   on:viewportleave   bind:inViewport >",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[19](value);
  }
  let object3dinstance_props = {
    object: (
      /*light*/
      ctx[0]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    userData: (
      /*userData*/
      ctx[12]
    ),
    dispose: (
      /*dispose*/
      ctx[13]
    ),
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[20]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*light*/
      1)
        object3dinstance_changes.object = /*light*/
        ctx2[0];
      if (dirty & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*userData*/
      4096)
        object3dinstance_changes.userData = /*userData*/
        ctx2[12];
      if (dirty & /*dispose*/
      8192)
        object3dinstance_changes.dispose = /*dispose*/
        ctx2[13];
      if (dirty & /*$$scope*/
      4194304) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      2) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let $linear;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightInstance", slots, ["default"]);
  let { light } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  const { invalidate } = useThrelte();
  const { linear } = useThrelteRoot();
  validate_store(linear, "linear");
  component_subscribe($$self, linear, (value) => $$invalidate(17, $linear = value));
  $$self.$$.on_mount.push(function() {
    if (light === void 0 && !("light" in $$props || $$self.$$.bound[$$self.$$.props["light"]])) {
      console.warn("<LightInstance> was created without expected prop 'light'");
    }
  });
  const writable_props = [
    "light",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "color",
    "intensity"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LightInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("light" in $$props2)
      $$invalidate(0, light = $$props2.light);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("color" in $$props2)
      $$invalidate(15, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(16, intensity = $$props2.intensity);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useThrelte,
    useThrelteRoot,
    convertColorRepresentationToColor,
    Object3DInstance: Object3DInstance_default,
    light,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    color,
    intensity,
    invalidate,
    linear,
    $linear
  });
  $$self.$inject_state = ($$props2) => {
    if ("light" in $$props2)
      $$invalidate(0, light = $$props2.light);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("color" in $$props2)
      $$invalidate(15, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(16, intensity = $$props2.intensity);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*intensity, color, $linear*/
    229376) {
      $: {
        if (intensity !== void 0)
          $$invalidate(0, light.intensity = intensity, light);
        if (color !== void 0)
          $$invalidate(0, light.color = convertColorRepresentationToColor(color, $linear), light);
        invalidate("LightInstance: props changed");
      }
    }
  };
  return [
    light,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    linear,
    color,
    intensity,
    $linear,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var LightInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      light: 0,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 1,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      userData: 12,
      dispose: 13,
      color: 15,
      intensity: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightInstance",
      options,
      id: create_fragment20.name
    });
  }
  get light() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LightInstance_default = LightInstance;

// node_modules/@threlte/core/dist/lights/AmbientLight.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(21:0) <LightInstance   {light}   {lookAt}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {color}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let lightinstance;
  let updating_inViewport;
  let current;
  function lightinstance_inViewport_binding(value) {
    ctx[17](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[15]
    ),
    lookAt: (
      /*lookAt*/
      ctx[4]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    userData: (
      /*userData*/
      ctx[10]
    ),
    dispose: (
      /*dispose*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[12]
    ),
    color: (
      /*color*/
      ctx[13]
    ),
    intensity: (
      /*intensity*/
      ctx[14]
    ),
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[18]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[19]
  );
  const block = {
    c: function create() {
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const lightinstance_changes = {};
      if (dirty & /*lookAt*/
      16)
        lightinstance_changes.lookAt = /*lookAt*/
        ctx2[4];
      if (dirty & /*position*/
      2)
        lightinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty & /*scale*/
      4)
        lightinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty & /*rotation*/
      8)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty & /*castShadow*/
      32)
        lightinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty & /*receiveShadow*/
      64)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty & /*frustumCulled*/
      128)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty & /*renderOrder*/
      256)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty & /*visible*/
      512)
        lightinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty & /*userData*/
      1024)
        lightinstance_changes.userData = /*userData*/
        ctx2[10];
      if (dirty & /*dispose*/
      2048)
        lightinstance_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty & /*viewportAware*/
      4096)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[12];
      if (dirty & /*color*/
      8192)
        lightinstance_changes.color = /*color*/
        ctx2[13];
      if (dirty & /*intensity*/
      16384)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[14];
      if (dirty & /*$$scope*/
      1048576) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AmbientLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { color = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  const light = new AmbientLight(color, intensity);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "viewportAware",
    "inViewport",
    "color",
    "intensity"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AmbientLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("viewportAware" in $$props2)
      $$invalidate(12, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("color" in $$props2)
      $$invalidate(13, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(14, intensity = $$props2.intensity);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeAmbientLight: AmbientLight,
    LightInstance: LightInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    viewportAware,
    inViewport,
    color,
    intensity,
    light
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("viewportAware" in $$props2)
      $$invalidate(12, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("color" in $$props2)
      $$invalidate(13, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(14, intensity = $$props2.intensity);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    viewportAware,
    color,
    intensity,
    light,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var AmbientLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      position: 1,
      scale: 2,
      rotation: 3,
      lookAt: 4,
      castShadow: 5,
      receiveShadow: 6,
      frustumCulled: 7,
      renderOrder: 8,
      visible: 9,
      userData: 10,
      dispose: 11,
      viewportAware: 12,
      inViewport: 0,
      color: 13,
      intensity: 14,
      light: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AmbientLight",
      options,
      id: create_fragment21.name
    });
  }
  get position() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[15];
  }
  set light(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AmbientLight_default = AmbientLight2;

// node_modules/@threlte/core/dist/lights/DirectionalLight.svelte
function create_if_block3(ctx) {
  let scenegraphobject;
  let t0;
  let transformableobject;
  let t1;
  let disposableobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: { object: (
      /*originalTarget*/
      ctx[16]
    ) },
    $$inline: true
  });
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*originalTarget*/
        ctx[16]
      ),
      position: (
        /*target*/
        ctx[15]
      )
    },
    $$inline: true
  });
  disposableobject = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[10]
      ),
      object: (
        /*target*/
        ctx[15]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
      t0 = space();
      create_component(transformableobject.$$.fragment);
      t1 = space();
      create_component(disposableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(transformableobject.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(disposableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(transformableobject, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(disposableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const transformableobject_changes = {};
      if (dirty & /*target*/
      32768)
        transformableobject_changes.position = /*target*/
        ctx2[15];
      transformableobject.$set(transformableobject_changes);
      const disposableobject_changes = {};
      if (dirty & /*dispose*/
      1024)
        disposableobject_changes.dispose = /*dispose*/
        ctx2[10];
      if (dirty & /*target*/
      32768)
        disposableobject_changes.object = /*target*/
        ctx2[15];
      disposableobject.$set(disposableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      transition_in(transformableobject.$$.fragment, local);
      transition_in(disposableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      transition_out(transformableobject.$$.fragment, local);
      transition_out(disposableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(transformableobject, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(disposableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(61:0) {#if target && !(target instanceof Object3D)}",
    ctx
  });
  return block;
}
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(67:0) <LightInstance   {light}   {position}   {scale}   {rotation}   castShadow={shadow ? true : false}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {color}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let t;
  let lightinstance;
  let updating_inViewport;
  let current;
  let if_block = (
    /*target*/
    ctx[15] && !/*target*/
    (ctx[15] instanceof Object3D) && create_if_block3(ctx)
  );
  function lightinstance_inViewport_binding(value) {
    ctx[19](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[1]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*shadow*/
      ctx[14] ? true : false
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[5]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[6]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[7]
    ),
    visible: (
      /*visible*/
      ctx[8]
    ),
    userData: (
      /*userData*/
      ctx[9]
    ),
    dispose: (
      /*dispose*/
      ctx[10]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[11]
    ),
    color: (
      /*color*/
      ctx[12]
    ),
    intensity: (
      /*intensity*/
      ctx[13]
    ),
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[20]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[21]
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*target*/
        ctx2[15] && !/*target*/
        (ctx2[15] instanceof Object3D)
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*target*/
          32768) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const lightinstance_changes = {};
      if (dirty & /*light*/
      2)
        lightinstance_changes.light = /*light*/
        ctx2[1];
      if (dirty & /*position*/
      4)
        lightinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        lightinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*shadow*/
      16384)
        lightinstance_changes.castShadow = /*shadow*/
        ctx2[14] ? true : false;
      if (dirty & /*receiveShadow*/
      32)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[5];
      if (dirty & /*frustumCulled*/
      64)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[6];
      if (dirty & /*renderOrder*/
      128)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[7];
      if (dirty & /*visible*/
      256)
        lightinstance_changes.visible = /*visible*/
        ctx2[8];
      if (dirty & /*userData*/
      512)
        lightinstance_changes.userData = /*userData*/
        ctx2[9];
      if (dirty & /*dispose*/
      1024)
        lightinstance_changes.dispose = /*dispose*/
        ctx2[10];
      if (dirty & /*viewportAware*/
      2048)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[11];
      if (dirty & /*color*/
      4096)
        lightinstance_changes.color = /*color*/
        ctx2[12];
      if (dirty & /*intensity*/
      8192)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[13];
      if (dirty & /*$$scope*/
      4194304) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let $started;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DirectionalLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { color = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  let { shadow = void 0 } = $$props;
  let { target = void 0 } = $$props;
  const light = new DirectionalLight(color, intensity);
  const { invalidate } = useThrelte();
  const originalTarget = light.target;
  const { start, stop, started } = useFrame(
    () => {
    },
    {
      autostart: false,
      debugFrameloopMessage: "DirectionalLight: tracking target"
    }
  );
  validate_store(started, "started");
  component_subscribe($$self, started, (value) => $$invalidate(23, $started = value));
  const updateLightTarget = (target2) => {
    if (target2 && target2 instanceof Object3D && !$started) {
      $$invalidate(1, light.target = target2, light);
      start();
      invalidate("DirectionalLight: target changed");
    } else if ((!target2 || !(target2 instanceof Object3D)) && $started) {
      $$invalidate(1, light.target = originalTarget, light);
      stop();
      invalidate("DirectionalLight: target changed");
    }
  };
  const updateLightShadow = (shadow2) => {
    if (shadow2) {
      const { mapSize = [512, 512], camera: { left = -5, bottom = -5, right = 5, top = 5, near = 0.5, far = 500 } = {}, bias = 0, radius = 1 } = shadow2 === true ? {} : shadow2;
      light.shadow.mapSize.set(mapSize[0], mapSize[1]);
      $$invalidate(1, light.shadow.camera.left = left, light);
      $$invalidate(1, light.shadow.camera.top = top, light);
      $$invalidate(1, light.shadow.camera.right = right, light);
      $$invalidate(1, light.shadow.camera.bottom = bottom, light);
      $$invalidate(1, light.shadow.camera.near = near, light);
      $$invalidate(1, light.shadow.camera.far = far, light);
      $$invalidate(1, light.shadow.bias = bias, light);
      $$invalidate(1, light.shadow.radius = radius, light);
    }
    invalidate("DirectionalLight: shadow changed");
  };
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "viewportAware",
    "inViewport",
    "color",
    "intensity",
    "shadow",
    "target"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DirectionalLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("receiveShadow" in $$props2)
      $$invalidate(5, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(6, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(7, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(8, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(9, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(10, dispose = $$props2.dispose);
    if ("viewportAware" in $$props2)
      $$invalidate(11, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("color" in $$props2)
      $$invalidate(12, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(13, intensity = $$props2.intensity);
    if ("shadow" in $$props2)
      $$invalidate(14, shadow = $$props2.shadow);
    if ("target" in $$props2)
      $$invalidate(15, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useFrame,
    ThreeDirectionalLight: DirectionalLight,
    Object3D,
    useThrelte,
    LightInstance: LightInstance_default,
    SceneGraphObject: SceneGraphObject_default,
    TransformableObject: TransformableObject_default,
    DisposableObject: DisposableObject_default,
    position,
    scale,
    rotation,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    viewportAware,
    inViewport,
    color,
    intensity,
    shadow,
    target,
    light,
    invalidate,
    originalTarget,
    start,
    stop,
    started,
    updateLightTarget,
    updateLightShadow,
    $started
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("receiveShadow" in $$props2)
      $$invalidate(5, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(6, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(7, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(8, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(9, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(10, dispose = $$props2.dispose);
    if ("viewportAware" in $$props2)
      $$invalidate(11, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("color" in $$props2)
      $$invalidate(12, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(13, intensity = $$props2.intensity);
    if ("shadow" in $$props2)
      $$invalidate(14, shadow = $$props2.shadow);
    if ("target" in $$props2)
      $$invalidate(15, target = $$props2.target);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*target*/
    32768) {
      $:
        updateLightTarget(target);
    }
    if ($$self.$$.dirty & /*shadow*/
    16384) {
      $:
        updateLightShadow(shadow);
    }
  };
  return [
    inViewport,
    light,
    position,
    scale,
    rotation,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    viewportAware,
    color,
    intensity,
    shadow,
    target,
    originalTarget,
    started,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var DirectionalLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      receiveShadow: 5,
      frustumCulled: 6,
      renderOrder: 7,
      visible: 8,
      userData: 9,
      dispose: 10,
      viewportAware: 11,
      inViewport: 0,
      color: 12,
      intensity: 13,
      shadow: 14,
      target: 15,
      light: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DirectionalLight",
      options,
      id: create_fragment22.name
    });
  }
  get position() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[1];
  }
  set light(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DirectionalLight_default = DirectionalLight2;

// node_modules/@threlte/core/dist/lights/PointLight.svelte
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: "(46:0) <LightInstance   {light}   {lookAt}   {position}   {scale}   {rotation}   castShadow={shadow ? true : false}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {color}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let lightinstance;
  let updating_inViewport;
  let current;
  function lightinstance_inViewport_binding(value) {
    ctx[20](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[0]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*shadow*/
      ctx[15] ? true : false
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    userData: (
      /*userData*/
      ctx[11]
    ),
    dispose: (
      /*dispose*/
      ctx[12]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[7]
    ),
    color: (
      /*color*/
      ctx[14]
    ),
    intensity: (
      /*intensity*/
      ctx[13]
    ),
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[21]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[22]
  );
  const block = {
    c: function create() {
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const lightinstance_changes = {};
      if (dirty & /*light*/
      1)
        lightinstance_changes.light = /*light*/
        ctx2[0];
      if (dirty & /*lookAt*/
      32)
        lightinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*position*/
      4)
        lightinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        lightinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*shadow*/
      32768)
        lightinstance_changes.castShadow = /*shadow*/
        ctx2[15] ? true : false;
      if (dirty & /*receiveShadow*/
      64)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty & /*frustumCulled*/
      256)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        lightinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*userData*/
      2048)
        lightinstance_changes.userData = /*userData*/
        ctx2[11];
      if (dirty & /*dispose*/
      4096)
        lightinstance_changes.dispose = /*dispose*/
        ctx2[12];
      if (dirty & /*viewportAware*/
      128)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[7];
      if (dirty & /*color*/
      16384)
        lightinstance_changes.color = /*color*/
        ctx2[14];
      if (dirty & /*intensity*/
      8192)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[13];
      if (dirty & /*$$scope*/
      8388608) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      2) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PointLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { distance = void 0 } = $$props;
  let { decay = void 0 } = $$props;
  let { power = void 0 } = $$props;
  let { shadow = void 0 } = $$props;
  const light = new PointLight(color, intensity, distance, decay);
  const { invalidate } = useThrelte();
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "receiveShadow",
    "viewportAware",
    "inViewport",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "intensity",
    "color",
    "distance",
    "decay",
    "power",
    "shadow"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PointLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("viewportAware" in $$props2)
      $$invalidate(7, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("intensity" in $$props2)
      $$invalidate(13, intensity = $$props2.intensity);
    if ("color" in $$props2)
      $$invalidate(14, color = $$props2.color);
    if ("distance" in $$props2)
      $$invalidate(16, distance = $$props2.distance);
    if ("decay" in $$props2)
      $$invalidate(17, decay = $$props2.decay);
    if ("power" in $$props2)
      $$invalidate(18, power = $$props2.power);
    if ("shadow" in $$props2)
      $$invalidate(15, shadow = $$props2.shadow);
    if ("$$scope" in $$props2)
      $$invalidate(23, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreePointLight: PointLight,
    useThrelte,
    LightInstance: LightInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    receiveShadow,
    viewportAware,
    inViewport,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    intensity,
    color,
    distance,
    decay,
    power,
    shadow,
    light,
    invalidate
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("viewportAware" in $$props2)
      $$invalidate(7, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("intensity" in $$props2)
      $$invalidate(13, intensity = $$props2.intensity);
    if ("color" in $$props2)
      $$invalidate(14, color = $$props2.color);
    if ("distance" in $$props2)
      $$invalidate(16, distance = $$props2.distance);
    if ("decay" in $$props2)
      $$invalidate(17, decay = $$props2.decay);
    if ("power" in $$props2)
      $$invalidate(18, power = $$props2.power);
    if ("shadow" in $$props2)
      $$invalidate(15, shadow = $$props2.shadow);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*distance, decay, power*/
    458752) {
      $: {
        if (distance !== void 0)
          $$invalidate(0, light.distance = distance, light);
        if (decay !== void 0)
          $$invalidate(0, light.decay = decay, light);
        if (power !== void 0)
          $$invalidate(0, light.power = power, light);
        invalidate("PointLight: props changed");
      }
    }
    if ($$self.$$.dirty & /*shadow, light*/
    32769) {
      $: {
        if (shadow) {
          const { mapSize = [512, 512], camera: { near = 0.5, far = 500 } = {}, bias = 0, radius = 1 } = shadow === true ? {} : shadow;
          light.shadow.mapSize.set(mapSize[0], mapSize[1]);
          $$invalidate(0, light.shadow.camera.near = near, light);
          $$invalidate(0, light.shadow.camera.far = far, light);
          $$invalidate(0, light.shadow.bias = bias, light);
          $$invalidate(0, light.shadow.radius = radius, light);
        }
        invalidate("PointLight: shadow changed");
      }
    }
  };
  return [
    light,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    receiveShadow,
    viewportAware,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    intensity,
    color,
    shadow,
    distance,
    decay,
    power,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var PointLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      receiveShadow: 6,
      viewportAware: 7,
      inViewport: 1,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      userData: 11,
      dispose: 12,
      intensity: 13,
      color: 14,
      distance: 16,
      decay: 17,
      power: 18,
      shadow: 15,
      light: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PointLight",
      options,
      id: create_fragment23.name
    });
  }
  get position() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distance() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distance(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decay() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decay(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get power() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set power(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[0];
  }
  set light(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PointLight_default = PointLight2;

// node_modules/@threlte/core/dist/lights/HemisphereLight.svelte
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: "(33:0) <LightInstance   {light}   {lookAt}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   color={skyColor}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let lightinstance;
  let updating_inViewport;
  let current;
  function lightinstance_inViewport_binding(value) {
    ctx[20](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[1]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    userData: (
      /*userData*/
      ctx[12]
    ),
    dispose: (
      /*dispose*/
      ctx[13]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[8]
    ),
    color: (
      /*skyColor*/
      ctx[15]
    ),
    intensity: (
      /*intensity*/
      ctx[14]
    ),
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[21]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[22]
  );
  const block = {
    c: function create() {
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const lightinstance_changes = {};
      if (dirty & /*light*/
      2)
        lightinstance_changes.light = /*light*/
        ctx2[1];
      if (dirty & /*lookAt*/
      32)
        lightinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*position*/
      4)
        lightinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        lightinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      64)
        lightinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*frustumCulled*/
      512)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*visible*/
      2048)
        lightinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*userData*/
      4096)
        lightinstance_changes.userData = /*userData*/
        ctx2[12];
      if (dirty & /*dispose*/
      8192)
        lightinstance_changes.dispose = /*dispose*/
        ctx2[13];
      if (dirty & /*viewportAware*/
      256)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[8];
      if (dirty & /*skyColor*/
      32768)
        lightinstance_changes.color = /*skyColor*/
        ctx2[15];
      if (dirty & /*intensity*/
      16384)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[14];
      if (dirty & /*$$scope*/
      8388608) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let $linear;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HemisphereLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  let { skyColor = void 0 } = $$props;
  let { groundColor = void 0 } = $$props;
  const light = new HemisphereLight(skyColor, groundColor, intensity);
  const { invalidate } = useThrelte();
  const { linear } = useThrelteRoot();
  validate_store(linear, "linear");
  component_subscribe($$self, linear, (value) => $$invalidate(18, $linear = value));
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "castShadow",
    "receiveShadow",
    "viewportAware",
    "inViewport",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "intensity",
    "skyColor",
    "groundColor"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HemisphereLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("intensity" in $$props2)
      $$invalidate(14, intensity = $$props2.intensity);
    if ("skyColor" in $$props2)
      $$invalidate(15, skyColor = $$props2.skyColor);
    if ("groundColor" in $$props2)
      $$invalidate(17, groundColor = $$props2.groundColor);
    if ("$$scope" in $$props2)
      $$invalidate(23, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeHemisphereLight: HemisphereLight,
    useThrelte,
    useThrelteRoot,
    LightInstance: LightInstance_default,
    convertColorRepresentationToColor,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    viewportAware,
    inViewport,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    intensity,
    skyColor,
    groundColor,
    light,
    invalidate,
    linear,
    $linear
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("intensity" in $$props2)
      $$invalidate(14, intensity = $$props2.intensity);
    if ("skyColor" in $$props2)
      $$invalidate(15, skyColor = $$props2.skyColor);
    if ("groundColor" in $$props2)
      $$invalidate(17, groundColor = $$props2.groundColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*groundColor, $linear*/
    393216) {
      $: {
        if (groundColor !== void 0) {
          $$invalidate(1, light.groundColor = convertColorRepresentationToColor(groundColor, $linear), light);
          invalidate("HemisphereLight: props changed");
        }
      }
    }
  };
  return [
    inViewport,
    light,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    viewportAware,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    intensity,
    skyColor,
    linear,
    groundColor,
    $linear,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var HemisphereLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      castShadow: 6,
      receiveShadow: 7,
      viewportAware: 8,
      inViewport: 0,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      userData: 12,
      dispose: 13,
      intensity: 14,
      skyColor: 15,
      groundColor: 17,
      light: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HemisphereLight",
      options,
      id: create_fragment24.name
    });
  }
  get position() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skyColor() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skyColor(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groundColor() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groundColor(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[1];
  }
  set light(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HemisphereLight_default = HemisphereLight2;

// node_modules/@threlte/core/dist/lights/SpotLight.svelte
function create_if_block4(ctx) {
  let scenegraphobject;
  let t;
  let transformableobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: { object: (
      /*originalTarget*/
      ctx[16]
    ) },
    $$inline: true
  });
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*originalTarget*/
        ctx[16]
      ),
      position: (
        /*target*/
        ctx[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
      t = space();
      create_component(transformableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(transformableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(transformableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const transformableobject_changes = {};
      if (dirty[0] & /*target*/
      16384)
        transformableobject_changes.position = /*target*/
        ctx2[14];
      transformableobject.$set(transformableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      transition_in(transformableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      transition_out(transformableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(transformableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(76:0) {#if target && !(target instanceof Object3D)}",
    ctx
  });
  return block;
}
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: "(81:0) <LightInstance   {light}   {position}   {scale}   {rotation}   castShadow={shadow ? true : false}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {color}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let t;
  let lightinstance;
  let updating_inViewport;
  let current;
  let if_block = (
    /*target*/
    ctx[14] && !/*target*/
    (ctx[14] instanceof Object3D) && create_if_block4(ctx)
  );
  function lightinstance_inViewport_binding(value) {
    ctx[24](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[1]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*shadow*/
      ctx[15] ? true : false
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[6]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    userData: (
      /*userData*/
      ctx[10]
    ),
    dispose: (
      /*dispose*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    color: (
      /*color*/
      ctx[12]
    ),
    intensity: (
      /*intensity*/
      ctx[13]
    ),
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[25]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[26]
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*target*/
        ctx2[14] && !/*target*/
        (ctx2[14] instanceof Object3D)
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*target*/
          16384) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const lightinstance_changes = {};
      if (dirty[0] & /*light*/
      2)
        lightinstance_changes.light = /*light*/
        ctx2[1];
      if (dirty[0] & /*position*/
      4)
        lightinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty[0] & /*scale*/
      8)
        lightinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty[0] & /*rotation*/
      16)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty[0] & /*shadow*/
      32768)
        lightinstance_changes.castShadow = /*shadow*/
        ctx2[15] ? true : false;
      if (dirty[0] & /*receiveShadow*/
      128)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty[0] & /*frustumCulled*/
      64)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[6];
      if (dirty[0] & /*renderOrder*/
      256)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        lightinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*userData*/
      1024)
        lightinstance_changes.userData = /*userData*/
        ctx2[10];
      if (dirty[0] & /*dispose*/
      2048)
        lightinstance_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*viewportAware*/
      32)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty[0] & /*color*/
      4096)
        lightinstance_changes.color = /*color*/
        ctx2[12];
      if (dirty[0] & /*intensity*/
      8192)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[13];
      if (dirty[0] & /*$$scope*/
      134217728) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let $started;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SpotLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  let { angle = void 0 } = $$props;
  let { decay = void 0 } = $$props;
  let { distance = void 0 } = $$props;
  let { penumbra = void 0 } = $$props;
  let { power = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { shadow = void 0 } = $$props;
  const { invalidate } = useThrelte();
  const light = new SpotLight(color, intensity);
  const originalTarget = light.target;
  const { start, stop, started } = useFrame(
    () => {
    },
    {
      autostart: false,
      debugFrameloopMessage: "SpotLight: tracking target"
    }
  );
  validate_store(started, "started");
  component_subscribe($$self, started, (value) => $$invalidate(28, $started = value));
  const updateLightTarget = (target2) => {
    if (target2 && target2 instanceof Object3D && !$started) {
      $$invalidate(1, light.target = target2, light);
      start();
      invalidate("SpotLight: target changed");
    } else if ((!target2 || !(target2 instanceof Object3D)) && $started) {
      $$invalidate(1, light.target = originalTarget, light);
      stop();
      invalidate("SpotLight: target changed");
    }
  };
  const updateLightShadow = (shadow2) => {
    if (shadow2) {
      const { mapSize = [512, 512], camera: { near = 0.5, far = 500 } = {}, bias = 0, radius = 1 } = shadow2 === true ? {} : shadow2;
      light.shadow.mapSize.set(mapSize[0], mapSize[1]);
      $$invalidate(1, light.shadow.camera.near = near, light);
      $$invalidate(1, light.shadow.camera.far = far, light);
      $$invalidate(1, light.shadow.bias = bias, light);
      $$invalidate(1, light.shadow.radius = radius, light);
    }
    invalidate("SpotLight: shadow changed");
  };
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "frustumCulled",
    "receiveShadow",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "color",
    "intensity",
    "angle",
    "decay",
    "distance",
    "penumbra",
    "power",
    "target",
    "shadow"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SpotLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(6, frustumCulled = $$props2.frustumCulled);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("color" in $$props2)
      $$invalidate(12, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(13, intensity = $$props2.intensity);
    if ("angle" in $$props2)
      $$invalidate(18, angle = $$props2.angle);
    if ("decay" in $$props2)
      $$invalidate(19, decay = $$props2.decay);
    if ("distance" in $$props2)
      $$invalidate(20, distance = $$props2.distance);
    if ("penumbra" in $$props2)
      $$invalidate(21, penumbra = $$props2.penumbra);
    if ("power" in $$props2)
      $$invalidate(22, power = $$props2.power);
    if ("target" in $$props2)
      $$invalidate(14, target = $$props2.target);
    if ("shadow" in $$props2)
      $$invalidate(15, shadow = $$props2.shadow);
    if ("$$scope" in $$props2)
      $$invalidate(27, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Object3D,
    ThreeSpotLight: SpotLight,
    useFrame,
    useThrelte,
    LightInstance: LightInstance_default,
    SceneGraphObject: SceneGraphObject_default,
    TransformableObject: TransformableObject_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    frustumCulled,
    receiveShadow,
    renderOrder,
    visible,
    userData,
    dispose,
    color,
    intensity,
    angle,
    decay,
    distance,
    penumbra,
    power,
    target,
    shadow,
    invalidate,
    light,
    originalTarget,
    start,
    stop,
    started,
    updateLightTarget,
    updateLightShadow,
    $started
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(6, frustumCulled = $$props2.frustumCulled);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("color" in $$props2)
      $$invalidate(12, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(13, intensity = $$props2.intensity);
    if ("angle" in $$props2)
      $$invalidate(18, angle = $$props2.angle);
    if ("decay" in $$props2)
      $$invalidate(19, decay = $$props2.decay);
    if ("distance" in $$props2)
      $$invalidate(20, distance = $$props2.distance);
    if ("penumbra" in $$props2)
      $$invalidate(21, penumbra = $$props2.penumbra);
    if ("power" in $$props2)
      $$invalidate(22, power = $$props2.power);
    if ("target" in $$props2)
      $$invalidate(14, target = $$props2.target);
    if ("shadow" in $$props2)
      $$invalidate(15, shadow = $$props2.shadow);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*target*/
    16384) {
      $:
        updateLightTarget(target);
    }
    if ($$self.$$.dirty[0] & /*shadow*/
    32768) {
      $:
        updateLightShadow(shadow);
    }
    if ($$self.$$.dirty[0] & /*distance, decay, angle, penumbra, power*/
    8126464) {
      $: {
        if (distance !== void 0)
          $$invalidate(1, light.distance = distance, light);
        if (decay !== void 0)
          $$invalidate(1, light.decay = decay, light);
        if (angle !== void 0)
          $$invalidate(1, light.angle = angle, light);
        if (penumbra !== void 0)
          $$invalidate(1, light.penumbra = penumbra, light);
        if (power !== void 0)
          $$invalidate(1, light.power = power, light);
        invalidate("SpotLight: props changed");
      }
    }
  };
  return [
    inViewport,
    light,
    position,
    scale,
    rotation,
    viewportAware,
    frustumCulled,
    receiveShadow,
    renderOrder,
    visible,
    userData,
    dispose,
    color,
    intensity,
    target,
    shadow,
    originalTarget,
    started,
    angle,
    decay,
    distance,
    penumbra,
    power,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var SpotLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance25,
      create_fragment25,
      safe_not_equal,
      {
        position: 2,
        scale: 3,
        rotation: 4,
        viewportAware: 5,
        inViewport: 0,
        frustumCulled: 6,
        receiveShadow: 7,
        renderOrder: 8,
        visible: 9,
        userData: 10,
        dispose: 11,
        color: 12,
        intensity: 13,
        angle: 18,
        decay: 19,
        distance: 20,
        penumbra: 21,
        power: 22,
        target: 14,
        shadow: 15,
        light: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SpotLight",
      options,
      id: create_fragment25.name
    });
  }
  get position() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angle() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angle(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decay() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decay(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distance() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distance(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get penumbra() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set penumbra(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get power() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set power(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[1];
  }
  set light(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SpotLight_default = SpotLight2;

// node_modules/@threlte/core/dist/misc/Fog.svelte
function create_fragment26(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let $linear;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fog", slots, []);
  let { color = 16777215 } = $$props;
  let { near = void 0 } = $$props;
  let { far = void 0 } = $$props;
  const { linear } = useThrelteRoot();
  validate_store(linear, "linear");
  component_subscribe($$self, linear, (value) => $$invalidate(5, $linear = value));
  const { scene, invalidate } = useThrelte();
  const fog = new Fog(convertColorRepresentationToColor(color, $linear), near, far);
  scene.fog = fog;
  invalidate("Fog: added");
  onDestroy(() => {
    scene.fog = null;
    invalidate("Fog: removed");
  });
  const writable_props = ["color", "near", "far"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Fog> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("near" in $$props2)
      $$invalidate(3, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(4, far = $$props2.far);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    ThreeFog: Fog,
    useThrelte,
    useThrelteRoot,
    convertColorRepresentationToColor,
    color,
    near,
    far,
    linear,
    scene,
    invalidate,
    fog,
    $linear
  });
  $$self.$inject_state = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("near" in $$props2)
      $$invalidate(3, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(4, far = $$props2.far);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, $linear, near, far*/
    60) {
      $: {
        if (color !== void 0)
          $$invalidate(1, fog.color = convertColorRepresentationToColor(color, $linear), fog);
        if (near !== void 0)
          $$invalidate(1, fog.near = near, fog);
        if (far !== void 0)
          $$invalidate(1, fog.far = far, fog);
        invalidate("Fog: props changed");
      }
    }
  };
  return [linear, fog, color, near, far, $linear];
}
var Fog2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { color: 2, near: 3, far: 4, fog: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fog",
      options,
      id: create_fragment26.name
    });
  }
  get color() {
    throw new Error("<Fog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Fog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get near() {
    throw new Error("<Fog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set near(value) {
    throw new Error("<Fog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get far() {
    throw new Error("<Fog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set far(value) {
    throw new Error("<Fog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fog() {
    return this.$$.ctx[1];
  }
  set fog(value) {
    throw new Error("<Fog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Fog_default = Fog2;

// node_modules/@threlte/core/dist/misc/FogExp2.svelte
function create_fragment27(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let $linear;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FogExp2", slots, []);
  let { color = 16777215 } = $$props;
  let { density = void 0 } = $$props;
  const { linear } = useThrelteRoot();
  validate_store(linear, "linear");
  component_subscribe($$self, linear, (value) => $$invalidate(4, $linear = value));
  const { scene, invalidate } = useThrelte();
  const fog = new FogExp2(convertColorRepresentationToColor(color, $linear), density);
  scene.fog = fog;
  invalidate("FogExp2: added");
  onDestroy(() => {
    scene.fog = null;
    invalidate("FogExp2: removed");
  });
  const writable_props = ["color", "density"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FogExp2> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("density" in $$props2)
      $$invalidate(3, density = $$props2.density);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    ThreeFogExp2: FogExp2,
    useThrelte,
    useThrelteRoot,
    convertColorRepresentationToColor,
    color,
    density,
    linear,
    scene,
    invalidate,
    fog,
    $linear
  });
  $$self.$inject_state = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("density" in $$props2)
      $$invalidate(3, density = $$props2.density);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, $linear, density*/
    28) {
      $: {
        $$invalidate(1, fog.color = convertColorRepresentationToColor(color, $linear), fog);
        if (density !== void 0)
          $$invalidate(1, fog.density = density, fog);
        invalidate("FogExp2: props changed");
      }
    }
  };
  return [linear, fog, color, density, $linear];
}
var FogExp22 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { color: 2, density: 3, fog: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FogExp2",
      options,
      id: create_fragment27.name
    });
  }
  get color() {
    throw new Error("<FogExp2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<FogExp2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get density() {
    throw new Error("<FogExp2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set density(value) {
    throw new Error("<FogExp2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fog() {
    return this.$$.ctx[1];
  }
  set fog(value) {
    throw new Error("<FogExp2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FogExp2_default = FogExp22;

// node_modules/@threlte/core/dist/misc/Layers.svelte
function create_fragment28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Layers", slots, ["default"]);
  let { layers } = $$props;
  const layerStore = writable(layers);
  setContext("threlte-layers", layerStore);
  $$self.$$.on_mount.push(function() {
    if (layers === void 0 && !("layers" in $$props || $$self.$$.bound[$$self.$$.props["layers"]])) {
      console.warn("<Layers> was created without expected prop 'layers'");
    }
  });
  const writable_props = ["layers"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Layers> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("layers" in $$props2)
      $$invalidate(0, layers = $$props2.layers);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ setContext, writable, layers, layerStore });
  $$self.$inject_state = ($$props2) => {
    if ("layers" in $$props2)
      $$invalidate(0, layers = $$props2.layers);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*layers*/
    1) {
      $:
        layerStore.set(layers);
    }
  };
  return [layers, $$scope, slots];
}
var Layers = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, { layers: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Layers",
      options,
      id: create_fragment28.name
    });
  }
  get layers() {
    throw new Error("<Layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set layers(value) {
    throw new Error("<Layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Layers_default = Layers;

// node_modules/@threlte/core/dist/misc/ContextBridge.svelte
function create_fragment29(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextBridge", slots, []);
  const ctx = useThrelte();
  const rootCtx = useThrelteRoot();
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ContextBridge> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ useThrelte, useThrelteRoot, ctx, rootCtx });
  return [ctx, rootCtx];
}
var ContextBridge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, { ctx: 0, rootCtx: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextBridge",
      options,
      id: create_fragment29.name
    });
  }
  get ctx() {
    return this.$$.ctx[0];
  }
  set ctx(value) {
    throw new Error("<ContextBridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootCtx() {
    return this.$$.ctx[1];
  }
  set rootCtx(value) {
    throw new Error("<ContextBridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextBridge_default = ContextBridge;

// node_modules/@threlte/core/dist/internal/InteractiveObject.svelte
function create_fragment30(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InteractiveObject", slots, []);
  let { object } = $$props;
  let previousObject = object;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  const eventDispatcher = createEventDispatcher();
  const { addInteractiveObject, removeInteractiveObject, addRaycastableObject, removeRaycastableObject } = useThrelteRoot();
  const { invalidate } = useThrelte();
  const removeObjectInteractivity = (object2) => {
    removeRaycastableObject(object2);
    removeInteractiveObject(object2);
    delete getThrelteUserData(object2).eventDispatcher;
  };
  const setupObjectInteractivity = (object2, ignorePointer2, interactive2) => {
    getThrelteUserData(object2).eventDispatcher = eventDispatcher;
    if (ignorePointer2) {
      removeRaycastableObject(object2);
      removeInteractiveObject(object2);
    } else {
      addRaycastableObject(object2);
      if (interactive2) {
        addInteractiveObject(object2);
      } else {
        removeInteractiveObject(object2);
      }
    }
  };
  onDestroy(() => {
    removeObjectInteractivity(object);
    invalidate("InteractiveObject: object removed");
  });
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<InteractiveObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object", "interactive", "ignorePointer"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InteractiveObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(0, object = $$props2.object);
    if ("interactive" in $$props2)
      $$invalidate(1, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(2, ignorePointer = $$props2.ignorePointer);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    useThrelte,
    useThrelteRoot,
    getThrelteUserData,
    object,
    previousObject,
    interactive,
    ignorePointer,
    eventDispatcher,
    addInteractiveObject,
    removeInteractiveObject,
    addRaycastableObject,
    removeRaycastableObject,
    invalidate,
    removeObjectInteractivity,
    setupObjectInteractivity
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(0, object = $$props2.object);
    if ("previousObject" in $$props2)
      $$invalidate(3, previousObject = $$props2.previousObject);
    if ("interactive" in $$props2)
      $$invalidate(1, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(2, ignorePointer = $$props2.ignorePointer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*object, previousObject, ignorePointer, interactive*/
    15) {
      $: {
        if (object !== previousObject) {
          removeObjectInteractivity(previousObject);
          setupObjectInteractivity(object, ignorePointer, interactive);
          invalidate("InteractiveObject: object changed");
          $$invalidate(3, previousObject = object);
        } else if (object === previousObject) {
          setupObjectInteractivity(object, ignorePointer, interactive);
          invalidate("InteractiveObject: props changed");
        }
      }
    }
  };
  return [object, interactive, ignorePointer, previousObject];
}
var InteractiveObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      object: 0,
      interactive: 1,
      ignorePointer: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InteractiveObject",
      options,
      id: create_fragment30.name
    });
  }
  get object() {
    throw new Error("<InteractiveObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<InteractiveObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<InteractiveObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<InteractiveObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<InteractiveObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<InteractiveObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InteractiveObject_default = InteractiveObject;

// node_modules/@threlte/core/dist/instances/MeshInstance.svelte
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: "(21:0) <Object3DInstance   object={mesh}   {lookAt}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {viewportAware}   on:viewportenter   on:viewportleave   bind:inViewport >",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let t;
  let interactiveobject;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[17](value);
  }
  let object3dinstance_props = {
    object: (
      /*mesh*/
      ctx[1]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    userData: (
      /*userData*/
      ctx[12]
    ),
    dispose: (
      /*dispose*/
      ctx[13]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[18]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[19]
  );
  interactiveobject = new InteractiveObject_default({
    props: {
      object: (
        /*mesh*/
        ctx[1]
      ),
      interactive: (
        /*interactive*/
        ctx[14]
      ),
      ignorePointer: (
        /*ignorePointer*/
        ctx[15]
      )
    },
    $$inline: true
  });
  interactiveobject.$on(
    "click",
    /*click_handler*/
    ctx[20]
  );
  interactiveobject.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[21]
  );
  interactiveobject.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[22]
  );
  interactiveobject.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[23]
  );
  interactiveobject.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[24]
  );
  interactiveobject.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[25]
  );
  interactiveobject.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[26]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
      t = space();
      create_component(interactiveobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(interactiveobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(interactiveobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*mesh*/
      2)
        object3dinstance_changes.object = /*mesh*/
        ctx2[1];
      if (dirty & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*userData*/
      4096)
        object3dinstance_changes.userData = /*userData*/
        ctx2[12];
      if (dirty & /*dispose*/
      8192)
        object3dinstance_changes.dispose = /*dispose*/
        ctx2[13];
      if (dirty & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*$$scope*/
      134217728) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
      const interactiveobject_changes = {};
      if (dirty & /*mesh*/
      2)
        interactiveobject_changes.object = /*mesh*/
        ctx2[1];
      if (dirty & /*interactive*/
      16384)
        interactiveobject_changes.interactive = /*interactive*/
        ctx2[14];
      if (dirty & /*ignorePointer*/
      32768)
        interactiveobject_changes.ignorePointer = /*ignorePointer*/
        ctx2[15];
      interactiveobject.$set(interactiveobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      transition_in(interactiveobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      transition_out(interactiveobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(interactiveobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MeshInstance", slots, ["default"]);
  let { mesh } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (mesh === void 0 && !("mesh" in $$props || $$self.$$.bound[$$self.$$.props["mesh"]])) {
      console.warn("<MeshInstance> was created without expected prop 'mesh'");
    }
  });
  const writable_props = [
    "mesh",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "interactive",
    "ignorePointer"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MeshInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("mesh" in $$props2)
      $$invalidate(1, mesh = $$props2.mesh);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(14, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(15, ignorePointer = $$props2.ignorePointer);
    if ("$$scope" in $$props2)
      $$invalidate(27, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    InteractiveObject: InteractiveObject_default,
    Object3DInstance: Object3DInstance_default,
    mesh,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer
  });
  $$self.$inject_state = ($$props2) => {
    if ("mesh" in $$props2)
      $$invalidate(1, mesh = $$props2.mesh);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(14, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(15, ignorePointer = $$props2.ignorePointer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    mesh,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    $$scope
  ];
}
var MeshInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      mesh: 1,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 0,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      userData: 12,
      dispose: 13,
      interactive: 14,
      ignorePointer: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MeshInstance",
      options,
      id: create_fragment31.name
    });
  }
  get mesh() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mesh(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MeshInstance_default = MeshInstance;

// node_modules/@threlte/core/dist/objects/Mesh.svelte
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: "(54:0) <MeshInstance   {mesh}   {position}   {scale}   {rotation}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {interactive}   {ignorePointer}   {userData}   {dispose}   on:click   on:contextmenu   on:pointerup   on:pointerdown   on:pointerenter   on:pointerleave   on:pointermove   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let disposableobject0;
  let t0;
  let disposableobject1;
  let t1;
  let meshinstance;
  let updating_inViewport;
  let current;
  disposableobject0 = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[11]
      ),
      object: (
        /*geometry*/
        ctx[15]
      )
    },
    $$inline: true
  });
  disposableobject1 = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[11]
      ),
      object: (
        /*material*/
        ctx[16]
      )
    },
    $$inline: true
  });
  function meshinstance_inViewport_binding(value) {
    ctx[21](value);
  }
  let meshinstance_props = {
    mesh: (
      /*mesh*/
      ctx[17]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[14]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    interactive: (
      /*interactive*/
      ctx[12]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[13]
    ),
    userData: (
      /*userData*/
      ctx[10]
    ),
    dispose: (
      /*dispose*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    ),
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    meshinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  meshinstance = new MeshInstance_default({
    props: meshinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(meshinstance, "inViewport", meshinstance_inViewport_binding));
  meshinstance.$on(
    "click",
    /*click_handler*/
    ctx[22]
  );
  meshinstance.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[23]
  );
  meshinstance.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[24]
  );
  meshinstance.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[25]
  );
  meshinstance.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[26]
  );
  meshinstance.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[27]
  );
  meshinstance.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[28]
  );
  meshinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[29]
  );
  meshinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[30]
  );
  const block = {
    c: function create() {
      create_component(disposableobject0.$$.fragment);
      t0 = space();
      create_component(disposableobject1.$$.fragment);
      t1 = space();
      create_component(meshinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(disposableobject1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(meshinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(disposableobject1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(meshinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject0_changes = {};
      if (dirty[0] & /*dispose*/
      2048)
        disposableobject0_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*geometry*/
      32768)
        disposableobject0_changes.object = /*geometry*/
        ctx2[15];
      disposableobject0.$set(disposableobject0_changes);
      const disposableobject1_changes = {};
      if (dirty[0] & /*dispose*/
      2048)
        disposableobject1_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*material*/
      65536)
        disposableobject1_changes.object = /*material*/
        ctx2[16];
      disposableobject1.$set(disposableobject1_changes);
      const meshinstance_changes = {};
      if (dirty[0] & /*position*/
      2)
        meshinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        meshinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        meshinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*lookAt*/
      16384)
        meshinstance_changes.lookAt = /*lookAt*/
        ctx2[14];
      if (dirty[0] & /*castShadow*/
      32)
        meshinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        meshinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*frustumCulled*/
      128)
        meshinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty[0] & /*renderOrder*/
      256)
        meshinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        meshinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*interactive*/
      4096)
        meshinstance_changes.interactive = /*interactive*/
        ctx2[12];
      if (dirty[0] & /*ignorePointer*/
      8192)
        meshinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[13];
      if (dirty[0] & /*userData*/
      1024)
        meshinstance_changes.userData = /*userData*/
        ctx2[10];
      if (dirty[0] & /*dispose*/
      2048)
        meshinstance_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*viewportAware*/
      16)
        meshinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (dirty[1] & /*$$scope*/
      1) {
        meshinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        meshinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      meshinstance.$set(meshinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject0.$$.fragment, local);
      transition_in(disposableobject1.$$.fragment, local);
      transition_in(meshinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject0.$$.fragment, local);
      transition_out(disposableobject1.$$.fragment, local);
      transition_out(meshinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(disposableobject1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(meshinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Mesh", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { geometry } = $$props;
  let { material } = $$props;
  let previousMaterial = material;
  let previousGeometry = geometry;
  const { invalidate } = useThrelte();
  const mesh = new Mesh(geometry, material);
  const getMesh = () => mesh;
  $$self.$$.on_mount.push(function() {
    if (geometry === void 0 && !("geometry" in $$props || $$self.$$.bound[$$self.$$.props["geometry"]])) {
      console.warn("<Mesh> was created without expected prop 'geometry'");
    }
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console.warn("<Mesh> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "interactive",
    "ignorePointer",
    "lookAt",
    "geometry",
    "material"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Mesh> was created with unknown prop '${key}'`);
  });
  function meshinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(14, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(15, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(16, material = $$props2.material);
    if ("$$scope" in $$props2)
      $$invalidate(31, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeMesh: Mesh,
    useThrelte,
    MeshInstance: MeshInstance_default,
    DisposableObject: DisposableObject_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    previousMaterial,
    previousGeometry,
    invalidate,
    mesh,
    getMesh
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(14, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(15, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(16, material = $$props2.material);
    if ("previousMaterial" in $$props2)
      $$invalidate(18, previousMaterial = $$props2.previousMaterial);
    if ("previousGeometry" in $$props2)
      $$invalidate(19, previousGeometry = $$props2.previousGeometry);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*material, previousMaterial*/
    327680) {
      $: {
        if (material !== previousMaterial) {
          getMesh().material = material;
          invalidate("Mesh: material changed");
        } else {
          invalidate("Mesh: material props changed");
        }
        $$invalidate(18, previousMaterial = material);
      }
    }
    if ($$self.$$.dirty[0] & /*geometry, previousGeometry*/
    557056) {
      $: {
        if (geometry !== previousGeometry) {
          getMesh().geometry = geometry;
          invalidate("Mesh: geometry changed");
        } else {
          invalidate("Mesh: geometry props changed");
        }
        $$invalidate(19, previousGeometry = geometry);
      }
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    mesh,
    previousMaterial,
    previousGeometry,
    slots,
    meshinstance_inViewport_binding,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Mesh2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance32,
      create_fragment32,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        frustumCulled: 7,
        renderOrder: 8,
        visible: 9,
        userData: 10,
        dispose: 11,
        interactive: 12,
        ignorePointer: 13,
        lookAt: 14,
        geometry: 15,
        material: 16,
        mesh: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mesh",
      options,
      id: create_fragment32.name
    });
  }
  get position() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mesh() {
    return this.$$.ctx[17];
  }
  set mesh(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Mesh_default = Mesh2;

// node_modules/@threlte/core/dist/lib/usePropChange.js
var usePropChange = (prop, equalityFn) => {
  let oldValue = prop;
  const onChange = (newValue, callback) => {
    if (equalityFn && !equalityFn(newValue, oldValue)) {
      callback(newValue, oldValue);
      oldValue = newValue;
    } else if (!equalityFn && newValue !== oldValue) {
      callback(newValue, oldValue);
      oldValue = newValue;
    }
  };
  return {
    onChange
  };
};

// node_modules/@threlte/core/dist/objects/InstancedMesh.svelte
var { console: console_13 } = globals;
function create_key_block(ctx) {
  let meshinstance;
  let updating_inViewport;
  let current;
  function meshinstance_inViewport_binding(value) {
    ctx[24](value);
  }
  let meshinstance_props = {
    mesh: (
      /*$instancedMesh*/
      ctx[17]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: void 0,
    renderOrder: (
      /*renderOrder*/
      ctx[7]
    ),
    visible: (
      /*visible*/
      ctx[8]
    ),
    userData: (
      /*userData*/
      ctx[9]
    ),
    dispose: (
      /*dispose*/
      ctx[10]
    ),
    interactive: (
      /*interactive*/
      ctx[11]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[12]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    )
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    meshinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  meshinstance = new MeshInstance_default({
    props: meshinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(meshinstance, "inViewport", meshinstance_inViewport_binding));
  meshinstance.$on(
    "click",
    /*onEvent*/
    ctx[20]
  );
  meshinstance.$on(
    "contextmenu",
    /*onEvent*/
    ctx[20]
  );
  meshinstance.$on(
    "pointerup",
    /*onEvent*/
    ctx[20]
  );
  meshinstance.$on(
    "pointerdown",
    /*onEvent*/
    ctx[20]
  );
  meshinstance.$on(
    "pointerenter",
    /*onEvent*/
    ctx[20]
  );
  meshinstance.$on(
    "pointerleave",
    /*onEvent*/
    ctx[20]
  );
  meshinstance.$on(
    "pointermove",
    /*onEvent*/
    ctx[20]
  );
  meshinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[25]
  );
  meshinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[26]
  );
  const block = {
    c: function create() {
      create_component(meshinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(meshinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(meshinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const meshinstance_changes = {};
      if (dirty[0] & /*$instancedMesh*/
      131072)
        meshinstance_changes.mesh = /*$instancedMesh*/
        ctx2[17];
      if (dirty[0] & /*castShadow*/
      32)
        meshinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        meshinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*renderOrder*/
      128)
        meshinstance_changes.renderOrder = /*renderOrder*/
        ctx2[7];
      if (dirty[0] & /*visible*/
      256)
        meshinstance_changes.visible = /*visible*/
        ctx2[8];
      if (dirty[0] & /*userData*/
      512)
        meshinstance_changes.userData = /*userData*/
        ctx2[9];
      if (dirty[0] & /*dispose*/
      1024)
        meshinstance_changes.dispose = /*dispose*/
        ctx2[10];
      if (dirty[0] & /*interactive*/
      2048)
        meshinstance_changes.interactive = /*interactive*/
        ctx2[11];
      if (dirty[0] & /*ignorePointer*/
      4096)
        meshinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[12];
      if (dirty[0] & /*viewportAware*/
      16)
        meshinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        meshinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      meshinstance.$set(meshinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(meshinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(meshinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(meshinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(188:2) {#key $instancedMesh.uuid}",
    ctx
  });
  return block;
}
function create_default_slot19(ctx) {
  let previous_key = (
    /*$instancedMesh*/
    ctx[17].uuid
  );
  let t;
  let current;
  let key_block = create_key_block(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      key_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$instancedMesh*/
      131072 && safe_not_equal(previous_key, previous_key = /*$instancedMesh*/
      ctx2[17].uuid)) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(t.parentNode, t);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      key_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: "(187:0) <Object3DInstance object={parentObject} {position} {scale} {rotation} {lookAt}>",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let disposableobject0;
  let t0;
  let disposableobject1;
  let t1;
  let object3dinstance;
  let current;
  disposableobject0 = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[10]
      ),
      object: (
        /*geometry*/
        ctx[14]
      )
    },
    $$inline: true
  });
  disposableobject1 = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[10]
      ),
      object: (
        /*material*/
        ctx[15]
      )
    },
    $$inline: true
  });
  object3dinstance = new Object3DInstance_default({
    props: {
      object: (
        /*parentObject*/
        ctx[18]
      ),
      position: (
        /*position*/
        ctx[1]
      ),
      scale: (
        /*scale*/
        ctx[2]
      ),
      rotation: (
        /*rotation*/
        ctx[3]
      ),
      lookAt: (
        /*lookAt*/
        ctx[13]
      ),
      $$slots: { default: [create_default_slot19] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(disposableobject0.$$.fragment);
      t0 = space();
      create_component(disposableobject1.$$.fragment);
      t1 = space();
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(disposableobject1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(disposableobject1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject0_changes = {};
      if (dirty[0] & /*dispose*/
      1024)
        disposableobject0_changes.dispose = /*dispose*/
        ctx2[10];
      if (dirty[0] & /*geometry*/
      16384)
        disposableobject0_changes.object = /*geometry*/
        ctx2[14];
      disposableobject0.$set(disposableobject0_changes);
      const disposableobject1_changes = {};
      if (dirty[0] & /*dispose*/
      1024)
        disposableobject1_changes.dispose = /*dispose*/
        ctx2[10];
      if (dirty[0] & /*material*/
      32768)
        disposableobject1_changes.object = /*material*/
        ctx2[15];
      disposableobject1.$set(disposableobject1_changes);
      const object3dinstance_changes = {};
      if (dirty[0] & /*position*/
      2)
        object3dinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        object3dinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*lookAt*/
      8192)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[13];
      if (dirty[0] & /*$$scope, $instancedMesh, castShadow, receiveShadow, renderOrder, visible, userData, dispose, interactive, ignorePointer, viewportAware, inViewport*/
      134356977) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject0.$$.fragment, local);
      transition_in(disposableobject1.$$.fragment, local);
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject0.$$.fragment, local);
      transition_out(disposableobject1.$$.fragment, local);
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(disposableobject1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var placeholderObject3D = new Object3D();
placeholderObject3D.scale.set(0, 0, 0);
var placeholderInstance = {
  matrix: placeholderObject3D.matrix,
  color: null
};
var emptyM4 = new Matrix4().fromArray(new Array(16).fill(0));
var defaultColor = new Color(16777215);
var instancedMeshContextName = "threlte-instanced-mesh-context";
var useInstancedMesh = (id) => {
  return getContext(instancedMeshContextName + id);
};
function instance33($$self, $$props, $$invalidate) {
  let $instancedMesh, $$unsubscribe_instancedMesh = noop, $$subscribe_instancedMesh = () => ($$unsubscribe_instancedMesh(), $$unsubscribe_instancedMesh = subscribe(instancedMesh, ($$value) => $$invalidate(17, $instancedMesh = $$value)), instancedMesh);
  let $instanceCountChangeHandlerQueued;
  $$self.$$.on_destroy.push(() => $$unsubscribe_instancedMesh());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InstancedMesh", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { geometry } = $$props;
  let { material } = $$props;
  let { count = void 0 } = $$props;
  let { id = "" } = $$props;
  const { onChange } = usePropChange(material);
  const autoCount = (count2) => count2 === void 0;
  const instancedMesh = writable(new InstancedMesh(geometry, material, autoCount(count) ? 0 : count));
  validate_store(instancedMesh, "instancedMesh");
  $$subscribe_instancedMesh();
  const parentObject = new Object3D();
  const instances = [];
  const { invalidate } = useThrelte();
  const useInstanceIndex = (instance42, callback) => {
    const index = instances.findIndex((i) => i === instance42);
    if (index === -1) {
      console.warn("Instanced Mesh: Instance not found");
      return;
    }
    callback(index);
  };
  const { start: queueHandleInstanceCountChange, stop, started: instanceCountChangeHandlerQueued } = useFrame(
    () => {
      $instancedMesh.dispose();
      set_store_value(instancedMesh, $instancedMesh = new InstancedMesh(geometry, material, instances.length), $instancedMesh);
      instances.forEach((instance42, index) => {
        setInstanceMatrixByIndex(instance42, index);
        if (instance42.color) {
          $instancedMesh.setColorAt(index, instance42.color);
        } else {
          $instancedMesh.setColorAt(index, defaultColor);
        }
      });
      set_store_value(instancedMesh, $instancedMesh.instanceMatrix.needsUpdate = true, $instancedMesh);
      if ($instancedMesh.instanceColor) {
        set_store_value(instancedMesh, $instancedMesh.instanceColor.needsUpdate = true, $instancedMesh);
      }
      stop();
    },
    {
      autostart: false,
      debugFrameloopMessage: "Instanced Mesh: auto instance count change queued"
    }
  );
  validate_store(instanceCountChangeHandlerQueued, "instanceCountChangeHandlerQueued");
  component_subscribe($$self, instanceCountChangeHandlerQueued, (value) => $$invalidate(29, $instanceCountChangeHandlerQueued = value));
  const registerInstance = (instance42) => {
    if (autoCount(count)) {
      instances.push(instance42);
      if (!$instanceCountChangeHandlerQueued)
        queueHandleInstanceCountChange();
    } else {
      const firstPlaceholderInstanceIndex = instances.findIndex((i) => i === placeholderInstance);
      if (firstPlaceholderInstanceIndex !== -1) {
        instances[firstPlaceholderInstanceIndex] = instance42;
      } else {
        instances.push(instance42);
      }
      if (instances.length > count) {
        console.warn("Instanced Mesh: More instances requested than allocated, increase count on <");
      }
    }
    setDefaultInstanceColor(instance42);
    invalidate("Instanced Mesh: Instance added");
  };
  const removeInstance = (instance42) => {
    if (autoCount(count)) {
      const index = instances.findIndex((i) => i === instance42);
      instances.splice(index, 1);
      if (!$instanceCountChangeHandlerQueued)
        queueHandleInstanceCountChange();
    } else {
      resetInstanceMatrix(instance42);
      const index = instances.findIndex((i) => i === instance42);
      if (index >= count) {
        instances.splice(index, 1);
      } else {
        instances.splice(index, 1, placeholderInstance);
      }
    }
    invalidate("Instanced Mesh: Instance removed");
  };
  const setDefaultInstanceColor = (instance42) => {
    if (instance42.color)
      return;
    useInstanceIndex(instance42, (index) => {
      $instancedMesh.setColorAt(index, defaultColor);
      if ($instancedMesh.instanceColor)
        set_store_value(instancedMesh, $instancedMesh.instanceColor.needsUpdate = true, $instancedMesh);
    });
  };
  const resetInstanceMatrix = (instance42) => {
    useInstanceIndex(instance42, (index) => {
      $instancedMesh.setMatrixAt(index, emptyM4);
      set_store_value(instancedMesh, $instancedMesh.instanceMatrix.needsUpdate = true, $instancedMesh);
      invalidate("Instanced Mesh: instance matrix resetted");
    });
  };
  const setInstanceMatrixByIndex = (instance42, index) => {
    $instancedMesh.setMatrixAt(index, instance42.matrix);
    set_store_value(instancedMesh, $instancedMesh.instanceMatrix.needsUpdate = true, $instancedMesh);
    invalidate("Instanced Mesh: instance matrix set");
  };
  const setInstanceMatrix = (instance42) => {
    useInstanceIndex(instance42, (index) => {
      setInstanceMatrixByIndex(instance42, index);
    });
  };
  const setInstanceColor = (instance42) => {
    useInstanceIndex(instance42, (index) => {
      $instancedMesh.setColorAt(index, instance42.color ?? defaultColor);
      if ($instancedMesh.instanceColor)
        set_store_value(instancedMesh, $instancedMesh.instanceColor.needsUpdate = true, $instancedMesh);
      invalidate("Instanced Mesh: instance color set");
    });
  };
  setContext(instancedMeshContextName + id, {
    registerInstance,
    removeInstance,
    setInstanceMatrix,
    setInstanceColor,
    parentObject
  });
  const onEvent = (e) => {
    if (e.detail.instanceId === void 0)
      return;
    const instance42 = instances[e.detail.instanceId];
    if (instance42 && instance42.pointerEventDispatcher) {
      instance42.pointerEventDispatcher(e.type, e.detail);
    }
  };
  $$self.$$.on_mount.push(function() {
    if (geometry === void 0 && !("geometry" in $$props || $$self.$$.bound[$$self.$$.props["geometry"]])) {
      console_13.warn("<InstancedMesh> was created without expected prop 'geometry'");
    }
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console_13.warn("<InstancedMesh> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "interactive",
    "ignorePointer",
    "lookAt",
    "geometry",
    "material",
    "count",
    "id"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_13.warn(`<InstancedMesh> was created with unknown prop '${key}'`);
  });
  function meshinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("renderOrder" in $$props2)
      $$invalidate(7, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(8, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(9, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(10, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(11, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(12, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(13, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(14, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(15, material = $$props2.material);
    if ("count" in $$props2)
      $$invalidate(21, count = $$props2.count);
    if ("id" in $$props2)
      $$invalidate(22, id = $$props2.id);
    if ("$$scope" in $$props2)
      $$invalidate(27, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    Color,
    ThreeInstancedMesh: InstancedMesh,
    Matrix4,
    Object3D,
    useThrelte,
    useFrame,
    MeshInstance: MeshInstance_default,
    usePropChange,
    Object3DInstance: Object3DInstance_default,
    writable,
    placeholderObject3D,
    placeholderInstance,
    emptyM4,
    defaultColor,
    instancedMeshContextName,
    useInstancedMesh,
    DisposableObject: DisposableObject_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    count,
    id,
    onChange,
    autoCount,
    instancedMesh,
    parentObject,
    instances,
    invalidate,
    useInstanceIndex,
    queueHandleInstanceCountChange,
    stop,
    instanceCountChangeHandlerQueued,
    registerInstance,
    removeInstance,
    setDefaultInstanceColor,
    resetInstanceMatrix,
    setInstanceMatrixByIndex,
    setInstanceMatrix,
    setInstanceColor,
    onEvent,
    $instancedMesh,
    $instanceCountChangeHandlerQueued
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("renderOrder" in $$props2)
      $$invalidate(7, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(8, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(9, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(10, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(11, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(12, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(13, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(14, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(15, material = $$props2.material);
    if ("count" in $$props2)
      $$invalidate(21, count = $$props2.count);
    if ("id" in $$props2)
      $$invalidate(22, id = $$props2.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*material*/
    32768) {
      $:
        onChange(material, (newMaterial) => {
          set_store_value(instancedMesh, $instancedMesh.material = newMaterial, $instancedMesh);
        });
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    instancedMesh,
    $instancedMesh,
    parentObject,
    instanceCountChangeHandlerQueued,
    onEvent,
    count,
    id,
    slots,
    meshinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var InstancedMesh2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance33,
      create_fragment33,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        renderOrder: 7,
        visible: 8,
        userData: 9,
        dispose: 10,
        interactive: 11,
        ignorePointer: 12,
        lookAt: 13,
        geometry: 14,
        material: 15,
        count: 21,
        id: 22,
        instancedMesh: 16
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InstancedMesh",
      options,
      id: create_fragment33.name
    });
  }
  get position() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instancedMesh() {
    return this.$$.ctx[16];
  }
  set instancedMesh(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InstancedMesh_default = InstancedMesh2;

// node_modules/@threlte/core/dist/objects/Instance.svelte
function create_default_slot20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: "(85:0) <SceneGraphObject object={object3d}>",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let scenegraphobject;
  let t;
  let transformableobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*object3d*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot20] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*object3d*/
        ctx[4]
      ),
      position: (
        /*position*/
        ctx[0]
      ),
      scale: (
        /*scale*/
        ctx[1]
      ),
      rotation: (
        /*rotation*/
        ctx[2]
      ),
      lookAt: (
        /*lookAt*/
        ctx[3]
      )
    },
    $$inline: true
  });
  transformableobject.$on(
    "transform",
    /*onTransform*/
    ctx[5]
  );
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
      t = space();
      create_component(transformableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(transformableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(transformableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const scenegraphobject_changes = {};
      if (dirty & /*$$scope*/
      512) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
      const transformableobject_changes = {};
      if (dirty & /*position*/
      1)
        transformableobject_changes.position = /*position*/
        ctx2[0];
      if (dirty & /*scale*/
      2)
        transformableobject_changes.scale = /*scale*/
        ctx2[1];
      if (dirty & /*rotation*/
      4)
        transformableobject_changes.rotation = /*rotation*/
        ctx2[2];
      if (dirty & /*lookAt*/
      8)
        transformableobject_changes.lookAt = /*lookAt*/
        ctx2[3];
      transformableobject.$set(transformableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      transition_in(transformableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      transition_out(transformableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(transformableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Instance", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { id = "" } = $$props;
  const { registerInstance, setInstanceMatrix, removeInstance, setInstanceColor, parentObject } = useInstancedMesh(id);
  const object3d = new Object3D();
  const m4 = new Matrix4();
  const pointerEventDispatcher = createEventDispatcher();
  const isDirectChild = () => {
    var _a;
    return parentObject.uuid === ((_a = object3d.parent) == null ? void 0 : _a.uuid);
  };
  const parseColor = (color2) => {
    return color2 !== void 0 ? color2 instanceof Color ? color2 : new Color(color2) : null;
  };
  const instance42 = {
    color: parseColor(color),
    matrix: object3d.matrix,
    pointerEventDispatcher
  };
  const setColor = (color2) => {
    instance42.color = parseColor(color2);
    setInstanceColor(instance42);
  };
  const prepareNonDirectChildMatrix = () => {
    let currentObj = object3d.parent;
    const interjacentObjects = [];
    while (currentObj && parentObject && currentObj.uuid !== parentObject.uuid) {
      interjacentObjects.push(currentObj);
      if (!currentObj.parent)
        break;
      currentObj = currentObj.parent;
    }
    object3d.updateMatrix();
    m4.copy(object3d.matrix);
    interjacentObjects.forEach((obj) => {
      obj.updateMatrix();
      m4.premultiply(obj.matrix);
    });
    instance42.matrix = m4;
  };
  const prepareDirectChildMatrix = () => {
    object3d.updateMatrix();
    instance42.matrix = object3d.matrix;
  };
  const setDirectChildInstanceTransform = () => {
    prepareDirectChildMatrix();
    setInstanceMatrix(instance42);
  };
  const { start: trackNonDirectChildInstanceTransform } = useFrame(
    () => {
      prepareNonDirectChildMatrix();
      setInstanceMatrix(instance42);
    },
    {
      autostart: false,
      debugFrameloopMessage: "Instance: tracking non-direct child instance"
    }
  );
  registerInstance(instance42);
  onMount(() => {
    if (isDirectChild())
      setDirectChildInstanceTransform();
    else
      trackNonDirectChildInstanceTransform();
    setColor(color);
  });
  const onTransform = () => {
    if (isDirectChild())
      setDirectChildInstanceTransform();
  };
  onDestroy(() => {
    removeInstance(instance42);
  });
  const writable_props = ["position", "scale", "rotation", "lookAt", "color", "id"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Instance> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(1, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(2, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(3, lookAt = $$props2.lookAt);
    if ("color" in $$props2)
      $$invalidate(6, color = $$props2.color);
    if ("id" in $$props2)
      $$invalidate(7, id = $$props2.id);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    onMount,
    Color,
    Matrix4,
    Object3D,
    useFrame,
    SceneGraphObject: SceneGraphObject_default,
    TransformableObject: TransformableObject_default,
    useInstancedMesh,
    position,
    scale,
    rotation,
    lookAt,
    color,
    id,
    registerInstance,
    setInstanceMatrix,
    removeInstance,
    setInstanceColor,
    parentObject,
    object3d,
    m4,
    pointerEventDispatcher,
    isDirectChild,
    parseColor,
    instance: instance42,
    setColor,
    prepareNonDirectChildMatrix,
    prepareDirectChildMatrix,
    setDirectChildInstanceTransform,
    trackNonDirectChildInstanceTransform,
    onTransform
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(1, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(2, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(3, lookAt = $$props2.lookAt);
    if ("color" in $$props2)
      $$invalidate(6, color = $$props2.color);
    if ("id" in $$props2)
      $$invalidate(7, id = $$props2.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color*/
    64) {
      $:
        setColor(color);
    }
  };
  return [
    position,
    scale,
    rotation,
    lookAt,
    object3d,
    onTransform,
    color,
    id,
    slots,
    $$scope
  ];
}
var Instance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment34, safe_not_equal, {
      position: 0,
      scale: 1,
      rotation: 2,
      lookAt: 3,
      color: 6,
      id: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Instance",
      options,
      id: create_fragment34.name
    });
  }
  get position() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Instance_default = Instance;

// node_modules/@threlte/core/dist/objects/Group.svelte
function create_default_slot21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: "(19:0) <Object3DInstance   object={group}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {castShadow}   {receiveShadow}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[15](value);
  }
  let object3dinstance_props = {
    object: (
      /*group*/
      ctx[13]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[4]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    userData: (
      /*userData*/
      ctx[11]
    ),
    dispose: (
      /*dispose*/
      ctx[12]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[16]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[17]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*position*/
      2)
        object3dinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty & /*scale*/
      4)
        object3dinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty & /*rotation*/
      8)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty & /*lookAt*/
      16)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[4];
      if (dirty & /*frustumCulled*/
      256)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        object3dinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*userData*/
      2048)
        object3dinstance_changes.userData = /*userData*/
        ctx2[11];
      if (dirty & /*dispose*/
      4096)
        object3dinstance_changes.dispose = /*dispose*/
        ctx2[12];
      if (dirty & /*castShadow*/
      64)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*viewportAware*/
      32)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty & /*$$scope*/
      262144) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Group", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  const group = new Group();
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Group> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeGroup: Group,
    Object3DInstance: Object3DInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    group
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    group,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Group2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment35, safe_not_equal, {
      position: 1,
      scale: 2,
      rotation: 3,
      lookAt: 4,
      viewportAware: 5,
      inViewport: 0,
      castShadow: 6,
      receiveShadow: 7,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      userData: 11,
      dispose: 12,
      group: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Group",
      options,
      id: create_fragment35.name
    });
  }
  get position() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    return this.$$.ctx[13];
  }
  set group(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Group_default = Group2;

// node_modules/@threlte/core/dist/objects/Object3D.svelte
function create_default_slot22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: "(20:0) <Object3DInstance   {object}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {castShadow}   {receiveShadow}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[15](value);
  }
  let object3dinstance_props = {
    object: (
      /*object*/
      ctx[13]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[4]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    userData: (
      /*userData*/
      ctx[11]
    ),
    dispose: (
      /*dispose*/
      ctx[12]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[16]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[17]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*position*/
      2)
        object3dinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty & /*scale*/
      4)
        object3dinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty & /*rotation*/
      8)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty & /*lookAt*/
      16)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[4];
      if (dirty & /*frustumCulled*/
      256)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        object3dinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*userData*/
      2048)
        object3dinstance_changes.userData = /*userData*/
        ctx2[11];
      if (dirty & /*dispose*/
      4096)
        object3dinstance_changes.dispose = /*dispose*/
        ctx2[12];
      if (dirty & /*castShadow*/
      64)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*viewportAware*/
      32)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty & /*$$scope*/
      262144) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Object3D", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  const object = new Object3D();
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Object3D> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeObject3D: Object3D,
    Object3DInstance: Object3DInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    object
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    object,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Object3D2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment36, safe_not_equal, {
      position: 1,
      scale: 2,
      rotation: 3,
      lookAt: 4,
      viewportAware: 5,
      inViewport: 0,
      castShadow: 6,
      receiveShadow: 7,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      userData: 11,
      dispose: 12,
      object: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Object3D",
      options,
      id: create_fragment36.name
    });
  }
  get position() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get object() {
    return this.$$.ctx[13];
  }
  set object(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Object3D_default = Object3D2;

// node_modules/@threlte/core/dist/instances/LineInstance.svelte
function create_default_slot23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: "(21:0) <Object3DInstance   object={line}   {lookAt}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {viewportAware}   on:viewportenter   on:viewportleave   bind:inViewport >",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let t;
  let interactiveobject;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[17](value);
  }
  let object3dinstance_props = {
    object: (
      /*line*/
      ctx[1]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    userData: (
      /*userData*/
      ctx[12]
    ),
    dispose: (
      /*dispose*/
      ctx[13]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[18]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[19]
  );
  interactiveobject = new InteractiveObject_default({
    props: {
      object: (
        /*line*/
        ctx[1]
      ),
      interactive: (
        /*interactive*/
        ctx[14]
      ),
      ignorePointer: (
        /*ignorePointer*/
        ctx[15]
      )
    },
    $$inline: true
  });
  interactiveobject.$on(
    "click",
    /*click_handler*/
    ctx[20]
  );
  interactiveobject.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[21]
  );
  interactiveobject.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[22]
  );
  interactiveobject.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[23]
  );
  interactiveobject.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[24]
  );
  interactiveobject.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[25]
  );
  interactiveobject.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[26]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
      t = space();
      create_component(interactiveobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(interactiveobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(interactiveobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*line*/
      2)
        object3dinstance_changes.object = /*line*/
        ctx2[1];
      if (dirty & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*userData*/
      4096)
        object3dinstance_changes.userData = /*userData*/
        ctx2[12];
      if (dirty & /*dispose*/
      8192)
        object3dinstance_changes.dispose = /*dispose*/
        ctx2[13];
      if (dirty & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*$$scope*/
      134217728) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
      const interactiveobject_changes = {};
      if (dirty & /*line*/
      2)
        interactiveobject_changes.object = /*line*/
        ctx2[1];
      if (dirty & /*interactive*/
      16384)
        interactiveobject_changes.interactive = /*interactive*/
        ctx2[14];
      if (dirty & /*ignorePointer*/
      32768)
        interactiveobject_changes.ignorePointer = /*ignorePointer*/
        ctx2[15];
      interactiveobject.$set(interactiveobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      transition_in(interactiveobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      transition_out(interactiveobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(interactiveobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineInstance", slots, ["default"]);
  let { line } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (line === void 0 && !("line" in $$props || $$self.$$.bound[$$self.$$.props["line"]])) {
      console.warn("<LineInstance> was created without expected prop 'line'");
    }
  });
  const writable_props = [
    "line",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "interactive",
    "ignorePointer"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LineInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("line" in $$props2)
      $$invalidate(1, line = $$props2.line);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(14, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(15, ignorePointer = $$props2.ignorePointer);
    if ("$$scope" in $$props2)
      $$invalidate(27, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    InteractiveObject: InteractiveObject_default,
    Object3DInstance: Object3DInstance_default,
    line,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer
  });
  $$self.$inject_state = ($$props2) => {
    if ("line" in $$props2)
      $$invalidate(1, line = $$props2.line);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(12, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(13, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(14, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(15, ignorePointer = $$props2.ignorePointer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    line,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    $$scope
  ];
}
var LineInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment37, safe_not_equal, {
      line: 1,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 0,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      userData: 12,
      dispose: 13,
      interactive: 14,
      ignorePointer: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineInstance",
      options,
      id: create_fragment37.name
    });
  }
  get line() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set line(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineInstance_default = LineInstance;

// node_modules/@threlte/core/dist/objects/Line.svelte
function create_default_slot24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[34],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[34],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[34]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[34],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot24.name,
    type: "slot",
    source: "(83:0) <LineInstance   {line}   {position}   {scale}   {rotation}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {interactive}   {ignorePointer}   on:click   on:contextmenu   on:pointerup   on:pointerdown   on:pointerenter   on:pointerleave   on:pointermove   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let disposableobject0;
  let t0;
  let disposableobject1;
  let t1;
  let disposableobject2;
  let t2;
  let lineinstance;
  let updating_inViewport;
  let current;
  disposableobject0 = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[11]
      ),
      object: (
        /*geometry*/
        ctx[15]
      )
    },
    $$inline: true
  });
  disposableobject1 = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[11]
      ),
      object: (
        /*material*/
        ctx[16]
      )
    },
    $$inline: true
  });
  disposableobject2 = new DisposableObject_default({
    props: {
      dispose: true,
      object: (
        /*tempGeometry*/
        ctx[18]
      )
    },
    $$inline: true
  });
  function lineinstance_inViewport_binding(value) {
    ctx[24](value);
  }
  let lineinstance_props = {
    line: (
      /*line*/
      ctx[17]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[14]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    userData: (
      /*userData*/
      ctx[10]
    ),
    dispose: (
      /*dispose*/
      ctx[11]
    ),
    interactive: (
      /*interactive*/
      ctx[12]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[13]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    ),
    $$slots: { default: [create_default_slot24] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lineinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lineinstance = new LineInstance_default({
    props: lineinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lineinstance, "inViewport", lineinstance_inViewport_binding));
  lineinstance.$on(
    "click",
    /*click_handler*/
    ctx[25]
  );
  lineinstance.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[26]
  );
  lineinstance.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[27]
  );
  lineinstance.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[28]
  );
  lineinstance.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[29]
  );
  lineinstance.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[30]
  );
  lineinstance.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[31]
  );
  lineinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[32]
  );
  lineinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[33]
  );
  const block = {
    c: function create() {
      create_component(disposableobject0.$$.fragment);
      t0 = space();
      create_component(disposableobject1.$$.fragment);
      t1 = space();
      create_component(disposableobject2.$$.fragment);
      t2 = space();
      create_component(lineinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(disposableobject1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(disposableobject2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(lineinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(disposableobject1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(disposableobject2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(lineinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject0_changes = {};
      if (dirty[0] & /*dispose*/
      2048)
        disposableobject0_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*geometry*/
      32768)
        disposableobject0_changes.object = /*geometry*/
        ctx2[15];
      disposableobject0.$set(disposableobject0_changes);
      const disposableobject1_changes = {};
      if (dirty[0] & /*dispose*/
      2048)
        disposableobject1_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*material*/
      65536)
        disposableobject1_changes.object = /*material*/
        ctx2[16];
      disposableobject1.$set(disposableobject1_changes);
      const lineinstance_changes = {};
      if (dirty[0] & /*position*/
      2)
        lineinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        lineinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        lineinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*lookAt*/
      16384)
        lineinstance_changes.lookAt = /*lookAt*/
        ctx2[14];
      if (dirty[0] & /*castShadow*/
      32)
        lineinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        lineinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*frustumCulled*/
      128)
        lineinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty[0] & /*renderOrder*/
      256)
        lineinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        lineinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*userData*/
      1024)
        lineinstance_changes.userData = /*userData*/
        ctx2[10];
      if (dirty[0] & /*dispose*/
      2048)
        lineinstance_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*interactive*/
      4096)
        lineinstance_changes.interactive = /*interactive*/
        ctx2[12];
      if (dirty[0] & /*ignorePointer*/
      8192)
        lineinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[13];
      if (dirty[0] & /*viewportAware*/
      16)
        lineinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (dirty[1] & /*$$scope*/
      8) {
        lineinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        lineinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lineinstance.$set(lineinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject0.$$.fragment, local);
      transition_in(disposableobject1.$$.fragment, local);
      transition_in(disposableobject2.$$.fragment, local);
      transition_in(lineinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject0.$$.fragment, local);
      transition_out(disposableobject1.$$.fragment, local);
      transition_out(disposableobject2.$$.fragment, local);
      transition_out(lineinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(disposableobject1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(disposableobject2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(lineinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { points = [] } = $$props;
  let { material } = $$props;
  let previousMaterial = material;
  let previousGeometry = geometry;
  let previousPoints = points;
  const tempGeometry = new BufferGeometry();
  const { invalidate } = useThrelte();
  const maybeSetGeometryFromPoints = (points2) => {
    if (!points2)
      return;
    const v3Array = points2.map((p) => p instanceof Vector3 ? p : new Vector3().fromArray(p));
    tempGeometry.setFromPoints(v3Array);
  };
  const useGeometry = (geometry2) => !!geometry2;
  if (!geometry) {
    maybeSetGeometryFromPoints(points);
  }
  const line = new Line(useGeometry(geometry) ? geometry : tempGeometry, material);
  const getLine = () => line;
  $$self.$$.on_mount.push(function() {
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console.warn("<Line> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "interactive",
    "ignorePointer",
    "lookAt",
    "geometry",
    "points",
    "material"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Line> was created with unknown prop '${key}'`);
  });
  function lineinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(14, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(15, geometry = $$props2.geometry);
    if ("points" in $$props2)
      $$invalidate(19, points = $$props2.points);
    if ("material" in $$props2)
      $$invalidate(16, material = $$props2.material);
    if ("$$scope" in $$props2)
      $$invalidate(34, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    BufferGeometry,
    ThreeLine: Line,
    Vector3,
    useThrelte,
    LineInstance: LineInstance_default,
    DisposableObject: DisposableObject_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    points,
    material,
    previousMaterial,
    previousGeometry,
    previousPoints,
    tempGeometry,
    invalidate,
    maybeSetGeometryFromPoints,
    useGeometry,
    line,
    getLine
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(14, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(15, geometry = $$props2.geometry);
    if ("points" in $$props2)
      $$invalidate(19, points = $$props2.points);
    if ("material" in $$props2)
      $$invalidate(16, material = $$props2.material);
    if ("previousMaterial" in $$props2)
      $$invalidate(20, previousMaterial = $$props2.previousMaterial);
    if ("previousGeometry" in $$props2)
      $$invalidate(21, previousGeometry = $$props2.previousGeometry);
    if ("previousPoints" in $$props2)
      $$invalidate(22, previousPoints = $$props2.previousPoints);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*material, previousMaterial*/
    1114112) {
      $: {
        if (material !== previousMaterial) {
          getLine().material = material;
          invalidate("Line: material changed");
        } else {
          invalidate("Line: material props changed");
        }
        $$invalidate(20, previousMaterial = material);
      }
    }
    if ($$self.$$.dirty[0] & /*geometry, previousGeometry*/
    2129920) {
      $: {
        if (geometry !== previousGeometry) {
          if (useGeometry(geometry)) {
            getLine().geometry = geometry;
            invalidate("Line: geometry changed");
          }
        } else {
          if (useGeometry(geometry)) {
            invalidate("Line: geometry props changed");
          }
        }
        $$invalidate(21, previousGeometry = geometry);
      }
    }
    if ($$self.$$.dirty[0] & /*previousPoints, points, geometry*/
    4751360) {
      $: {
        if (previousPoints !== points) {
          if (!geometry) {
            maybeSetGeometryFromPoints(points);
            getLine().geometry = tempGeometry;
          }
          $$invalidate(22, previousPoints = points);
        }
      }
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    line,
    tempGeometry,
    points,
    previousMaterial,
    previousGeometry,
    previousPoints,
    slots,
    lineinstance_inViewport_binding,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Line2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance37,
      create_fragment38,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        frustumCulled: 7,
        renderOrder: 8,
        visible: 9,
        userData: 10,
        dispose: 11,
        interactive: 12,
        ignorePointer: 13,
        lookAt: 14,
        geometry: 15,
        points: 19,
        material: 16,
        line: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line",
      options,
      id: create_fragment38.name
    });
  }
  get position() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get points() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set points(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get line() {
    return this.$$.ctx[17];
  }
  set line(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Line_default = Line2;

// node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector = new Vector3();
var LineSegmentsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.isLineSegmentsGeometry = true;
    this.type = "LineSegmentsGeometry";
    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(index);
    this.setAttribute("position", new Float32BufferAttribute(positions, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  applyMatrix4(matrix) {
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0) {
      start.applyMatrix4(matrix);
      end.applyMatrix4(matrix);
      start.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  setPositions(array) {
    let lineSegments;
    if (array instanceof Float32Array) {
      lineSegments = array;
    } else if (Array.isArray(array)) {
      lineSegments = new Float32Array(array);
    }
    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);
    this.setAttribute("instanceStart", new InterleavedBufferAttribute(instanceBuffer, 3, 0));
    this.setAttribute("instanceEnd", new InterleavedBufferAttribute(instanceBuffer, 3, 3));
    this.computeBoundingBox();
    this.computeBoundingSphere();
    return this;
  }
  setColors(array) {
    let colors;
    if (array instanceof Float32Array) {
      colors = array;
    } else if (Array.isArray(array)) {
      colors = new Float32Array(array);
    }
    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);
    this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(instanceColorBuffer, 3, 0));
    this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(instanceColorBuffer, 3, 3));
    return this;
  }
  fromWireframeGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromEdgesGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromMesh(mesh) {
    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));
    return this;
  }
  fromLineSegments(lineSegments) {
    const geometry = lineSegments.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      this.boundingBox.setFromBufferAttribute(start);
      _box.setFromBufferAttribute(end);
      this.boundingBox.union(_box);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (this.boundingBox === null) {
      this.computeBoundingBox();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      const center = this.boundingSphere.center;
      this.boundingBox.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = start.count; i < il; i++) {
        _vector.fromBufferAttribute(start, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
        _vector.fromBufferAttribute(end, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
  }
  toJSON() {
  }
  applyMatrix(matrix) {
    console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
    return this.applyMatrix4(matrix);
  }
};

// node_modules/three/examples/jsm/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var LineMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
      vertexShader: ShaderLib["line"].vertexShader,
      fragmentShader: ShaderLib["line"].fragmentShader,
      clipping: true
      // required for clipping support
    });
    this.isLineMaterial = true;
    Object.defineProperties(this, {
      color: {
        enumerable: true,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(value) {
          this.uniforms.diffuse.value = value;
        }
      },
      worldUnits: {
        enumerable: true,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(value) {
          if (value === true) {
            this.defines.WORLD_UNITS = "";
          } else {
            delete this.defines.WORLD_UNITS;
          }
        }
      },
      linewidth: {
        enumerable: true,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(value) {
          this.uniforms.linewidth.value = value;
        }
      },
      dashed: {
        enumerable: true,
        get: function() {
          return Boolean("USE_DASH" in this.defines);
        },
        set(value) {
          if (Boolean(value) !== Boolean("USE_DASH" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_DASH = "";
          } else {
            delete this.defines.USE_DASH;
          }
        }
      },
      dashScale: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(value) {
          this.uniforms.dashScale.value = value;
        }
      },
      dashSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(value) {
          this.uniforms.dashSize.value = value;
        }
      },
      dashOffset: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(value) {
          this.uniforms.dashOffset.value = value;
        }
      },
      gapSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(value) {
          this.uniforms.gapSize.value = value;
        }
      },
      opacity: {
        enumerable: true,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(value) {
          this.uniforms.opacity.value = value;
        }
      },
      resolution: {
        enumerable: true,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(value) {
          this.uniforms.resolution.value.copy(value);
        }
      },
      alphaToCoverage: {
        enumerable: true,
        get: function() {
          return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(value) {
          if (Boolean(value) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_ALPHA_TO_COVERAGE = "";
            this.extensions.derivatives = true;
          } else {
            delete this.defines.USE_ALPHA_TO_COVERAGE;
            this.extensions.derivatives = false;
          }
        }
      }
    });
    this.setValues(parameters);
  }
};

// node_modules/three/examples/jsm/lines/LineSegments2.js
var _start = new Vector3();
var _end = new Vector3();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector3();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint = new Vector3();
var _box2 = new Box3();
var _sphere = new Sphere();
var _clipToWorldVector = new Vector4();
var _ray;
var _lineWidth;
function getWorldSpaceHalfWidth(camera, distance, resolution) {
  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  _clipToWorldVector.x = _lineWidth / resolution.width;
  _clipToWorldVector.y = _lineWidth / resolution.height;
  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));
}
function raycastWorldUnits(lineSegments, intersects) {
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  for (let i = 0, l = segmentCount; i < l; i++) {
    _line.start.fromBufferAttribute(instanceStart, i);
    _line.end.fromBufferAttribute(instanceEnd, i);
    _line.applyMatrix4(matrixWorld);
    const pointOnLine = new Vector3();
    const point = new Vector3();
    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;
    if (isInside) {
      intersects.push({
        point,
        pointOnLine,
        distance: _ray.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv2: null
      });
    }
  }
}
function raycastScreenSpace(lineSegments, camera, intersects) {
  const projectionMatrix = camera.projectionMatrix;
  const material = lineSegments.material;
  const resolution = material.resolution;
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  const near = -camera.near;
  _ray.at(1, _ssOrigin);
  _ssOrigin.w = 1;
  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
  _ssOrigin.applyMatrix4(projectionMatrix);
  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
  _ssOrigin.x *= resolution.x / 2;
  _ssOrigin.y *= resolution.y / 2;
  _ssOrigin.z = 0;
  _ssOrigin3.copy(_ssOrigin);
  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
  for (let i = 0, l = segmentCount; i < l; i++) {
    _start4.fromBufferAttribute(instanceStart, i);
    _end4.fromBufferAttribute(instanceEnd, i);
    _start4.w = 1;
    _end4.w = 1;
    _start4.applyMatrix4(_mvMatrix);
    _end4.applyMatrix4(_mvMatrix);
    const isBehindCameraNear = _start4.z > near && _end4.z > near;
    if (isBehindCameraNear) {
      continue;
    }
    if (_start4.z > near) {
      const deltaDist = _start4.z - _end4.z;
      const t = (_start4.z - near) / deltaDist;
      _start4.lerp(_end4, t);
    } else if (_end4.z > near) {
      const deltaDist = _end4.z - _start4.z;
      const t = (_end4.z - near) / deltaDist;
      _end4.lerp(_start4, t);
    }
    _start4.applyMatrix4(projectionMatrix);
    _end4.applyMatrix4(projectionMatrix);
    _start4.multiplyScalar(1 / _start4.w);
    _end4.multiplyScalar(1 / _end4.w);
    _start4.x *= resolution.x / 2;
    _start4.y *= resolution.y / 2;
    _end4.x *= resolution.x / 2;
    _end4.y *= resolution.y / 2;
    _line.start.copy(_start4);
    _line.start.z = 0;
    _line.end.copy(_end4);
    _line.end.z = 0;
    const param = _line.closestPointToPointParameter(_ssOrigin3, true);
    _line.at(param, _closestPoint);
    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);
    const isInClipSpace = zPos >= -1 && zPos <= 1;
    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;
    if (isInClipSpace && isInside) {
      _line.start.fromBufferAttribute(instanceStart, i);
      _line.end.fromBufferAttribute(instanceEnd, i);
      _line.start.applyMatrix4(matrixWorld);
      _line.end.applyMatrix4(matrixWorld);
      const pointOnLine = new Vector3();
      const point = new Vector3();
      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
      intersects.push({
        point,
        pointOnLine,
        distance: _ray.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv2: null
      });
    }
  }
}
var LineSegments2 = class extends Mesh {
  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLineSegments2 = true;
    this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const geometry = this.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const lineDistances = new Float32Array(2 * instanceStart.count);
    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {
      _start.fromBufferAttribute(instanceStart, i);
      _end.fromBufferAttribute(instanceEnd, i);
      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
    }
    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
    geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
    geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
    return this;
  }
  raycast(raycaster, intersects) {
    const worldUnits = this.material.worldUnits;
    const camera = raycaster.camera;
    if (camera === null && !worldUnits) {
      console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    }
    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
    _ray = raycaster.ray;
    const matrixWorld = this.matrixWorld;
    const geometry = this.geometry;
    const material = this.material;
    _lineWidth = material.linewidth + threshold;
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
    let sphereMargin;
    if (worldUnits) {
      sphereMargin = _lineWidth * 0.5;
    } else {
      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));
      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);
    }
    _sphere.radius += sphereMargin;
    if (_ray.intersectsSphere(_sphere) === false) {
      return;
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    _box2.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
    let boxMargin;
    if (worldUnits) {
      boxMargin = _lineWidth * 0.5;
    } else {
      const distanceToBox = Math.max(camera.near, _box2.distanceToPoint(_ray.origin));
      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);
    }
    _box2.expandByScalar(boxMargin);
    if (_ray.intersectsBox(_box2) === false) {
      return;
    }
    if (worldUnits) {
      raycastWorldUnits(this, intersects);
    } else {
      raycastScreenSpace(this, camera, intersects);
    }
  }
};

// node_modules/three/examples/jsm/lines/LineGeometry.js
var LineGeometry = class extends LineSegmentsGeometry {
  constructor() {
    super();
    this.isLineGeometry = true;
    this.type = "LineGeometry";
  }
  setPositions(array) {
    const length = array.length - 3;
    const points = new Float32Array(2 * length);
    for (let i = 0; i < length; i += 3) {
      points[2 * i] = array[i];
      points[2 * i + 1] = array[i + 1];
      points[2 * i + 2] = array[i + 2];
      points[2 * i + 3] = array[i + 3];
      points[2 * i + 4] = array[i + 4];
      points[2 * i + 5] = array[i + 5];
    }
    super.setPositions(points);
    return this;
  }
  setColors(array) {
    const length = array.length - 3;
    const colors = new Float32Array(2 * length);
    for (let i = 0; i < length; i += 3) {
      colors[2 * i] = array[i];
      colors[2 * i + 1] = array[i + 1];
      colors[2 * i + 2] = array[i + 2];
      colors[2 * i + 3] = array[i + 3];
      colors[2 * i + 4] = array[i + 4];
      colors[2 * i + 5] = array[i + 5];
    }
    super.setColors(colors);
    return this;
  }
  fromLine(line) {
    const geometry = line.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
};

// node_modules/three/examples/jsm/lines/Line2.js
var Line22 = class extends LineSegments2 {
  constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLine2 = true;
    this.type = "Line2";
  }
};

// node_modules/@threlte/core/dist/objects/Line2.svelte
function create_default_slot25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot25.name,
    type: "slot",
    source: "(68:0) <MeshInstance   mesh={line2}   {position}   {scale}   {rotation}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {interactive}   {ignorePointer}   on:click   on:contextmenu   on:pointerup   on:pointerdown   on:pointerenter   on:pointerleave   on:pointermove   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let disposableobject0;
  let t0;
  let disposableobject1;
  let t1;
  let meshinstance;
  let updating_inViewport;
  let current;
  disposableobject0 = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[12]
      ),
      object: (
        /*geometry*/
        ctx[16]
      )
    },
    $$inline: true
  });
  disposableobject1 = new DisposableObject_default({
    props: {
      dispose: true,
      object: (
        /*fallbackGeometry*/
        ctx[17]
      )
    },
    $$inline: true
  });
  function meshinstance_inViewport_binding(value) {
    ctx[22](value);
  }
  let meshinstance_props = {
    mesh: (
      /*line2*/
      ctx[0]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    lookAt: (
      /*lookAt*/
      ctx[15]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    userData: (
      /*userData*/
      ctx[11]
    ),
    dispose: (
      /*dispose*/
      ctx[12]
    ),
    interactive: (
      /*interactive*/
      ctx[13]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[14]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    meshinstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  meshinstance = new MeshInstance_default({
    props: meshinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(meshinstance, "inViewport", meshinstance_inViewport_binding));
  meshinstance.$on(
    "click",
    /*click_handler*/
    ctx[23]
  );
  meshinstance.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[24]
  );
  meshinstance.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[25]
  );
  meshinstance.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[26]
  );
  meshinstance.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[27]
  );
  meshinstance.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[28]
  );
  meshinstance.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[29]
  );
  meshinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[30]
  );
  meshinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[31]
  );
  const block = {
    c: function create() {
      create_component(disposableobject0.$$.fragment);
      t0 = space();
      create_component(disposableobject1.$$.fragment);
      t1 = space();
      create_component(meshinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(disposableobject1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(meshinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(disposableobject1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(meshinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject0_changes = {};
      if (dirty[0] & /*dispose*/
      4096)
        disposableobject0_changes.dispose = /*dispose*/
        ctx2[12];
      if (dirty[0] & /*geometry*/
      65536)
        disposableobject0_changes.object = /*geometry*/
        ctx2[16];
      disposableobject0.$set(disposableobject0_changes);
      const meshinstance_changes = {};
      if (dirty[0] & /*line2*/
      1)
        meshinstance_changes.mesh = /*line2*/
        ctx2[0];
      if (dirty[0] & /*position*/
      4)
        meshinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty[0] & /*scale*/
      8)
        meshinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty[0] & /*rotation*/
      16)
        meshinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty[0] & /*lookAt*/
      32768)
        meshinstance_changes.lookAt = /*lookAt*/
        ctx2[15];
      if (dirty[0] & /*castShadow*/
      64)
        meshinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty[0] & /*receiveShadow*/
      128)
        meshinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty[0] & /*frustumCulled*/
      256)
        meshinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty[0] & /*renderOrder*/
      512)
        meshinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty[0] & /*visible*/
      1024)
        meshinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty[0] & /*userData*/
      2048)
        meshinstance_changes.userData = /*userData*/
        ctx2[11];
      if (dirty[0] & /*dispose*/
      4096)
        meshinstance_changes.dispose = /*dispose*/
        ctx2[12];
      if (dirty[0] & /*interactive*/
      8192)
        meshinstance_changes.interactive = /*interactive*/
        ctx2[13];
      if (dirty[0] & /*ignorePointer*/
      16384)
        meshinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[14];
      if (dirty[0] & /*viewportAware*/
      32)
        meshinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty[1] & /*$$scope*/
      2) {
        meshinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      2) {
        updating_inViewport = true;
        meshinstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      meshinstance.$set(meshinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject0.$$.fragment, local);
      transition_in(disposableobject1.$$.fragment, local);
      transition_in(meshinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject0.$$.fragment, local);
      transition_out(disposableobject1.$$.fragment, local);
      transition_out(meshinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(disposableobject1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(meshinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line2", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { points = [] } = $$props;
  let { material } = $$props;
  let fallbackGeometry = new LineGeometry();
  fallbackGeometry.setPositions([0, 0, 0]);
  let geometry = void 0;
  const line2 = new Line22(void 0, material);
  onDestroy(() => {
    fallbackGeometry.dispose();
    geometry == null ? void 0 : geometry.dispose();
  });
  const getLine = () => line2;
  const { invalidate } = useThrelte();
  let previousMaterial = material;
  $$self.$$.on_mount.push(function() {
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console.warn("<Line2> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "interactive",
    "ignorePointer",
    "lookAt",
    "points",
    "material"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Line2> was created with unknown prop '${key}'`);
  });
  function meshinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(13, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(14, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(15, lookAt = $$props2.lookAt);
    if ("points" in $$props2)
      $$invalidate(18, points = $$props2.points);
    if ("material" in $$props2)
      $$invalidate(19, material = $$props2.material);
    if ("$$scope" in $$props2)
      $$invalidate(32, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    Vector3,
    ThreeLine2: Line22,
    LineGeometry,
    useThrelte,
    MeshInstance: MeshInstance_default,
    DisposableObject: DisposableObject_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    points,
    material,
    fallbackGeometry,
    geometry,
    line2,
    getLine,
    invalidate,
    previousMaterial
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(11, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(12, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(13, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(14, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(15, lookAt = $$props2.lookAt);
    if ("points" in $$props2)
      $$invalidate(18, points = $$props2.points);
    if ("material" in $$props2)
      $$invalidate(19, material = $$props2.material);
    if ("fallbackGeometry" in $$props2)
      $$invalidate(17, fallbackGeometry = $$props2.fallbackGeometry);
    if ("geometry" in $$props2)
      $$invalidate(16, geometry = $$props2.geometry);
    if ("previousMaterial" in $$props2)
      $$invalidate(20, previousMaterial = $$props2.previousMaterial);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*geometry, points, line2*/
    327681) {
      $: {
        geometry == null ? void 0 : geometry.dispose();
        if (points.length) {
          $$invalidate(16, geometry = new LineGeometry());
          geometry.setPositions(points.map((p) => p instanceof Vector3 ? p.toArray() : p).flat());
          $$invalidate(0, line2.geometry = geometry, line2);
        } else {
          $$invalidate(0, line2.geometry = fallbackGeometry, line2);
        }
        line2.computeLineDistances();
        invalidate("Line2: points changed");
      }
    }
    if ($$self.$$.dirty[0] & /*material, previousMaterial*/
    1572864) {
      $: {
        if (material !== previousMaterial) {
          getLine().material = material;
          invalidate("Line2: material changed");
        } else {
          invalidate("Line2: material props changed");
        }
        $$invalidate(20, previousMaterial = material);
      }
    }
  };
  return [
    line2,
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    fallbackGeometry,
    points,
    material,
    previousMaterial,
    slots,
    meshinstance_inViewport_binding,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Line23 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance38,
      create_fragment39,
      safe_not_equal,
      {
        position: 2,
        scale: 3,
        rotation: 4,
        viewportAware: 5,
        inViewport: 1,
        castShadow: 6,
        receiveShadow: 7,
        frustumCulled: 8,
        renderOrder: 9,
        visible: 10,
        userData: 11,
        dispose: 12,
        interactive: 13,
        ignorePointer: 14,
        lookAt: 15,
        points: 18,
        material: 19,
        line2: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line2",
      options,
      id: create_fragment39.name
    });
  }
  get position() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get points() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set points(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get line2() {
    return this.$$.ctx[0];
  }
  set line2(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Line2_default = Line23;

// node_modules/@threlte/core/dist/objects/LineSegments.svelte
function create_default_slot26(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot26.name,
    type: "slot",
    source: "(54:0) <LineInstance   line={lineSegments}   {position}   {scale}   {rotation}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {userData}   {dispose}   {interactive}   {ignorePointer}   on:click   on:contextmenu   on:pointerup   on:pointerdown   on:pointerenter   on:pointerleave   on:pointermove   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment40(ctx) {
  let disposableobject0;
  let t0;
  let disposableobject1;
  let t1;
  let lineinstance;
  let updating_inViewport;
  let current;
  disposableobject0 = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[11]
      ),
      object: (
        /*geometry*/
        ctx[15]
      )
    },
    $$inline: true
  });
  disposableobject1 = new DisposableObject_default({
    props: {
      dispose: (
        /*dispose*/
        ctx[11]
      ),
      object: (
        /*material*/
        ctx[16]
      )
    },
    $$inline: true
  });
  function lineinstance_inViewport_binding(value) {
    ctx[21](value);
  }
  let lineinstance_props = {
    line: (
      /*lineSegments*/
      ctx[17]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[14]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    userData: (
      /*userData*/
      ctx[10]
    ),
    dispose: (
      /*dispose*/
      ctx[11]
    ),
    interactive: (
      /*interactive*/
      ctx[12]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[13]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    ),
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lineinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lineinstance = new LineInstance_default({
    props: lineinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lineinstance, "inViewport", lineinstance_inViewport_binding));
  lineinstance.$on(
    "click",
    /*click_handler*/
    ctx[22]
  );
  lineinstance.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[23]
  );
  lineinstance.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[24]
  );
  lineinstance.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[25]
  );
  lineinstance.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[26]
  );
  lineinstance.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[27]
  );
  lineinstance.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[28]
  );
  lineinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[29]
  );
  lineinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[30]
  );
  const block = {
    c: function create() {
      create_component(disposableobject0.$$.fragment);
      t0 = space();
      create_component(disposableobject1.$$.fragment);
      t1 = space();
      create_component(lineinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(disposableobject1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(lineinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(disposableobject1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(lineinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject0_changes = {};
      if (dirty[0] & /*dispose*/
      2048)
        disposableobject0_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*geometry*/
      32768)
        disposableobject0_changes.object = /*geometry*/
        ctx2[15];
      disposableobject0.$set(disposableobject0_changes);
      const disposableobject1_changes = {};
      if (dirty[0] & /*dispose*/
      2048)
        disposableobject1_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*material*/
      65536)
        disposableobject1_changes.object = /*material*/
        ctx2[16];
      disposableobject1.$set(disposableobject1_changes);
      const lineinstance_changes = {};
      if (dirty[0] & /*position*/
      2)
        lineinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        lineinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        lineinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*lookAt*/
      16384)
        lineinstance_changes.lookAt = /*lookAt*/
        ctx2[14];
      if (dirty[0] & /*castShadow*/
      32)
        lineinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        lineinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*frustumCulled*/
      128)
        lineinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty[0] & /*renderOrder*/
      256)
        lineinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        lineinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*userData*/
      1024)
        lineinstance_changes.userData = /*userData*/
        ctx2[10];
      if (dirty[0] & /*dispose*/
      2048)
        lineinstance_changes.dispose = /*dispose*/
        ctx2[11];
      if (dirty[0] & /*interactive*/
      4096)
        lineinstance_changes.interactive = /*interactive*/
        ctx2[12];
      if (dirty[0] & /*ignorePointer*/
      8192)
        lineinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[13];
      if (dirty[0] & /*viewportAware*/
      16)
        lineinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (dirty[1] & /*$$scope*/
      1) {
        lineinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        lineinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lineinstance.$set(lineinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject0.$$.fragment, local);
      transition_in(disposableobject1.$$.fragment, local);
      transition_in(lineinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject0.$$.fragment, local);
      transition_out(disposableobject1.$$.fragment, local);
      transition_out(lineinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(disposableobject1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(lineinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineSegments", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { geometry } = $$props;
  let { material } = $$props;
  let previousMaterial = material;
  let previousGeometry = geometry;
  const { invalidate } = useThrelte();
  const lineSegments = new LineSegments(geometry, material);
  const getLineSegments = () => lineSegments;
  $$self.$$.on_mount.push(function() {
    if (geometry === void 0 && !("geometry" in $$props || $$self.$$.bound[$$self.$$.props["geometry"]])) {
      console.warn("<LineSegments> was created without expected prop 'geometry'");
    }
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console.warn("<LineSegments> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "userData",
    "dispose",
    "interactive",
    "ignorePointer",
    "lookAt",
    "geometry",
    "material"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LineSegments> was created with unknown prop '${key}'`);
  });
  function lineinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(14, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(15, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(16, material = $$props2.material);
    if ("$$scope" in $$props2)
      $$invalidate(31, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeLineSegments: LineSegments,
    useThrelte,
    LineInstance: LineInstance_default,
    DisposableObject: DisposableObject_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    previousMaterial,
    previousGeometry,
    invalidate,
    lineSegments,
    getLineSegments
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("userData" in $$props2)
      $$invalidate(10, userData = $$props2.userData);
    if ("dispose" in $$props2)
      $$invalidate(11, dispose = $$props2.dispose);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(14, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(15, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(16, material = $$props2.material);
    if ("previousMaterial" in $$props2)
      $$invalidate(18, previousMaterial = $$props2.previousMaterial);
    if ("previousGeometry" in $$props2)
      $$invalidate(19, previousGeometry = $$props2.previousGeometry);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*material, previousMaterial*/
    327680) {
      $: {
        if (material !== previousMaterial) {
          getLineSegments().material = material;
          invalidate("LineSegments: material changed");
        } else {
          invalidate("LineSegments: material props changed");
        }
        $$invalidate(18, previousMaterial = material);
      }
    }
    if ($$self.$$.dirty[0] & /*geometry, previousGeometry*/
    557056) {
      $: {
        if (geometry !== previousGeometry) {
          getLineSegments().geometry = geometry;
          invalidate("LineSegments: geometry changed");
        } else {
          invalidate("LineSegments: geometry props changed");
        }
        $$invalidate(19, previousGeometry = geometry);
      }
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    userData,
    dispose,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    lineSegments,
    previousMaterial,
    previousGeometry,
    slots,
    lineinstance_inViewport_binding,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var LineSegments3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance39,
      create_fragment40,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        frustumCulled: 7,
        renderOrder: 8,
        visible: 9,
        userData: 10,
        dispose: 11,
        interactive: 12,
        ignorePointer: 13,
        lookAt: 14,
        geometry: 15,
        material: 16,
        lineSegments: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineSegments",
      options,
      id: create_fragment40.name
    });
  }
  get position() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineSegments() {
    return this.$$.ctx[17];
  }
  set lineSegments(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineSegments_default = LineSegments3;

// node_modules/@threlte/core/dist/three/lib/resolve.js
var resolve = (target, propertyPath) => {
  if (propertyPath.includes(".")) {
    const path = propertyPath.split(".");
    const key = path.pop();
    for (let i = 0; i < path.length; i += 1) {
      target = target[path[i]];
    }
    return {
      target,
      key
    };
  } else {
    return {
      target,
      key: propertyPath
    };
  }
};

// node_modules/@threlte/core/dist/three/lib/useAttach.js
var initialValueBeforeAttach = Symbol("initialValueBeforeAttach");
var useAttach = () => {
  const { invalidate } = useThrelte();
  let isAttached = false;
  let valueBeforeAttach = initialValueBeforeAttach;
  let detachFn;
  let attachedTo;
  let attachedKey;
  const update = (instance42, parent, attach) => {
    detach();
    if (!attach) {
      const i = instance42;
      const isMaterial = (i == null ? void 0 : i.isMaterial) || false;
      if (isMaterial) {
        attach = "material";
      }
      const isGeometry = (i == null ? void 0 : i.isBufferGeometry) || (i == null ? void 0 : i.isGeometry) || false;
      if (isGeometry) {
        attach = "geometry";
      }
    }
    if (!attach)
      return;
    if (typeof attach === "function") {
      detachFn = attach(parent, instance42);
    } else {
      const { target, key } = resolve(parent, attach);
      valueBeforeAttach = target[key];
      target[key] = instance42;
      attachedTo = target;
      attachedKey = key;
    }
    isAttached = true;
    invalidate();
  };
  const detach = () => {
    if (!isAttached)
      return;
    if (detachFn) {
      detachFn();
      detachFn = void 0;
    } else if (attachedTo && attachedKey && valueBeforeAttach !== initialValueBeforeAttach) {
      attachedTo[attachedKey] = valueBeforeAttach;
      valueBeforeAttach = initialValueBeforeAttach;
      attachedTo = void 0;
      attachedKey = void 0;
    }
    isAttached = false;
    invalidate();
  };
  onDestroy(() => {
    detach();
  });
  return {
    update
  };
};

// node_modules/@threlte/core/dist/three/lib/useCamera.js
var isCamera = (value) => {
  return value && value.isCamera;
};
var isOrthographicCamera = (value) => {
  return value && value.isOrthographicCamera;
};
var isPerspectiveCamera = (value) => {
  return value && value.isPerspectiveCamera;
};
var isPerspectiveCameraOrOrthographicCamera = (value) => {
  return isPerspectiveCamera(value) || isOrthographicCamera(value);
};
var useCamera = () => {
  const { invalidate, size } = useThrelte();
  const { setCamera } = useThrelteRoot();
  let currentInstance;
  let unsubscribe = void 0;
  onDestroy(() => {
    unsubscribe == null ? void 0 : unsubscribe();
  });
  const subscriber = (size2) => {
    if (!currentInstance)
      return;
    if (isOrthographicCamera(currentInstance)) {
      currentInstance.left = size2.width / -2;
      currentInstance.right = size2.width / 2;
      currentInstance.top = size2.height / 2;
      currentInstance.bottom = size2.height / -2;
      currentInstance.updateProjectionMatrix();
      currentInstance.updateMatrixWorld();
      invalidate();
    } else if (isPerspectiveCamera(currentInstance)) {
      currentInstance.aspect = size2.width / size2.height;
      currentInstance.updateProjectionMatrix();
      currentInstance.updateMatrixWorld();
      invalidate();
    }
  };
  const update = (instance42, manual) => {
    unsubscribe == null ? void 0 : unsubscribe();
    if (manual || !isPerspectiveCameraOrOrthographicCamera(instance42)) {
      currentInstance = void 0;
      return;
    }
    currentInstance = instance42;
    unsubscribe = size.subscribe(subscriber);
  };
  const makeDefaultCamera = (instance42, makeDefault) => {
    if (!isCamera(instance42) || !makeDefault)
      return;
    setCamera(instance42);
    invalidate();
  };
  return {
    update,
    makeDefaultCamera
  };
};

// node_modules/@threlte/core/dist/three/lib/useEvents.js
var isEventDispatcher = (value) => {
  return !!(value == null ? void 0 : value.addEventListener);
};
var useEvents = () => {
  const dispatch = createEventDispatcher();
  const component = get_current_component();
  const eventHandlerProxy = (event) => {
    if (event == null ? void 0 : event.type) {
      dispatch(event.type, event);
    }
  };
  const cleanupEventListeners = (ref2, events) => {
    if (isEventDispatcher(ref2)) {
      events.forEach((eventName) => {
        ref2.removeEventListener(eventName, eventHandlerProxy);
      });
    }
  };
  const addEventListeners = (ref2, events) => {
    if (isEventDispatcher(ref2)) {
      events.forEach((eventName) => {
        ref2.addEventListener(eventName, eventHandlerProxy);
      });
    }
  };
  let currentEventNames = [];
  let currentRef;
  const eventNames = writable([]);
  const unsubscribeEventNames = eventNames.subscribe((eventNames2) => {
    cleanupEventListeners(currentRef, currentEventNames);
    addEventListeners(currentRef, eventNames2);
    currentEventNames = eventNames2;
  });
  onDestroy(unsubscribeEventNames);
  const ref = writable();
  const unsubscribeRef = ref.subscribe((value) => {
    cleanupEventListeners(currentRef, currentEventNames);
    addEventListeners(value, currentEventNames);
    currentRef = value;
  });
  onDestroy(unsubscribeRef);
  onDestroy(() => {
    cleanupEventListeners(currentRef, currentEventNames);
  });
  onMount(() => {
    eventNames.set(Object.keys(component.$$.callbacks));
  });
  const updateRef = (newRef) => {
    ref.set(newRef);
  };
  return {
    updateRef
  };
};

// node_modules/@threlte/core/dist/three/lib/useProps.js
var ignoredProps = ["$$scope", "$$slots", "type", "args", "attach", "instance"];
var updateProjectionMatrixKeys = [
  "fov",
  "aspect",
  "near",
  "far",
  "left",
  "right",
  "top",
  "bottom",
  "zoom"
];
var memoizeProp = (value) => {
  if (typeof value === "string")
    return true;
  if (typeof value === "number")
    return true;
  if (typeof value === "boolean")
    return true;
  if (typeof value === "undefined")
    return true;
  if (value === null)
    return true;
  return false;
};
var useProps = () => {
  const { invalidate } = useThrelte();
  const memoizedProps = /* @__PURE__ */ new Map();
  const setProp = (instance42, propertyPath, value, options) => {
    var _a, _b;
    if (memoizeProp(value)) {
      const memoizedProp = memoizedProps.get(propertyPath);
      if (memoizedProp && memoizedProp.instance === instance42 && memoizedProp.value === value) {
        return;
      }
      memoizedProps.set(propertyPath, {
        instance: instance42,
        value
      });
    }
    const { key, target } = resolve(instance42, propertyPath);
    if (!Array.isArray(value) && typeof value === "number" && typeof ((_a = target[key]) == null ? void 0 : _a.setScalar) === "function") {
      target[key].setScalar(value);
    } else {
      if (typeof ((_b = target[key]) == null ? void 0 : _b.set) === "function") {
        if (Array.isArray(value)) {
          target[key].set(...value);
        } else {
          target[key].set(value);
        }
      } else {
        target[key] = value;
        if (options.manualCamera)
          return;
        if (updateProjectionMatrixKeys.includes(key) && (target.isPerspectiveCamera || target.isOrthographicCamera)) {
          target.updateProjectionMatrix();
        }
      }
    }
  };
  const updateProps = (instance42, props, options) => {
    for (const key in props) {
      if (!ignoredProps.includes(key)) {
        setProp(instance42, key, props[key], options);
      }
      invalidate();
    }
  };
  return {
    updateProps
  };
};

// node_modules/@threlte/core/dist/three/Three.svelte
var get_default_slot_changes_1 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context_1 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
var get_default_slot_changes = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_if_block_1(ctx) {
  let disposableobject;
  let current;
  disposableobject = new DisposableObject_default({
    props: {
      object: (
        /*ref*/
        ctx[0]
      ),
      dispose: (
        /*dispose*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(disposableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject_changes = {};
      if (dirty & /*ref*/
      1)
        disposableobject_changes.object = /*ref*/
        ctx2[0];
      if (dirty & /*dispose*/
      2)
        disposableobject_changes.dispose = /*dispose*/
        ctx2[1];
      disposableobject.$set(disposableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(66:0) {#if isDisposableObject(ref)}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context_1
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        8193)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(77:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let scenegraphobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*ref*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot27] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const scenegraphobject_changes = {};
      if (dirty & /*ref*/
      1)
        scenegraphobject_changes.object = /*ref*/
        ctx2[0];
      if (dirty & /*$$scope, ref*/
      8193) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(73:0) {#if extendsObject3D(ref)}",
    ctx
  });
  return block;
}
function create_default_slot27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        8193)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot27.name,
    type: "slot",
    source: "(74:2) <SceneGraphObject object={ref}>",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let show_if_1 = (
    /*isDisposableObject*/
    ctx[4](
      /*ref*/
      ctx[0]
    )
  );
  let t;
  let show_if;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  let if_block0 = show_if_1 && create_if_block_1(ctx);
  const if_block_creators = [create_if_block5, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*ref*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!/*extendsObject3D*/
      ctx2[3](
        /*ref*/
        ctx2[0]
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*ref*/
      1)
        show_if_1 = /*isDisposableObject*/
        ctx2[4](
          /*ref*/
          ctx2[0]
        );
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*ref*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "args", "attach", "manual", "makeDefault", "dispose", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Three", slots, ["default"]);
  let { type } = $$props;
  let { args = void 0 } = $$props;
  let { attach = void 0 } = $$props;
  let { manual = void 0 } = $$props;
  let { makeDefault = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  const parent = getContext("threlte-hierarchical-parent-context");
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(11, $parent = value));
  const isClass = (type2) => {
    return typeof type2 === "function" && /^\s*class\s+/.test(type2.toString());
  };
  const argsIsConstructorParameters = (args2) => {
    return Array.isArray(args2);
  };
  let { ref = isClass(type) && argsIsConstructorParameters(args) ? new type(...args) : isClass(type) ? new type() : type } = $$props;
  let initialized = false;
  const objectStore = writable(ref);
  setContext("threlte-hierarchical-parent-context", objectStore);
  const props = useProps();
  const camera = useCamera();
  const attachment = useAttach();
  const events = useEvents();
  const extendsObject3D = (object) => {
    return !!object.isObject3D;
  };
  const isDisposableObject = (object) => {
    return object.dispose !== void 0;
  };
  $$self.$$.on_mount.push(function() {
    if (type === void 0 && !("type" in $$props || $$self.$$.bound[$$self.$$.props["type"]])) {
      console.warn("<Three> was created without expected prop 'type'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(5, type = $$new_props.type);
    if ("args" in $$new_props)
      $$invalidate(6, args = $$new_props.args);
    if ("attach" in $$new_props)
      $$invalidate(7, attach = $$new_props.attach);
    if ("manual" in $$new_props)
      $$invalidate(8, manual = $$new_props.manual);
    if ("makeDefault" in $$new_props)
      $$invalidate(9, makeDefault = $$new_props.makeDefault);
    if ("dispose" in $$new_props)
      $$invalidate(1, dispose = $$new_props.dispose);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    writable,
    DisposableObject: DisposableObject_default,
    SceneGraphObject: SceneGraphObject_default,
    useAttach,
    useCamera,
    useEvents,
    useProps,
    type,
    args,
    attach,
    manual,
    makeDefault,
    dispose,
    parent,
    isClass,
    argsIsConstructorParameters,
    ref,
    initialized,
    objectStore,
    props,
    camera,
    attachment,
    events,
    extendsObject3D,
    isDisposableObject,
    $parent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props)
      $$invalidate(5, type = $$new_props.type);
    if ("args" in $$props)
      $$invalidate(6, args = $$new_props.args);
    if ("attach" in $$props)
      $$invalidate(7, attach = $$new_props.attach);
    if ("manual" in $$props)
      $$invalidate(8, manual = $$new_props.manual);
    if ("makeDefault" in $$props)
      $$invalidate(9, makeDefault = $$new_props.makeDefault);
    if ("dispose" in $$props)
      $$invalidate(1, dispose = $$new_props.dispose);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("initialized" in $$props)
      $$invalidate(10, initialized = $$new_props.initialized);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*initialized, type, args*/
    1120) {
      $:
        if (initialized) {
          $$invalidate(0, ref = isClass(type) && argsIsConstructorParameters(args) ? new type(...args) : isClass(type) ? new type() : type);
        } else {
          $$invalidate(10, initialized = true);
        }
    }
    if ($$self.$$.dirty & /*ref*/
    1) {
      $:
        objectStore.set(ref);
    }
    $:
      props.updateProps(ref, $$restProps, { manualCamera: manual });
    if ($$self.$$.dirty & /*ref, manual*/
    257) {
      $:
        camera.update(ref, manual);
    }
    if ($$self.$$.dirty & /*ref, makeDefault*/
    513) {
      $:
        camera.makeDefaultCamera(ref, makeDefault);
    }
    if ($$self.$$.dirty & /*ref, $parent, attach*/
    2177) {
      $:
        attachment.update(ref, $parent, attach);
    }
    if ($$self.$$.dirty & /*ref*/
    1) {
      $:
        events.updateRef(ref);
    }
  };
  return [
    ref,
    dispose,
    parent,
    extendsObject3D,
    isDisposableObject,
    type,
    args,
    attach,
    manual,
    makeDefault,
    initialized,
    $parent,
    slots,
    $$scope
  ];
}
var Three = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment41, safe_not_equal, {
      type: 5,
      args: 6,
      attach: 7,
      manual: 8,
      makeDefault: 9,
      dispose: 1,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Three",
      options,
      id: create_fragment41.name
    });
  }
  get type() {
    throw new Error("<Three>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Three>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get args() {
    throw new Error("<Three>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set args(value) {
    throw new Error("<Three>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attach() {
    throw new Error("<Three>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attach(value) {
    throw new Error("<Three>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get manual() {
    throw new Error("<Three>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set manual(value) {
    throw new Error("<Three>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get makeDefault() {
    throw new Error("<Three>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set makeDefault(value) {
    throw new Error("<Three>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<Three>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<Three>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Three>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Three>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Three_default = Three;

// node_modules/@threlte/core/dist/three/PreprocessFallback.svelte
var { console: console_14 } = globals;
function create_fragment42(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PreprocessFallback", slots, []);
  "use strict";
  console.error("The component <T> can only be used in conjunction with the custom preprocessor.");
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_14.warn(`<PreprocessFallback> was created with unknown prop '${key}'`);
  });
  return [];
}
var PreprocessFallback = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PreprocessFallback",
      options,
      id: create_fragment42.name
    });
  }
};
var PreprocessFallback_default = PreprocessFallback;

// node_modules/@threlte/core/dist/three/T.js
var T = new Proxy(PreprocessFallback_default, {
  get(target, prop) {
    return target[prop] || PreprocessFallback_default;
  }
});

// node_modules/@threlte/core/dist/hooks/useTexture.js
var loader = useLoader(TextureLoader, () => new TextureLoader(DefaultLoadingManager));
var loadTexture = (path, options) => {
  return loader.load(path, (t) => {
    var _a;
    invalidateGlobally("useTexture");
    (_a = options == null ? void 0 : options.onLoad) == null ? void 0 : _a.call(options, t);
  }, (e) => {
    var _a;
    (_a = options == null ? void 0 : options.onProgress) == null ? void 0 : _a.call(options, e);
  }, (e) => {
    var _a;
    (_a = options == null ? void 0 : options.onError) == null ? void 0 : _a.call(options, e);
  });
};
var pathsIsString = (paths) => {
  return typeof paths === "string";
};
var pathsIsArray = (paths) => {
  return Array.isArray(paths);
};
var convertTextureColor = (texture) => {
  try {
    const rootCtx = useThrelteRoot();
    if (!rootCtx)
      return texture;
    if (!get_store_value(rootCtx.linear))
      texture.encoding = sRGBEncoding;
  } catch (error) {
    console.warn("Calling useTexture outside component initialization does not support color correction.");
  }
  return texture;
};
function useTexture(paths, options) {
  if (pathsIsString(paths)) {
    if (!browser)
      return new Texture();
    return convertTextureColor(loadTexture(paths, options));
  } else if (pathsIsArray(paths)) {
    if (!browser) {
      return paths.map(() => new Texture());
    }
    return paths.map((path) => convertTextureColor(loadTexture(path, options)));
  } else {
    const entries = Object.entries(paths);
    const map = entries.reduce((acc, [key, value]) => {
      acc[key] = browser ? loadTexture(value, options) : new Texture();
      return acc;
    }, {});
    return map;
  }
}

// node_modules/@threlte/core/dist/hooks/useAudioListener.js
function useAudioListener(callbackOrId, id) {
  const audioCtx = useThrelteAudio();
  if (!audioCtx) {
    throw new Error('No threlte audio context found, "useAudioListener" can only be used in a child component of <Canvas>');
  }
  if (callbackOrId && typeof callbackOrId === "string") {
    const listener = audioCtx.getAudioListener(callbackOrId);
    if (!listener)
      throw new Error("No AudioListener found.");
    return {
      listener,
      context: listener.context
    };
  } else if (callbackOrId && typeof callbackOrId === "function") {
    const listener = audioCtx.getAudioListener(id);
    if (!listener)
      throw new Error("No AudioListener found.");
    return callbackOrId({
      listener,
      context: listener.context
    });
  } else {
    const listener = audioCtx.getAudioListener();
    if (!listener)
      throw new Error("No AudioListener found.");
    return {
      listener,
      context: listener.context
    };
  }
}

export {
  createObjectStore,
  useThrelte,
  useParent,
  HierarchicalObject_default,
  SceneGraphObject_default,
  Canvas_default,
  useThrelteRoot,
  DisposableObject_default,
  LayerableObject_default,
  useFrame,
  TransformableObject_default,
  ViewportAwareObject_default,
  Object3DInstance_default,
  CameraInstance_default,
  OrthographicCamera_default,
  PerspectiveCamera_default,
  useThrelteAudio,
  AudioListener_default,
  useLoader,
  Audio_default,
  PositionalAudio_default,
  PositionalAudioHelper_default,
  OrbitControls_default,
  TransformControls_default,
  Pass_default,
  LightInstance_default,
  AmbientLight_default,
  DirectionalLight_default,
  PointLight_default,
  HemisphereLight_default,
  SpotLight_default,
  Fog_default,
  FogExp2_default,
  Layers_default,
  ContextBridge_default,
  InteractiveObject_default,
  MeshInstance_default,
  Mesh_default,
  InstancedMesh_default,
  Instance_default,
  Group_default,
  Object3D_default,
  LineInstance_default,
  Line_default,
  Line2_default,
  LineSegments_default,
  Three_default,
  T,
  useTexture,
  useAudioListener
};
//# sourceMappingURL=chunk-VNELLRGH.js.map
